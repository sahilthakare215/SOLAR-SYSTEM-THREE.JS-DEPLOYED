import { BaseEvent, EventDispatcher, Material, Object3D, OrthographicCamera, PerspectiveCamera, Scene, Texture, WebGLRenderTarget, WebGLRenderer } from "three";
import { ImmutableTimer } from "../utils/ImmutableTimer.js";
import { Resolution } from "../utils/Resolution.js";
import { Scissor } from "../utils/Scissor.js";
import { Viewport } from "../utils/Viewport.js";
import { BaseEventMap } from "./BaseEventMap.js";
import { Disposable } from "./Disposable.js";
import { Identifiable } from "./Identifiable.js";
import { Input } from "./io/Input.js";
import { Output } from "./io/Output.js";
import { Renderable } from "./Renderable.js";
/**
 * Pass events.
 *
 * @category Core
 */
export interface PassEventMap extends BaseEventMap {
    /**
     * Triggers when the pass gets enabled or disabled.
     *
     * @event
     */
    toggle: BaseEvent;
}
/**
 * An abstract pass.
 *
 * @param TMaterial - The type of the fullscreen material, or null if this pass has none.
 * @category Core
 */
export declare abstract class Pass<TMaterial extends Material | null = null> extends EventDispatcher<PassEventMap> implements Disposable, Identifiable, Renderable {
    /**
     * An ID manager.
     */
    private static idManager;
    /**
     * A collection of scene event helpers.
     *
     * One helper is created per scene to efficiently forward events of all child objects.
     */
    private static sceneEventTargets;
    readonly id: number;
    /**
     * A listener for events dispatched by the {@link scene}.
     */
    private readonly sceneListener;
    /**
     * A container that keeps track of input shader data.
     */
    private readonly shaderDataTracker;
    /**
     * A scene that contains the fullscreen mesh.
     */
    private fullscreenScene;
    /**
     * A fullscreen camera.
     */
    private fullscreenCamera;
    /**
     * A fullscreen mesh.
     */
    private screen;
    /**
     * @see {@link Pass.prototype.name}
     */
    private _name;
    /**
     * @see {@link enabled}
     */
    private _enabled;
    /**
     * @see {@link attached}
     */
    private _attached;
    /**
     * @see {@link autoSyncDefaultBuffers}
     */
    private _autoSyncDefaultBuffers;
    /**
     * @see {@link timer}
     */
    private _timer;
    /**
     * @see {@link renderer}
     */
    private _renderer;
    /**
     * @see {@link scene}
     */
    private _scene;
    /**
     * @see {@link camera}
     */
    private _camera;
    /**
     * @see {@link subpasses}
     */
    private _subpasses;
    /**
     * A collection of objects that will be disposed when this pass is disposed.
     *
     * IO resources, materials and subpasses will be disposed separately and don't need to be added.
     */
    protected readonly disposables: Set<Disposable>;
    /**
     * A collection of fullscreen materials that are used by this pass.
     *
     * This only needs to be filled if multiple fullscreen materials are used. The initial {@link fullscreenMaterial}
     * will automatically be added.
     */
    protected readonly materials: Set<TMaterial>;
    /**
     * The current resolution.
     */
    readonly resolution: Resolution;
    /**
     * The viewport.
     *
     * @see {@link Viewport.enabled} to enable the viewport.
     */
    readonly viewport: Viewport;
    /**
     * A rectangular area inside the viewport. Fragments that are outside the area will not be rendered.
     *
     * @see {@link Scissor.enabled} to enable the scissor.
     */
    readonly scissor: Scissor;
    /**
     * The input resources of this pass.
     */
    readonly input: Input;
    /**
     * The output resources of this pass.
     */
    readonly output: Output;
    /**
     * Constructs a new pass.
     *
     * @param name - A name that will be used for debugging purposes.
     */
    constructor(name: string);
    /**
     * The name of this pass.
     */
    get name(): string;
    protected set name(value: string);
    /**
     * Indicates whether this pass is enabled.
     *
     * @defaultValue true
     */
    get enabled(): boolean;
    set enabled(value: boolean);
    /**
     * Indicates whether this pass is currently attached to another pass or a render pipeline.
     */
    get attached(): boolean;
    set attached(value: boolean);
    /**
     * Controls whether the settings of the input and output default buffers should be synchronized.
     *
     * @defaultValue true
     */
    protected get autoSyncDefaultBuffers(): boolean;
    protected set autoSyncDefaultBuffers(value: boolean);
    /**
     * A list of subpasses.
     *
     * Subpasses are included in automatic resource optimizations and will be disposed when the parent pass is disposed.
     * The resolution, viewport and scissor of the subpasses are also kept in sync with the parent pass.
     *
     * They also gain access to the following data:
     * - {@link timer}
     * - {@link renderer}
     * - {@link scene}
     * - {@link camera}
     * - {@link attached}
     */
    get subpasses(): readonly Pass<Material | null>[];
    protected set subpasses(value: Pass<Material | null>[]);
    /**
     * A timer.
     */
    get timer(): ImmutableTimer | null;
    set timer(value: ImmutableTimer | null);
    /**
     * The current renderer.
     */
    get renderer(): WebGLRenderer | null;
    set renderer(value: WebGLRenderer | null);
    /**
     * The main scene.
     */
    get scene(): Scene | null;
    set scene(value: Scene | null);
    /**
     * The main camera.
     */
    get camera(): OrthographicCamera | PerspectiveCamera | null;
    set camera(value: OrthographicCamera | PerspectiveCamera | null);
    /**
     * The current fullscreen material.
     */
    get fullscreenMaterial(): TMaterial;
    protected set fullscreenMaterial(value: TMaterial);
    /**
     * Sets the base settings of all subpasses.
     */
    private initializeSubpasses;
    /**
     * Updates the resolution of all subpasses.
     */
    private updateSubpassResolution;
    /**
     * Updates the viewport of all subpasses.
     */
    private updateSubpassViewport;
    /**
     * Updates the scissor of all subpasses.
     */
    private updateSubpassScissor;
    /**
     * Updates the size of the default output buffer, if it exists.
     */
    private updateOutputBufferSize;
    /**
     * Updates the viewport and scissor based on the current resolution.
     */
    private updateViewportAndScissor;
    /**
     * Updates the size of the given material.
     */
    private updateFullscreenMaterialResolution;
    /**
     * Updates the size of the fullscreen materials.
     */
    private updateFullscreenMaterialsResolution;
    /**
     * Updates the shader input data of the given fullscreen material.
     *
     * @param material - The material to update.
     */
    private updateFullscreenMaterialInput;
    /**
     * Updates the shader input data of all fullscreen {@link materials}.
     */
    private updateFullscreenMaterialsInput;
    /**
     * Updates the shader output settings of all fullscreen {@link materials}.
     */
    private updateFullscreenMaterialsOutput;
    /**
     * Synchronizes the texture settings of the input and output default buffers.
     *
     * This method ensures that the output buffer uses adequate settings for storing values from the input buffer.
     */
    private syncDefaultBuffers;
    /**
     * Checks if this pass uses convolution shaders.
     *
     * Only works on passes that use a `FullscreenMaterial`.
     *
     * @param recursive - Controls whether subpasses should be checked recursively.
     * @return True if the pass uses convolution shaders.
     */
    isConvolutionPass(recursive: boolean): boolean;
    /**
     * Checks if the current renderer supports all features that are required by this pass.
     *
     * Override this method to check if the current device supports the necessary features.
     * This method should throw an error if the requirements are not met.
     *
     * @throws If the device doesn't meet the requirements.
     */
    checkRequirements(): void;
    /**
     * Performs tasks when the input resources have changed.
     *
     * Override this empty method to handle input changes.
     */
    protected onInputChange(): void;
    /**
     * Performs tasks when the output resources have changed.
     *
     * Override this empty method to handle output changes.
     */
    protected onOutputChange(): void;
    /**
     * Performs tasks when the {@link resolution} has changed.
     *
     * Override this empty method to handle resolution changes.
     */
    protected onResolutionChange(): void;
    /**
     * Performs tasks when the {@link viewport} has changed.
     *
     * Override this empty method to handle viewport changes.
     */
    protected onViewportChange(): void;
    /**
     * Performs tasks when the {@link scissor} has changed.
     *
     * Override this empty method to handle scissor changes.
     */
    protected onScissorChange(): void;
    /**
     * Performs tasks when a child node is added to the current {@link scene}.
     *
     * Note: This method will only be called for child nodes and not for the scene itself.
     *
     * @param object - The child node that was added.
     */
    protected onSceneChildAdded(object: Object3D): void;
    /**
     * Performs tasks when a child node is removed from the current {@link scene}.
     *
     * Note: This method will only be called for child nodes and not for the scene itself.
     *
     * @param object - The child node that was removed.
     */
    protected onSceneChildRemoved(object: Object3D): void;
    /**
     * Compiles the materials used by this pass.
     *
     * @return A promise that resolves when the compilation has finished.
     */
    compile(): Promise<void>;
    /**
     * Creates a standard render target with default settings and no depth.
     *
     * @see https://threejs.org/docs/?q=rendert#api/en/renderers/WebGLRenderTarget
     * @return The framebuffer.
     */
    protected createFramebuffer(): WebGLRenderTarget;
    /**
     * Dispatches a `change` event.
     */
    protected setChanged(): void;
    /**
     * Applies the viewport of this pass to the given render target.
     *
     * Note: viewport/scissor on render targets use absolute pixels whereas the renderer expects logical pixels.
     */
    protected applyViewport(renderTarget?: WebGLRenderTarget | WebGLRenderTarget<Texture[]> | null): void;
    /**
     * Applies the scissor region of this pass to the given render target.
     *
     * Note: viewport/scissor on render targets use absolute pixels whereas the renderer expects logical pixels.
     */
    protected applyScissor(renderTarget?: WebGLRenderTarget | WebGLRenderTarget<Texture[]> | null): void;
    /**
     * Sets the active render target.
     *
     * This method also calls {@link applyViewport} and {@link applyScissor}.
     *
     * @param renderTarget - A render target. Use `null` to render to the canvas.
     * @param activeCubeFace - The active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of `WebGLCubeRenderTarget`.
     * @param activeMipmapLevel - Specifies the active mipmap level.
     */
    protected setRenderTarget(renderTarget?: WebGLRenderTarget | WebGLRenderTarget<Texture[]> | null, activeCubeFace?: number, activeMipmapLevel?: number): void;
    /**
     * Renders the fullscreen material to the current render target.
     */
    protected renderFullscreen(): void;
    /**
     * Handles {@link resolution} events.
     *
     * @param event - A resolution event.
     */
    private handleResolutionEvent;
    /**
     * Handles {@link viewport} events.
     *
     * @param event - A viewport event.
     */
    private handleViewportEvent;
    /**
     * Handles {@link scissor} events.
     *
     * @param event - A scissor event.
     */
    private handleScissorEvent;
    /**
     * Handles {@link input} events.
     *
     * @param event - An input event.
     */
    private handleInputEvent;
    /**
     * Handles {@link output} events.
     *
     * @param event - An output event.
     */
    private handleOutputEvent;
    /**
     * Handles scene graph events.
     *
     * @param event - A scene graph event.
     */
    private handleSceneEvent;
    dispose(): void;
    abstract render(): void;
}
