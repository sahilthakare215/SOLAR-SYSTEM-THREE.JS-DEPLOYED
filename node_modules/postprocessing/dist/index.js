/**
 * postprocessing v7.0.0-beta.13 build Thu Aug 14 2025
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015 Raoul van RÃ¼schen
 * @license Zlib
 */
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// package.json
var version = "7.0.0-beta.13";

// src/core/io/Resource.ts
import { EventDispatcher } from "three";

// src/utils/IdManager.ts
var IdManager = class {
  /**
   * The next ID.
   */
  nextId;
  /**
   * Constructs a new ID manager.
   *
   * @param initialId - The first ID.
   */
  constructor(initialId = 0) {
    this.nextId = initialId;
  }
  /**
   * Returns the next unique ID.
   *
   * @return The ID.
   */
  getNextId() {
    return this.nextId++;
  }
  /**
   * Resets the ID counter.
   *
   * @param initialId - The first ID.
   * @return This manager.
   */
  reset(initialId = 0) {
    this.nextId = initialId;
    return this;
  }
};

// src/core/io/Resource.ts
var Resource = class _Resource extends EventDispatcher {
  /**
   * An ID manager.
   */
  static idManager = new IdManager();
  id;
  /**
   * @see {@link value}
   */
  _value;
  /**
   * @see {@link overrideValue}
   */
  _overrideValue;
  /**
   * Indicates whether this resource is currently muted.
   *
   * Muted resources don't dispatch `change` events.
   */
  muted;
  /**
   * Indicates whether this resource is currently locked.
   *
   * A resource will be locked for the duration of a `change` event dispatch.
   */
  locked;
  /**
   * Constructs a new resource wrapper.
   *
   * @param value - A resource value.
   */
  constructor(value) {
    super();
    this.id = _Resource.idManager.getNextId();
    this._value = value;
    this._overrideValue = null;
    this.locked = false;
    this.muted = false;
  }
  /**
   * The value of this resource.
   */
  get value() {
    return this._overrideValue ?? this._value;
  }
  set value(value) {
    this._value = value;
    this.setChanged();
  }
  /**
   * An additional value that overrides the main {@link value}.
   *
   * @internal
   */
  get overrideValue() {
    return this._overrideValue;
  }
  set overrideValue(value) {
    this._overrideValue = value;
    this.setChanged();
  }
  /**
   * Mutes all events dispatched by this resource.
   *
   * @internal
   */
  mute() {
    this.muted = true;
  }
  /**
   * Unmutes this resource and resumes dispatching events.
   *
   * @internal
   */
  unmute() {
    this.muted = false;
  }
  /**
   * Dispatches a `change` event.
   *
   * @throws If the resource is currently locked.
   * @internal
   */
  setChanged() {
    if (this.muted) {
      return;
    }
    if (this.locked) {
      throw new Error("Unable to change resource value inside change event handler");
    }
    this.locked = true;
    this.dispatchEvent({ type: "change" });
    this.locked = false;
  }
};

// src/core/io/DisposableResource.ts
var DisposableResource = class _DisposableResource extends Resource {
  /**
   * Keeps track of resource references.
   */
  static references = /* @__PURE__ */ new Map();
  /**
   * Constructs a new disposable resource wrapper.
   *
   * @param value - A resource value.
   */
  constructor(value) {
    super(value);
    _DisposableResource.increaseReferenceCount(value);
  }
  get value() {
    return super.value;
  }
  set value(value) {
    const previousValue = super.value;
    super.value = value;
    if (value === previousValue) {
      return;
    }
    _DisposableResource.decreaseReferenceCount(previousValue);
    _DisposableResource.increaseReferenceCount(value);
    if (previousValue !== null && !_DisposableResource.references.has(previousValue)) {
      previousValue.dispose();
    }
  }
  dispose() {
    this.value?.dispose();
  }
  /**
   * Decreases the reference count for the given resource.
   *
   * @param resource - A resource.
   */
  static decreaseReferenceCount(value) {
    if (value === null) {
      return;
    }
    const refs = _DisposableResource.references;
    const currentValue = refs.get(value) ?? 0;
    if (currentValue > 0) {
      if (currentValue === 1) {
        refs.delete(value);
      } else {
        refs.set(value, currentValue - 1);
      }
    }
  }
  /**
   * Increases the reference count for the given resource.
   *
   * @param resource - A resource.
   */
  static increaseReferenceCount(value) {
    if (value === null) {
      return;
    }
    const refs = _DisposableResource.references;
    const currentValue = refs.get(value) ?? 0;
    refs.set(value, currentValue + 1);
  }
};

// src/core/io/Input.ts
import { EventDispatcher as EventDispatcher4, UnsignedByteType } from "three";

// src/enums/GBuffer.ts
var GBuffer = /* @__PURE__ */ ((GBuffer2) => {
  GBuffer2["COLOR"] = "Color";
  GBuffer2["DEPTH"] = "Depth";
  GBuffer2["NORMAL"] = "Normal";
  GBuffer2["ORM"] = "ORM";
  GBuffer2["EMISSION"] = "Emission";
  return GBuffer2;
})(GBuffer || {});

// src/utils/ObservableMap.ts
import { EventDispatcher as EventDispatcher2 } from "three";
var ObservableMap = class extends EventDispatcher2 {
  /**
   * The internal data collection.
   */
  data;
  /**
   * Constructs a new map.
   *
   * @param iterable - A list of entries to add to this map.
   */
  constructor(iterable) {
    super();
    this.data = new Map(iterable);
  }
  get size() {
    return this.data.size;
  }
  get [Symbol.toStringTag]() {
    return this.data[Symbol.toStringTag];
  }
  clear() {
    this.dispatchEvent({ type: "clear" });
    const result = this.data.clear();
    this.dispatchEvent({ type: "change" });
    return result;
  }
  delete(key) {
    if (!this.data.has(key)) {
      return false;
    }
    this.dispatchEvent({
      type: "delete",
      key,
      value: this.data.get(key)
    });
    this.data.delete(key);
    this.dispatchEvent({ type: "change" });
    return true;
  }
  get(key) {
    return this.data.get(key);
  }
  has(key) {
    return this.data.has(key);
  }
  set(key, value) {
    if (this.data.has(key)) {
      this.dispatchEvent({
        type: "delete",
        key,
        value: this.data.get(key)
      });
    }
    this.data.set(key, value);
    this.dispatchEvent({ type: "add", key, value });
    this.dispatchEvent({ type: "change" });
    return this;
  }
  entries() {
    return this.data.entries();
  }
  keys() {
    return this.data.keys();
  }
  values() {
    return this.data.values();
  }
  forEach(callbackfn, thisArg) {
    return this.data.forEach(callbackfn, thisArg);
  }
  [Symbol.iterator]() {
    return this.data[Symbol.iterator]();
  }
};

// src/utils/ObservableSet.ts
import { EventDispatcher as EventDispatcher3 } from "three";
var ObservableSet = class extends EventDispatcher3 {
  /**
   * The internal data collection.
   */
  data;
  /**
   * Constructs a new set.
   *
   * @param iterable - A list of values to add to this set.
   */
  constructor(iterable) {
    super();
    this.data = new Set(iterable);
  }
  get size() {
    return this.data.size;
  }
  get [Symbol.toStringTag]() {
    return this.data[Symbol.toStringTag];
  }
  [Symbol.iterator]() {
    return this.data[Symbol.iterator]();
  }
  clear() {
    if (this.data.size === 0) {
      return;
    }
    this.dispatchEvent({ type: "clear" });
    this.data.clear();
    this.dispatchEvent({ type: "change" });
  }
  delete(value) {
    if (!this.data.has(value)) {
      return false;
    }
    this.dispatchEvent({ type: "delete", value });
    this.data.delete(value);
    this.dispatchEvent({ type: "change" });
    return true;
  }
  has(value) {
    return this.data.has(value);
  }
  add(value) {
    if (this.data.has(value)) {
      return this;
    }
    this.data.add(value);
    this.dispatchEvent({ type: "add", value });
    this.dispatchEvent({ type: "change" });
    return this;
  }
  entries() {
    return this.data.entries();
  }
  keys() {
    return this.data.keys();
  }
  values() {
    return this.data.values();
  }
  forEach(callbackfn, thisArg) {
    return this.data.forEach(callbackfn, thisArg);
  }
};

// src/core/io/TextureResource.ts
var TextureResource = class extends DisposableResource {
  /**
   * A collection of `change` listeners for bound uniforms.
   */
  uniformListeners;
  /**
   * Constructs a new texture resource.
   *
   * @param value - A texture.
   */
  constructor(value = null) {
    super(value);
    this.uniformListeners = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Binds a uniform to this texture resource to keep its value up-to-date.
   *
   * Please use {@link unbindUniform} in case you want to discard the bound uniform to prevent memory leaks.
   *
   * @param uniform - The uniform.
   */
  bindUniform(uniform) {
    if (!this.uniformListeners.has(uniform)) {
      const listener = () => {
        uniform.value = this.value;
      };
      this.uniformListeners.set(uniform, listener);
      this.addEventListener("change", listener);
    }
    uniform.value = this.value;
  }
  /**
   * Unbinds a uniform from this texture resource.
   *
   * @param uniform - The uniform.
   */
  unbindUniform(uniform) {
    if (this.uniformListeners.has(uniform)) {
      this.removeEventListener("change", this.uniformListeners.get(uniform));
    }
  }
};

// src/core/io/Input.ts
var Input = class _Input extends EventDispatcher4 {
  /**
   * Identifies the default input buffer in the {@link textures} collection.
   */
  static BUFFER_DEFAULT = "BUFFER_DEFAULT";
  defines;
  uniforms;
  /**
   * Required {@link GBuffer} components.
   *
   * {@link GBuffer.COLOR} is included by default.
   */
  gBuffer;
  /**
   * Input textures.
   *
   * Entries specified in {@link gBuffer} will be added automatically.
   */
  textures;
  /**
   * @see {@link gBufferConfig}.
   */
  _gBufferConfig;
  /**
   * An event listener that triggers a `change` event.
   */
  propagateChangeEvent;
  /**
   * Constructs new input resources.
   */
  constructor() {
    super();
    const gBuffer = new ObservableSet(["Color" /* COLOR */]);
    const defines = new ObservableMap();
    const uniforms = new ObservableMap();
    const textures = new ObservableMap();
    const propagateChangeEvent = () => this.setChanged();
    gBuffer.addEventListener("change", propagateChangeEvent);
    defines.addEventListener("change", propagateChangeEvent);
    uniforms.addEventListener("change", propagateChangeEvent);
    textures.addEventListener("change", propagateChangeEvent);
    textures.addEventListener("add", (e) => e.value.addEventListener("change", propagateChangeEvent));
    textures.addEventListener("delete", (e) => e.value.removeEventListener("change", propagateChangeEvent));
    textures.addEventListener("clear", (e) => {
      for (const value of e.target.values()) {
        value.removeEventListener("change", propagateChangeEvent);
      }
    });
    this.propagateChangeEvent = propagateChangeEvent;
    this.defines = defines;
    this.uniforms = uniforms;
    this.textures = textures;
    this.gBuffer = gBuffer;
    this._gBufferConfig = null;
  }
  /**
   * The current G-Buffer configuration.
   *
   * @internal
   */
  get gBufferConfig() {
    return this._gBufferConfig;
  }
  set gBufferConfig(value) {
    if (this._gBufferConfig !== null) {
      this._gBufferConfig.removeEventListener("change", this.propagateChangeEvent);
    }
    if (value !== null) {
      value.addEventListener("change", this.propagateChangeEvent);
    }
    this._gBufferConfig = value;
    this.setChanged();
  }
  /**
   * Alias for {@link textures}.
   */
  get buffers() {
    return this.textures;
  }
  /**
   * Indicates whether a default input buffer has been set.
   */
  get hasDefaultBuffer() {
    return this.textures.has(_Input.BUFFER_DEFAULT);
  }
  /**
   * The default input buffer.
   */
  get defaultBuffer() {
    return this.textures.get(_Input.BUFFER_DEFAULT) ?? null;
  }
  set defaultBuffer(value) {
    this.setBuffer(_Input.BUFFER_DEFAULT, value);
  }
  /**
   * Indicates whether the default buffer uses high precision.
   */
  get frameBufferPrecisionHigh() {
    return this.defaultBuffer?.value?.type !== UnsignedByteType;
  }
  /**
   * Dispatches a `change` event.
   *
   * @internal
   */
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Sets a buffer.
   *
   * A new resource will be created if the buffer doesn't already exist.
   *
   * @param key - A buffer key.
   * @param value - The buffer.
   */
  setBuffer(key, value) {
    if (value instanceof TextureResource) {
      this.textures.set(key, value);
    } else {
      const resource = this.textures.get(key);
      if (resource !== void 0 && resource !== null) {
        resource.value = value;
      } else {
        this.textures.set(key, new TextureResource(value));
      }
    }
  }
  /**
   * Retrieves a buffer.
   *
   * @param key - A buffer key.
   * @return The buffer, or `null` if it doesn't exist.
   */
  getBuffer(key) {
    return this.textures.get(key)?.value ?? null;
  }
  /**
   * Removes the default buffer.
   *
   * @return True if the buffer existed and has been removed, or false if it doesn't exist.
   */
  removeDefaultBuffer() {
    return this.textures.delete(_Input.BUFFER_DEFAULT);
  }
  dispose() {
    for (const disposable of this.textures.values()) {
      disposable.value?.dispose();
    }
  }
};

// src/passes/ClearPass.ts
import { Color as Color2, Scene as Scene3 } from "three";

// src/core/Pass.ts
import {
  BufferAttribute,
  BufferGeometry,
  EventDispatcher as EventDispatcher8,
  Group,
  Mesh,
  OrthographicCamera as OrthographicCamera2,
  SRGBColorSpace,
  Scene,
  ShaderMaterial as ShaderMaterial2,
  Vector2 as Vector23,
  WebGLRenderTarget as WebGLRenderTarget2
} from "three";

// src/materials/FullscreenMaterial.ts
import {
  GLSL3,
  NoBlending,
  PerspectiveCamera,
  ShaderMaterial,
  Uniform,
  UnsignedByteType as UnsignedByteType2,
  Vector3,
  Vector4
} from "three";

// src/materials/shaders/common.vert
var common_default = `out vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/FullscreenMaterial.ts
var FullscreenMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new fullscreen shader material.
   */
  constructor(parameters) {
    super(Object.assign({
      name: "FullscreenMaterial",
      glslVersion: GLSL3,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      vertexShader: common_default
    }, parameters));
    Object.assign(this.uniforms, {
      projectionMatrix: new Uniform(null),
      projectionMatrixInverse: new Uniform(null),
      viewMatrix: new Uniform(null),
      viewMatrixInverse: new Uniform(null),
      cameraParams: new Uniform(new Vector3()),
      resolution: new Uniform(new Vector4()),
      inputBuffer: new Uniform(null)
    });
    this.outputPrecision = "lowp";
    this.onBeforeCompile = (_shader, renderer) => {
      if (renderer.getRenderTarget() === null && this.outputPrecision !== "lowp") {
        this.outputPrecision = "lowp";
        this.needsUpdate = false;
      }
    };
  }
  /**
   * The precision of the output color.
   */
  get outputPrecision() {
    return this.defines.OUTPUT_COLOR_PRECISION;
  }
  set outputPrecision(value) {
    if (this.defines.OUTPUT_COLOR_PRECISION !== value) {
      this.defines.OUTPUT_COLOR_PRECISION = value;
      this.needsUpdate = true;
    }
  }
  /**
   * Indicates whether the input buffer uses high precision.
   */
  get frameBufferPrecisionHigh() {
    return this.defines.FRAME_BUFFER_PRECISION_HIGH !== void 0;
  }
  set frameBufferPrecisionHigh(value) {
    if (this.frameBufferPrecisionHigh !== value) {
      if (value) {
        this.defines.FRAME_BUFFER_PRECISION_HIGH = true;
      } else {
        delete this.defines.FRAME_BUFFER_PRECISION_HIGH;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * The input buffer.
   *
   * If this buffer uses high precision, the macro `FRAME_BUFFER_PRECISION_HIGH` will be defined.
   */
  get inputBuffer() {
    return this.uniforms.inputBuffer.value;
  }
  set inputBuffer(value) {
    this.frameBufferPrecisionHigh = value !== null && value.type !== UnsignedByteType2;
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The current camera near plane value.
   */
  get near() {
    const cameraParams = this.uniforms.cameraParams.value;
    return cameraParams.x;
  }
  /**
   * The current camera far plane value.
   */
  get far() {
    const cameraParams = this.uniforms.cameraParams.value;
    return cameraParams.y;
  }
  /**
   * Copies the settings of the given camera.
   *
   * Updates the camera-related uniforms and macros.
   *
   * @param camera - A camera.
   */
  copyCameraSettings(camera) {
    this.uniforms.projectionMatrix.value = camera.projectionMatrix;
    this.uniforms.projectionMatrixInverse.value = camera.projectionMatrixInverse;
    this.uniforms.viewMatrix.value = camera.matrixWorldInverse;
    this.uniforms.viewMatrixInverse.value = camera.matrixWorld;
    const cameraParams = this.uniforms.cameraParams.value;
    cameraParams.set(camera.near, camera.far, cameraParams.z);
    const perspectiveCameraDefined = this.defines.PERSPECTIVE_CAMERA !== void 0;
    if (camera instanceof PerspectiveCamera) {
      if (!perspectiveCameraDefined) {
        this.defines.PERSPECTIVE_CAMERA = true;
        this.needsUpdate = true;
      }
    } else if (perspectiveCameraDefined) {
      delete this.defines.PERSPECTIVE_CAMERA;
      this.needsUpdate = true;
    }
  }
  /**
   * Updates the `resolution` uniform (XY = resolution, ZW = texelSize).
   *
   * @param width - The width.
   * @param height - The height.
   */
  setSize(width, height) {
    const resolution = this.uniforms.resolution.value;
    resolution.set(width, height, 1 / width, 1 / height);
    const cameraParams = this.uniforms.cameraParams.value;
    cameraParams.z = width / height;
  }
};

// src/utils/Resolution.ts
import { EventDispatcher as EventDispatcher5, Vector2 } from "three";
var AUTO_SIZE = -1;
var Resolution = class extends EventDispatcher5 {
  /**
   * An auto sizing constant.
   *
   * Can be used to automatically calculate the width or height based on the original aspect ratio.
   */
  static AUTO_SIZE = AUTO_SIZE;
  /**
   * The unscaled base resolution in logical pixels.
  */
  baseSize;
  /**
   * The unscaled preferred resolution in logical pixels.
   */
  preferredSize;
  /**
   * The effective resolution in absolute pixels.
   */
  effectiveSize;
  /**
   * @see {@link pixelRatio}
   */
  _pixelRatio;
  /**
   * @see {@link scale}
   */
  _scale;
  /**
   * Indicates whether this resolution is currently locked.
   *
   * A resolution will be locked for the duration of a `change` event dispatch.
   */
  locked;
  /**
   * Constructs a new resolution.
   *
   * @param width - The preferred width.
   * @param height - The preferred height.
   * @param scale - A resolution scale.
   */
  constructor(width = AUTO_SIZE, height = AUTO_SIZE, scale = 1) {
    super();
    this.baseSize = new Vector2(1, 1);
    this.preferredSize = new Vector2(width, height);
    this.effectiveSize = new Vector2();
    this._pixelRatio = 1;
    this._scale = scale;
    this.locked = false;
    this.addEventListener("change", () => this.updateEffectiveSize());
    this.updateEffectiveSize();
  }
  /**
   * Calculates the effective size.
   */
  updateEffectiveSize() {
    const base = this.baseSize;
    const preferred = this.preferredSize;
    const effective = this.effectiveSize;
    effective.copy(base);
    if (preferred.width !== AUTO_SIZE) {
      effective.width = preferred.width;
    } else if (preferred.height !== AUTO_SIZE) {
      effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));
    }
    if (preferred.height !== AUTO_SIZE) {
      effective.height = preferred.height;
    } else if (preferred.width !== AUTO_SIZE) {
      effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));
    }
    effective.multiplyScalar(this.scaledPixelRatio).floor();
  }
  /**
   * The effective width, calculated based on the preferred size, pixel ratio and resolution scale.
   */
  get width() {
    return this.effectiveSize.width;
  }
  /**
   * The effective height, calculated based on the preferred size, pixel ratio and resolution scale.
   */
  get height() {
    return this.effectiveSize.height;
  }
  /**
   * The aspect ratio.
   */
  get aspectRatio() {
    return this.baseSize.width / this.baseSize.height;
  }
  /**
   * The device pixel ratio.
   *
   * @defaultValue 1.0
   */
  get pixelRatio() {
    return this._pixelRatio;
  }
  set pixelRatio(value) {
    if (this._pixelRatio !== value) {
      this._pixelRatio = value;
      this.setChanged();
    }
  }
  /**
   * The resolution scale.
   *
   * @defaultValue 1.0
   */
  get scale() {
    return this._scale;
  }
  set scale(value) {
    if (this._scale !== value) {
      this._scale = value;
      this.preferredSize.setScalar(AUTO_SIZE);
      this.setChanged();
    }
  }
  /**
   * The {@link pixelRatio} multiplied by the {@link scale}.
   */
  get scaledPixelRatio() {
    return this._pixelRatio * this._scale;
  }
  /**
   * The unscaled base width in logical pixels.
   *
   * @defaultValue 1
   */
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(value) {
    if (this.baseSize.width !== value) {
      this.baseSize.width = value;
      this.setChanged();
    }
  }
  /**
   * The unscaled base height in logical pixels.
   *
   * @defaultValue 1
   */
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(value) {
    if (this.baseSize.height !== value) {
      this.baseSize.height = value;
      this.setChanged();
    }
  }
  /**
   * Sets the base size in logical pixels.
   *
   * @param width - The width.
   * @param height - The height.
   */
  setBaseSize(width, height) {
    if (this.baseSize.width !== width || this.baseSize.height !== height) {
      this.baseSize.set(width, height);
      this.setChanged();
    }
  }
  /**
   * Alias for {@link setBaseSize}.
   *
   * @param width - The width.
   * @param height - The height.
   */
  setSize(width, height) {
    this.setBaseSize(width, height);
  }
  /**
   * Copies the base size of a given resolution.
   *
   * @param resolution - A resolution.
   */
  copyBaseSize(resolution) {
    if (!this.baseSize.equals(resolution.baseSize)) {
      this.baseSize.copy(resolution.baseSize);
      this.setChanged();
    }
  }
  /**
   * The unscaled preferred width in logical pixels.
   *
   * @defaultValue {@link Resolution.AUTO_SIZE}
   */
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(value) {
    if (this.preferredSize.width !== value) {
      this.preferredSize.width = value;
      this.setChanged();
    }
  }
  /**
   * The unscaled preferred height in logical pixels.
   *
   * @defaultValue {@link Resolution.AUTO_SIZE}
   */
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(value) {
    if (this.preferredSize.height !== value) {
      this.preferredSize.height = value;
      this.setChanged();
    }
  }
  /**
   * Sets the preferred size in logical pixels.
   *
   * @param width - The width.
   * @param height - The height.
   */
  setPreferredSize(width, height) {
    if (this.preferredSize.width !== width || this.preferredSize.height !== height) {
      this.preferredSize.set(width, height);
      this.setChanged();
    }
  }
  /**
   * Copies the preferred size of a given resolution.
   *
   * @param resolution - A resolution.
   */
  copyPreferredSize(resolution) {
    if (!this.preferredSize.equals(resolution.preferredSize)) {
      this.preferredSize.copy(resolution.preferredSize);
      this.setChanged();
    }
  }
  /**
   * Resets the preferred size to {@link AUTO_SIZE}.
   */
  resetPreferredSize() {
    if (this.preferredSize.width !== AUTO_SIZE || this.preferredSize.height !== AUTO_SIZE) {
      this.preferredSize.set(AUTO_SIZE, AUTO_SIZE);
      this.setChanged();
    }
  }
  /**
   * Copies the given resolution.
   *
   * @param resolution - The resolution.
   */
  copy(resolution) {
    if (!this.equals(resolution)) {
      this.preferredSize.copy(resolution.preferredSize);
      this.baseSize.copy(resolution.baseSize);
      this._pixelRatio = resolution.pixelRatio;
      this._scale = resolution.scale;
      this.setChanged();
    }
  }
  /**
   * Checks if this resolution equals the given resolution.
   *
   * @param resolution - A resolution.
   * @return True if the resolutions are the same.
   */
  equals(resolution) {
    return this.scale === resolution.scale && this.pixelRatio === resolution.pixelRatio && this.baseSize.equals(resolution.baseSize) && this.preferredSize.equals(resolution.preferredSize);
  }
  /**
   * Dispatches a `change` event.
   */
  setChanged() {
    if (this.locked) {
      throw new Error("Unable to change resolution inside change event handler");
    }
    this.locked = true;
    this.dispatchEvent({ type: "change" });
    this.locked = false;
  }
  get x() {
    return this.width;
  }
  get y() {
    return this.height;
  }
};

// src/utils/SceneEventTarget.ts
import { EventDispatcher as EventDispatcher6 } from "three";
var SceneEventTarget = class extends EventDispatcher6 {
  /**
   * A listener for events dispatched by the {@link scene}.
   */
  listener;
  /**
   * Constructs a new scene event target.
   *
   * @param scene - A scene.
   */
  constructor(scene) {
    super();
    this.listener = (event) => this.handleSceneEvent(event);
    this.handleSceneEvent({
      type: "childadded",
      target: scene,
      child: scene
    });
  }
  /**
   * Handles scene graph events.
   *
   * @param event - A scene graph event.
   */
  handleSceneEvent(event) {
    switch (event.type) {
      case "childadded": {
        event.child?.traverse((node) => {
          node.addEventListener("childadded", this.listener);
          node.addEventListener("childremoved", this.listener);
        });
        break;
      }
      case "childremoved": {
        event.child?.traverse((node) => {
          node.removeEventListener("childadded", this.listener);
          node.removeEventListener("childremoved", this.listener);
        });
        break;
      }
    }
    this.dispatchEvent(event);
  }
};

// src/utils/ShaderDataTracker.ts
var ShaderDataTracker = class {
  defines;
  uniforms;
  /**
   * Constructs a new shader data tracker.
   */
  constructor() {
    this.defines = /* @__PURE__ */ new Map();
    this.uniforms = /* @__PURE__ */ new Map();
  }
  /**
   * Applies shader macros to a given material.
   *
   * @see {@link trackDefines} to set macros that should be removed from the material before new ones are added.
   * @param material - The material that the macros should be assigned to.
   * @param defines - A collection of preprocessor macro definitions.
   * @return This helper.
   */
  applyDefines(material, defines) {
    for (const key of this.defines.keys()) {
      delete material.defines[key];
    }
    for (const entry of defines.entries()) {
      material.defines[entry[0]] = entry[1];
    }
    material.needsUpdate = true;
    return this;
  }
  /**
   * Sets shader macros that should be removed from materials before new ones are added.
   *
   * @see {@link applyDefines} for adding new macros to a material.
   * @param defines - A collection of preprocessor macro definitions.
   * @return This helper.
   */
  trackDefines(defines) {
    this.defines.clear();
    for (const entry of defines.entries()) {
      this.defines.set(entry[0], entry[1]);
    }
    return this;
  }
  /**
   * Applies shader uniforms to a given material.
   *
   * @see {@link trackUniforms} to set uniforms that should be removed from the material before new ones are added.
   * @param material - The material that the uniforms should be assigned to.
   * @param uniforms - A collection of uniforms.
   * @return This helper.
   */
  applyUniforms(material, uniforms) {
    for (const key of this.uniforms.keys()) {
      delete material.uniforms[key];
    }
    for (const entry of uniforms.entries()) {
      material.uniforms[entry[0]] = entry[1];
    }
    material.uniformsNeedUpdate = true;
    return this;
  }
  /**
   * Sets shader uniforms that should be removed from materials before new ones are added.
   *
   * @see {@link applyUniforms} for adding new uniforms to a material.
   * @param uniforms - A collection of uniforms.
   * @return This helper.
   */
  trackUniforms(uniforms) {
    this.uniforms.clear();
    for (const entry of uniforms.entries()) {
      this.uniforms.set(entry[0], entry[1]);
    }
    return this;
  }
  dispose() {
    this.defines.clear();
    this.uniforms.clear();
  }
};

// src/utils/Viewport.ts
import { Vector2 as Vector22 } from "three";
var Viewport = class _Viewport extends Resolution {
  /**
   * The offset in logical pixels.
   */
  offset;
  /**
   * The effective offset.
   */
  effectiveOffset;
  /**
   * @see {@link enabled}
   */
  _enabled;
  /**
   * Constructs a new viewport.
   */
  constructor() {
    super();
    this.offset = new Vector22();
    this.effectiveOffset = new Vector22();
    this._enabled = false;
    this.addEventListener("change", () => this.updateEffectiveOffset());
  }
  /**
   * Calculates the effective offset.
   */
  updateEffectiveOffset() {
    this.effectiveOffset.copy(this.offset).multiplyScalar(this.scaledPixelRatio).floor();
  }
  /**
   * Indicates whether this viewport is enabled.
   *
   * @defaultValue false
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled !== value) {
      this._enabled = value;
      this.setChanged();
    }
  }
  /**
   * The effective offset along the X-axis, calculated based on the scale and pixel ratio.
   *
   * @defaultValue 0
   */
  get offsetX() {
    return this.effectiveOffset.x;
  }
  /**
   * The effective offset along the Y-axis, calculated based on the scale and pixel ratio.
   *
   * @defaultValue 0
   */
  get offsetY() {
    return this.effectiveOffset.y;
  }
  /**
   * Sets the offset in logical pixels.
   *
   * @param x - The X-offset.
   * @param y - The Y-offset.
   */
  setOffset(x, y) {
    if (this.offset.x !== x || this.offset.y !== y) {
      this.offset.set(x, y);
      this.updateEffectiveOffset();
      this.setChanged();
    }
  }
  /**
   * Sets the offset and the preferred size in logical pixels.
   *
   * If the width and height are omitted, x and y will be used for the size instead.
   *
   * @param x - The X-offset.
   * @param y - The Y-offset.
   * @param width - The width.
   * @param height - The height.
   */
  set(x, y, width, height) {
    if (width === void 0 || height === void 0) {
      super.setPreferredSize(x, y);
    } else {
      this.offset.set(x, y);
      this.updateEffectiveOffset();
      super.setPreferredSize(width, height);
    }
  }
  copy(viewport) {
    if (viewport instanceof _Viewport) {
      if (!this.equals(viewport)) {
        this.enabled = viewport.enabled;
        this.offset.copy(viewport.offset);
        this.effectiveOffset.copy(viewport.effectiveOffset);
        super.copy(viewport);
      }
    } else {
      super.copy(viewport);
    }
  }
  equals(viewport) {
    return this.enabled === viewport.enabled && this.offset.equals(viewport.offset) && super.equals(viewport);
  }
  get x() {
    return this.effectiveOffset.x;
  }
  get y() {
    return this.effectiveOffset.y;
  }
  get z() {
    return this.width;
  }
  get w() {
    return this.height;
  }
};

// src/utils/Scissor.ts
var Scissor = class extends Viewport {
};

// src/core/io/Output.ts
import { EventDispatcher as EventDispatcher7, UnsignedByteType as UnsignedByteType3 } from "three";

// src/core/io/RenderTargetResource.ts
var RenderTargetResource = class extends DisposableResource {
  /**
   * A live resource that wraps the texture of the current render target.
   */
  texture;
  /**
   * Constructs a new render target resource.
   *
   * @param value - A render target.
   */
  constructor(value = null) {
    super(value);
    this.texture = new TextureResource(this.value?.texture);
  }
  get value() {
    return super.value;
  }
  set value(value) {
    super.value = value;
    this.texture.value = value !== null ? value.texture : null;
  }
  mute() {
    super.mute();
    this.texture.mute();
  }
  unmute() {
    super.unmute();
    this.texture.unmute();
  }
};

// src/core/io/Output.ts
var Output = class _Output extends EventDispatcher7 {
  /**
   * Identifies the default output buffer in the {@link renderTargets} collection.
   */
  static BUFFER_DEFAULT = "BUFFER_DEFAULT";
  defines;
  uniforms;
  /**
   * Output render targets.
   */
  renderTargets;
  /**
   * Constructs new output resources.
   */
  constructor() {
    super();
    const defines = new ObservableMap();
    const uniforms = new ObservableMap();
    const renderTargets = new ObservableMap();
    const propagateChangeEvent = () => this.setChanged();
    defines.addEventListener("change", propagateChangeEvent);
    uniforms.addEventListener("change", propagateChangeEvent);
    renderTargets.addEventListener("change", propagateChangeEvent);
    renderTargets.addEventListener("add", (e) => e.value.addEventListener("change", propagateChangeEvent));
    renderTargets.addEventListener("delete", (e) => e.value.removeEventListener("change", propagateChangeEvent));
    renderTargets.addEventListener("clear", (e) => {
      for (const value of e.target.values()) {
        value.removeEventListener("change", propagateChangeEvent);
      }
    });
    this.defines = defines;
    this.uniforms = uniforms;
    this.renderTargets = renderTargets;
  }
  /**
   * Alias for {@link renderTargets}.
   */
  get buffers() {
    return this.renderTargets;
  }
  /**
   * Indicates whether a default output buffer has been set.
   */
  get hasDefaultBuffer() {
    return this.renderTargets.has(_Output.BUFFER_DEFAULT);
  }
  /**
   * The default output buffer.
   */
  get defaultBuffer() {
    return this.renderTargets.get(_Output.BUFFER_DEFAULT) ?? null;
  }
  set defaultBuffer(value) {
    this.setBuffer(_Output.BUFFER_DEFAULT, value);
  }
  /**
   * Indicates whether the default buffer uses high precision.
   */
  get frameBufferPrecisionHigh() {
    const outputBuffer = this.defaultBuffer?.value;
    if (outputBuffer === void 0 || outputBuffer === null) {
      return false;
    }
    return outputBuffer.texture.type !== UnsignedByteType3;
  }
  /**
   * Dispatches a `change` event.
   *
   * @internal
   */
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Sets a buffer.
   *
   * A new resource will be created if the buffer doesn't already exist.
   *
   * @param key - A buffer key.
   * @param value - The buffer.
   */
  setBuffer(key, value) {
    if (value instanceof RenderTargetResource) {
      this.renderTargets.set(key, value);
    } else {
      const resource = this.renderTargets.get(key);
      if (resource !== void 0 && resource !== null) {
        resource.value = value;
      } else {
        this.renderTargets.set(key, new RenderTargetResource(value));
      }
    }
  }
  /**
   * Retrieves a buffer.
   *
   * @param key - A buffer key.
   * @return The buffer, or `null` if it doesn't exist.
   */
  getBuffer(key) {
    return this.renderTargets.get(key)?.value ?? null;
  }
  /**
   * Removes the default buffer.
   *
   * @return True if the buffer existed and has been removed, or false if it doesn't exist.
   */
  removeDefaultBuffer() {
    return this.renderTargets.delete(_Output.BUFFER_DEFAULT);
  }
  dispose() {
    for (const disposable of this.renderTargets.values()) {
      disposable.value?.depthTexture?.dispose();
      disposable.value?.dispose();
    }
  }
};

// src/core/Pass.ts
var v = /* @__PURE__ */ new Vector23();
var Pass = class _Pass extends EventDispatcher8 {
  /**
   * A shared fullscreen triangle.
   *
   * The screen size is 2x2 units (NDC). A triangle needs to be 4x4 units to fill the screen.
   * @see https://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/
   * @internal
   */
  static fullscreenGeometry = /* @__PURE__ */ (() => {
    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new BufferAttribute(vertices, 3));
    return geometry;
  })();
  /**
   * An ID manager.
   */
  static idManager = /* @__PURE__ */ new IdManager();
  /**
   * A collection of scene event helpers.
   *
   * One helper is created per scene to efficiently forward events of all child objects.
   */
  static sceneEventTargets = /* @__PURE__ */ new WeakMap();
  id;
  /**
   * A listener for events dispatched by the {@link scene}.
   */
  sceneListener;
  /**
   * A container that keeps track of input shader data.
   */
  shaderDataTracker;
  /**
   * A scene that contains the fullscreen mesh.
   */
  fullscreenScene;
  /**
   * A fullscreen camera.
   */
  fullscreenCamera;
  /**
   * A fullscreen mesh.
   */
  screen;
  // #region Backing Data
  /**
   * @see {@link Pass.prototype.name}
   */
  _name;
  /**
   * @see {@link enabled}
   */
  _enabled;
  /**
   * @see {@link attached}
   */
  _attached;
  /**
   * @see {@link autoSyncDefaultBuffers}
   */
  _autoSyncDefaultBuffers;
  /**
   * @see {@link timer}
   */
  _timer;
  /**
   * @see {@link renderer}
   */
  _renderer;
  /**
   * @see {@link scene}
   */
  _scene;
  /**
   * @see {@link camera}
   */
  _camera;
  /**
   * @see {@link subpasses}
   */
  _subpasses;
  // #endregion
  /**
   * A collection of objects that will be disposed when this pass is disposed.
   *
   * IO resources, materials and subpasses will be disposed separately and don't need to be added.
   */
  disposables;
  /**
   * A collection of fullscreen materials that are used by this pass.
   *
   * This only needs to be filled if multiple fullscreen materials are used. The initial {@link fullscreenMaterial}
   * will automatically be added.
   */
  materials;
  /**
   * The current resolution.
   */
  resolution;
  /**
   * The viewport.
   *
   * @see {@link Viewport.enabled} to enable the viewport.
   */
  viewport;
  /**
   * A rectangular area inside the viewport. Fragments that are outside the area will not be rendered.
   *
   * @see {@link Scissor.enabled} to enable the scissor.
   */
  scissor;
  /**
   * The input resources of this pass.
   */
  input;
  /**
   * The output resources of this pass.
   */
  output;
  /**
   * Constructs a new pass.
   *
   * @param name - A name that will be used for debugging purposes.
   */
  constructor(name) {
    super();
    this.sceneListener = (event) => this.handleSceneEvent(event);
    this.shaderDataTracker = new ShaderDataTracker();
    this.fullscreenScene = null;
    this.fullscreenCamera = null;
    this.screen = null;
    this._name = name;
    this._enabled = true;
    this._attached = false;
    this._autoSyncDefaultBuffers = true;
    this._renderer = null;
    this._timer = null;
    this._scene = null;
    this._camera = null;
    this._subpasses = [];
    this.id = _Pass.idManager.getNextId();
    this.disposables = /* @__PURE__ */ new Set();
    this.materials = /* @__PURE__ */ new Set();
    this.resolution = new Resolution();
    this.viewport = new Viewport();
    this.scissor = new Scissor();
    this.resolution.addEventListener("change", (e) => this.handleResolutionEvent(e));
    this.viewport.addEventListener("change", (e) => this.handleViewportEvent(e));
    this.scissor.addEventListener("change", (e) => this.handleScissorEvent(e));
    this.input = new Input();
    this.output = new Output();
    this.input.addEventListener("change", (e) => this.handleInputEvent(e));
    this.output.addEventListener("change", (e) => this.handleOutputEvent(e));
  }
  // #region Accessors
  /**
   * The name of this pass.
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  /**
   * Indicates whether this pass is enabled.
   *
   * @defaultValue true
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled !== value) {
      this._enabled = value;
      this.dispatchEvent({ type: "toggle" });
    }
  }
  /**
   * Indicates whether this pass is currently attached to another pass or a render pipeline.
   */
  get attached() {
    return this._attached;
  }
  set attached(value) {
    if (this._attached !== value) {
      this._attached = value;
      this.input.setChanged();
      this.output.setChanged();
      this.resolution.setChanged();
    }
  }
  /**
   * Controls whether the settings of the input and output default buffers should be synchronized.
   *
   * @defaultValue true
   */
  get autoSyncDefaultBuffers() {
    return this._autoSyncDefaultBuffers;
  }
  set autoSyncDefaultBuffers(value) {
    if (this._autoSyncDefaultBuffers !== value) {
      this._autoSyncDefaultBuffers = value;
      this.syncDefaultBuffers();
    }
  }
  /**
   * A list of subpasses.
   *
   * Subpasses are included in automatic resource optimizations and will be disposed when the parent pass is disposed.
   * The resolution, viewport and scissor of the subpasses are also kept in sync with the parent pass.
   *
   * They also gain access to the following data:
   * - {@link timer}
   * - {@link renderer}
   * - {@link scene}
   * - {@link camera}
   * - {@link attached}
   */
  get subpasses() {
    return this._subpasses;
  }
  set subpasses(value) {
    for (const pass of this.subpasses) {
      pass.attached = false;
    }
    for (const pass of value) {
      if (pass.attached) {
        throw new Error(`${pass.name} is already attached to another pass`);
      }
    }
    this._subpasses = value;
    Object.freeze(this._subpasses);
    this.initializeSubpasses();
  }
  /**
   * A timer.
   */
  get timer() {
    return this._timer;
  }
  set timer(value) {
    this._timer = value;
    for (const pass of this.subpasses) {
      pass.timer = value;
    }
  }
  /**
   * The current renderer.
   */
  get renderer() {
    return this._renderer;
  }
  set renderer(value) {
    this._renderer = value;
    try {
      if (value?.capabilities !== void 0) {
        this.checkRequirements();
      }
    } catch (e) {
      console.warn(e);
      console.info("Disabling pass:", this);
      this.enabled = false;
    }
    for (const pass of this.subpasses) {
      pass.renderer = value;
    }
  }
  /**
   * The main scene.
   */
  get scene() {
    return this._scene;
  }
  set scene(value) {
    if (this._scene === value) {
      return;
    }
    if (this._scene !== null && _Pass.sceneEventTargets.has(this._scene)) {
      const sceneEventTarget = _Pass.sceneEventTargets.get(this._scene);
      sceneEventTarget.removeEventListener("childadded", this.sceneListener);
      sceneEventTarget.removeEventListener("childremoved", this.sceneListener);
    }
    this._scene = value;
    if (value !== null) {
      if (!_Pass.sceneEventTargets.has(value)) {
        _Pass.sceneEventTargets.set(value, new SceneEventTarget(value));
      }
      const sceneEventTarget = _Pass.sceneEventTargets.get(value);
      sceneEventTarget.addEventListener("childadded", this.sceneListener);
      sceneEventTarget.addEventListener("childremoved", this.sceneListener);
    }
    for (const pass of this.subpasses) {
      pass.scene = value;
    }
  }
  /**
   * The main camera.
   */
  get camera() {
    return this._camera;
  }
  set camera(value) {
    if (this._camera === value) {
      return;
    }
    this._camera = value;
    if (value !== null && this.fullscreenMaterial instanceof FullscreenMaterial) {
      this.fullscreenMaterial.copyCameraSettings(value);
    }
    for (const pass of this.subpasses) {
      pass.camera = value;
    }
  }
  /**
   * The current fullscreen material.
   */
  get fullscreenMaterial() {
    return this.screen?.material;
  }
  set fullscreenMaterial(value) {
    if (value === null) {
      return;
    }
    if (this.screen !== null) {
      this.screen.material = value;
    } else {
      this.screen = new Mesh(_Pass.fullscreenGeometry, value);
      this.screen.frustumCulled = false;
      this.fullscreenScene = new Scene();
      this.fullscreenCamera = new OrthographicCamera2(-1, 1, 1, -1, 0, 1);
      this.fullscreenScene.add(this.screen);
    }
    if (!this.materials.has(value)) {
      this.materials.add(value);
      this.updateFullscreenMaterialInput(value);
    }
  }
  // #endregion
  /**
   * Sets the base settings of all subpasses.
   */
  initializeSubpasses() {
    for (const pass of this.subpasses) {
      pass.timer = this.timer;
      pass.renderer = this.renderer;
      pass.scene = this.scene;
      pass.camera = this.camera;
      pass.resolution.copy(this.resolution);
      pass.viewport.copy(this.viewport);
      pass.scissor.copy(this.scissor);
      pass.attached = true;
    }
  }
  /**
   * Updates the resolution of all subpasses.
   */
  updateSubpassResolution() {
    const { baseWidth, baseHeight, scaledPixelRatio } = this.resolution;
    for (const pass of this.subpasses) {
      pass.resolution.pixelRatio = scaledPixelRatio;
      pass.resolution.setBaseSize(baseWidth, baseHeight);
    }
  }
  /**
   * Updates the viewport of all subpasses.
   */
  updateSubpassViewport() {
    const { baseWidth, baseHeight, scaledPixelRatio } = this.viewport;
    for (const pass of this.subpasses) {
      pass.viewport.pixelRatio = scaledPixelRatio;
      pass.viewport.setBaseSize(baseWidth, baseHeight);
    }
  }
  /**
   * Updates the scissor of all subpasses.
   */
  updateSubpassScissor() {
    const { baseWidth, baseHeight, scaledPixelRatio } = this.scissor;
    for (const pass of this.subpasses) {
      pass.scissor.pixelRatio = scaledPixelRatio;
      pass.scissor.setBaseSize(baseWidth, baseHeight);
    }
  }
  /**
   * Updates the size of the default output buffer, if it exists.
   */
  updateOutputBufferSize() {
    this.output.defaultBuffer?.value?.setSize(this.resolution.width, this.resolution.height);
  }
  /**
   * Updates the viewport and scissor based on the current resolution.
   */
  updateViewportAndScissor() {
    const { baseWidth, baseHeight, scaledPixelRatio } = this.resolution;
    this.viewport.pixelRatio = scaledPixelRatio;
    this.viewport.setBaseSize(baseWidth, baseHeight);
    this.scissor.pixelRatio = scaledPixelRatio;
    this.scissor.setBaseSize(baseWidth, baseHeight);
  }
  /**
   * Updates the size of the given material.
   */
  updateFullscreenMaterialResolution(material) {
    if (material instanceof FullscreenMaterial) {
      material.setSize(this.resolution.width, this.resolution.height);
    }
  }
  /**
   * Updates the size of the fullscreen materials.
   */
  updateFullscreenMaterialsResolution() {
    for (const material of this.materials) {
      this.updateFullscreenMaterialResolution(material);
    }
  }
  /**
   * Updates the shader input data of the given fullscreen material.
   *
   * @param material - The material to update.
   */
  updateFullscreenMaterialInput(material) {
    if (!(material instanceof ShaderMaterial2)) {
      return;
    }
    if (material instanceof FullscreenMaterial) {
      material.inputBuffer = this.input.defaultBuffer?.value ?? null;
    }
    this.shaderDataTracker.applyDefines(material, this.input.defines).applyUniforms(material, this.input.uniforms);
  }
  /**
   * Updates the shader input data of all fullscreen {@link materials}.
   */
  updateFullscreenMaterialsInput() {
    for (const material of this.materials) {
      this.updateFullscreenMaterialInput(material);
    }
    this.shaderDataTracker.trackDefines(this.input.defines).trackUniforms(this.input.uniforms);
  }
  /**
   * Updates the shader output settings of all fullscreen {@link materials}.
   */
  updateFullscreenMaterialsOutput() {
    for (const material of this.materials) {
      if (material instanceof FullscreenMaterial) {
        material.outputPrecision = this.output.frameBufferPrecisionHigh ? "mediump" : "lowp";
      }
    }
  }
  /**
   * Synchronizes the texture settings of the input and output default buffers.
   *
   * This method ensures that the output buffer uses adequate settings for storing values from the input buffer.
   */
  syncDefaultBuffers() {
    const renderer = this.renderer;
    const inputBuffer = this.input.defaultBuffer?.value ?? null;
    const outputBuffer = this.output.defaultBuffer?.value ?? null;
    if (!this.autoSyncDefaultBuffers || renderer === null || inputBuffer === null || outputBuffer === null) {
      return;
    }
    const texture = outputBuffer.texture;
    texture.needsUpdate = texture.format !== inputBuffer.format || texture.internalFormat !== inputBuffer.internalFormat || texture.type !== inputBuffer.type;
    if (texture.needsUpdate) {
      texture.format = inputBuffer.format;
      texture.internalFormat = inputBuffer.internalFormat;
      texture.type = inputBuffer.type;
    }
    const useSRGBFramebuffer = !this.output.frameBufferPrecisionHigh && renderer.outputColorSpace === SRGBColorSpace;
    if (useSRGBFramebuffer && texture.colorSpace !== SRGBColorSpace) {
      texture.colorSpace = SRGBColorSpace;
      texture.needsUpdate = true;
    }
    if (texture.needsUpdate) {
      this.output.defaultBuffer.texture.setChanged();
    }
  }
  /**
   * Checks if this pass uses convolution shaders.
   *
   * Only works on passes that use a `FullscreenMaterial`.
   *
   * @param recursive - Controls whether subpasses should be checked recursively.
   * @return True if the pass uses convolution shaders.
   */
  isConvolutionPass(recursive) {
    const material = this.fullscreenMaterial;
    if (material instanceof FullscreenMaterial && /texture\s*\(\s*gBuffer.color/.test(material.fragmentShader)) {
      return true;
    }
    if (recursive) {
      for (const subpass of this.subpasses) {
        if (subpass.isConvolutionPass(recursive)) {
          return true;
        }
      }
    }
    return false;
  }
  // #region Lifecycle Hooks
  /**
   * Checks if the current renderer supports all features that are required by this pass.
   *
   * Override this method to check if the current device supports the necessary features.
   * This method should throw an error if the requirements are not met.
   *
   * @throws If the device doesn't meet the requirements.
   */
  checkRequirements() {
  }
  /**
   * Performs tasks when the input resources have changed.
   *
   * Override this empty method to handle input changes.
   */
  onInputChange() {
  }
  /**
   * Performs tasks when the output resources have changed.
   *
   * Override this empty method to handle output changes.
   */
  onOutputChange() {
  }
  /**
   * Performs tasks when the {@link resolution} has changed.
   *
   * Override this empty method to handle resolution changes.
   */
  onResolutionChange() {
  }
  /**
   * Performs tasks when the {@link viewport} has changed.
   *
   * Override this empty method to handle viewport changes.
   */
  onViewportChange() {
  }
  /**
   * Performs tasks when the {@link scissor} has changed.
   *
   * Override this empty method to handle scissor changes.
   */
  onScissorChange() {
  }
  /**
   * Performs tasks when a child node is added to the current {@link scene}.
   *
   * Note: This method will only be called for child nodes and not for the scene itself.
   *
   * @param object - The child node that was added.
   */
  onSceneChildAdded(object) {
  }
  /**
   * Performs tasks when a child node is removed from the current {@link scene}.
   *
   * Note: This method will only be called for child nodes and not for the scene itself.
   *
   * @param object - The child node that was removed.
   */
  onSceneChildRemoved(object) {
  }
  // #endregion
  /**
   * Compiles the materials used by this pass.
   *
   * @return A promise that resolves when the compilation has finished.
   */
  async compile() {
    if (this.renderer === null) {
      return;
    }
    const group = new Group();
    for (const material of this.materials) {
      group.add(new Mesh(_Pass.fullscreenGeometry, material));
    }
    const promises = [
      this.renderer.compileAsync(group, this.fullscreenCamera, this.fullscreenScene)
    ];
    for (const pass of this.subpasses) {
      promises.push(pass.compile());
    }
    await Promise.all(promises);
  }
  /**
   * Creates a standard render target with default settings and no depth.
   *
   * @see https://threejs.org/docs/?q=rendert#api/en/renderers/WebGLRenderTarget
   * @return The framebuffer.
   */
  createFramebuffer() {
    const { width, height } = this.resolution;
    return new WebGLRenderTarget2(width, height, { depthBuffer: false });
  }
  /**
   * Dispatches a `change` event.
   */
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Applies the viewport of this pass to the given render target.
   *
   * Note: viewport/scissor on render targets use absolute pixels whereas the renderer expects logical pixels.
   */
  applyViewport(renderTarget = null) {
    const renderer = this.renderer;
    if (renderer === null) {
      return;
    }
    const viewport = this.viewport;
    if (viewport.enabled) {
      if (renderTarget !== null) {
        renderTarget.viewport.copy(viewport);
      } else {
        renderer.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);
      }
    } else {
      if (renderTarget !== null) {
        const { width, height } = renderTarget;
        renderTarget.viewport.set(0, 0, width, height);
      } else {
        const { width, height } = renderer.getSize(v);
        renderer.setViewport(0, 0, width, height);
      }
    }
  }
  /**
   * Applies the scissor region of this pass to the given render target.
   *
   * Note: viewport/scissor on render targets use absolute pixels whereas the renderer expects logical pixels.
   */
  applyScissor(renderTarget = null) {
    const renderer = this.renderer;
    if (renderer === null) {
      return;
    }
    const scissor = this.scissor;
    if (scissor.enabled) {
      if (renderTarget !== null) {
        renderTarget.scissor.copy(scissor);
        renderTarget.scissorTest = true;
      } else {
        renderer.setScissor(scissor.x, scissor.y, scissor.z, scissor.w);
        renderer.setScissorTest(true);
      }
    } else {
      if (renderTarget !== null) {
        const { width, height } = renderTarget;
        renderTarget.scissor.set(0, 0, width, height);
        renderTarget.scissorTest = false;
      } else if (renderer.getScissorTest()) {
        const { width, height } = renderer.getSize(v);
        renderer.setScissor(0, 0, width, height);
        renderer.setScissorTest(false);
      }
    }
  }
  /**
   * Sets the active render target.
   *
   * This method also calls {@link applyViewport} and {@link applyScissor}.
   *
   * @param renderTarget - A render target. Use `null` to render to the canvas.
   * @param activeCubeFace - The active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of `WebGLCubeRenderTarget`.
   * @param activeMipmapLevel - Specifies the active mipmap level.
   */
  setRenderTarget(renderTarget = null, activeCubeFace, activeMipmapLevel) {
    this.applyViewport(renderTarget);
    this.applyScissor(renderTarget);
    this.renderer?.setRenderTarget(renderTarget, activeCubeFace, activeMipmapLevel);
  }
  /**
   * Renders the fullscreen material to the current render target.
   */
  renderFullscreen() {
    if (this.renderer !== null && this.fullscreenMaterial !== null) {
      this.renderer.render(this.fullscreenScene, this.fullscreenCamera);
    }
  }
  // #region Event Handlers
  /**
   * Handles {@link resolution} events.
   *
   * @param event - A resolution event.
   */
  handleResolutionEvent(event) {
    if (!this.attached) {
      return;
    }
    switch (event.type) {
      case "change":
        this.updateFullscreenMaterialsResolution();
        this.updateOutputBufferSize();
        this.onResolutionChange();
        this.updateSubpassResolution();
        this.updateViewportAndScissor();
        break;
    }
  }
  /**
   * Handles {@link viewport} events.
   *
   * @param event - A viewport event.
   */
  handleViewportEvent(event) {
    if (!this.attached) {
      return;
    }
    switch (event.type) {
      case "change":
        this.onViewportChange();
        this.updateSubpassViewport();
        break;
    }
  }
  /**
   * Handles {@link scissor} events.
   *
   * @param event - A scissor event.
   */
  handleScissorEvent(event) {
    if (!this.attached) {
      return;
    }
    switch (event.type) {
      case "change":
        this.onScissorChange();
        this.updateSubpassScissor();
        break;
    }
  }
  /**
   * Handles {@link input} events.
   *
   * @param event - An input event.
   */
  handleInputEvent(event) {
    if (!this.attached) {
      return;
    }
    switch (event.type) {
      case "change":
        this.updateFullscreenMaterialsInput();
        this.syncDefaultBuffers();
        this.onInputChange();
        break;
    }
  }
  /**
   * Handles {@link output} events.
   *
   * @param event - An output event.
   */
  handleOutputEvent(event) {
    if (!this.attached) {
      return;
    }
    switch (event.type) {
      case "change":
        this.updateOutputBufferSize();
        this.updateFullscreenMaterialsOutput();
        this.syncDefaultBuffers();
        this.onOutputChange();
        break;
    }
  }
  /**
   * Handles scene graph events.
   *
   * @param event - A scene graph event.
   */
  handleSceneEvent(event) {
    if (!this.attached) {
      return;
    }
    switch (event.type) {
      case "childadded":
        this.onSceneChildAdded(event.child);
        break;
      case "childremoved":
        this.onSceneChildRemoved(event.child);
        break;
    }
  }
  // #endregion
  dispose() {
    this.input.dispose();
    this.output.dispose();
    this.shaderDataTracker.dispose();
    for (const material of this.materials) {
      material?.dispose();
    }
    for (const disposable of this.disposables) {
      disposable.dispose();
    }
    for (const pass of this.subpasses) {
      pass.dispose();
    }
  }
};

// src/utils/gbuffer/GBufferUtils.ts
import {
  FloatType,
  HalfFloatType,
  RGBAFormat,
  RGBFormat,
  RGFormat,
  RedFormat,
  UnsignedByteType as UnsignedByteType4
} from "three";
var textureTypeToPrecision = /* @__PURE__ */ new Map([
  [FloatType, "highp"],
  [HalfFloatType, "mediump"],
  [UnsignedByteType4, "lowp"]
]);
var pixelFormatToTexelType = /* @__PURE__ */ new Map([
  [RedFormat, "float"],
  [RGFormat, "vec2"],
  [RGBFormat, "vec3"],
  [RGBAFormat, "vec4"]
]);
function extractIndices(renderTarget) {
  const indices = /* @__PURE__ */ new Map();
  for (let i = 0, l = renderTarget.textures.length; i < l; ++i) {
    const texture = renderTarget.textures[i];
    indices.set(texture.name, i);
  }
  return indices;
}
function extractOutputDefinitions(renderTarget) {
  const definitions = [];
  for (let i = 0, l = renderTarget.textures.length; i < l; ++i) {
    const texture = renderTarget.textures[i];
    const precision = textureTypeToPrecision.get(texture.type);
    const type = pixelFormatToTexelType.get(texture.format);
    const name = texture.name.replace(/\W*/g, "");
    if (i === 0) {
      definitions.push("#ifndef gl_FragColor");
    }
    definitions.push(`layout(location = ${i}) out ${precision} ${type} out_FragData${i};`);
    if (name !== "") {
      definitions.push(`#define out_${name} out_FragData${i}`);
    }
    if (i === 0) {
      definitions.push(`#define gl_FragColor out_FragData${i}`);
      definitions.push("#endif");
    }
  }
  return definitions.join("\n");
}

// src/utils/Background.ts
import {
  BoxGeometry,
  CubeTexture,
  CubeUVReflectionMapping,
  Euler,
  Group as Group2,
  Matrix4,
  Mesh as Mesh2,
  PlaneGeometry,
  Texture as Texture6,
  Uniform as Uniform2
} from "three";

// src/materials/BackgroundMaterial.ts
import { UniformsUtils, ShaderLib, ShaderMaterial as ShaderMaterial3 } from "three";
var BackgroundMaterial = class extends ShaderMaterial3 {
  /**
   * Constructs a new background material.
   */
  constructor() {
    super({
      name: "BackgroundMaterial",
      fragmentShader: ShaderLib.background.fragmentShader,
      vertexShader: ShaderLib.background.vertexShader,
      uniforms: UniformsUtils.clone(ShaderLib.background.uniforms),
      depthWrite: false,
      depthTest: false,
      fog: false
    });
  }
  /**
   * The current background texture.
   */
  get map() {
    return this.uniforms.t2D.value;
  }
  set map(value) {
    this.uniforms.t2D.value = value;
  }
};

// src/materials/SkyBoxMaterial.ts
import { BackSide, UniformsUtils as UniformsUtils2, ShaderLib as ShaderLib2, ShaderMaterial as ShaderMaterial4 } from "three";
var SkyBoxMaterial = class extends ShaderMaterial4 {
  /**
   * Constructs a new sky box material.
   */
  constructor() {
    super({
      name: "SkyBoxMaterial",
      fragmentShader: ShaderLib2.backgroundCube.fragmentShader,
      vertexShader: ShaderLib2.backgroundCube.vertexShader,
      uniforms: UniformsUtils2.clone(ShaderLib2.backgroundCube.uniforms),
      side: BackSide,
      depthWrite: false,
      depthTest: false,
      fog: false
    });
  }
  /**
   * The current background texture.
   */
  get envMap() {
    return this.uniforms.envMap.value;
  }
  set envMap(value) {
    this.uniforms.envMap.value = value;
  }
};

// src/utils/Background.ts
var euler = /* @__PURE__ */ new Euler();
var matrix4 = /* @__PURE__ */ new Matrix4();
var Background = class extends Group2 {
  /**
   * A sky box.
   */
  skyBox;
  /**
   * A background plane.
   */
  background;
  /**
   * Constructs a new background.
   */
  constructor() {
    super();
    const skyBox = new Mesh2(new BoxGeometry(1, 1, 1), new SkyBoxMaterial());
    skyBox.name = "SkyBox";
    skyBox.geometry.deleteAttribute("normal");
    skyBox.geometry.deleteAttribute("uv");
    skyBox.matrixAutoUpdate = false;
    skyBox.frustumCulled = false;
    skyBox.layers.enableAll();
    this.skyBox = skyBox;
    skyBox.onBeforeRender = function(_renderer, _scene, camera) {
      this.matrixWorld.copyPosition(camera.matrixWorld);
    };
    const background = new Mesh2(new PlaneGeometry(2, 2), new BackgroundMaterial());
    background.name = "Background";
    background.geometry.deleteAttribute("normal");
    background.matrixAutoUpdate = false;
    background.frustumCulled = false;
    background.layers.enableAll();
    this.background = background;
    this.add(this.skyBox, this.background);
  }
  /**
   * Creates uniforms for the background materials using the given clear values.
   *
   * @param values - Clear values.
   */
  setClearValues(values) {
    const skyBoxMaterial = new SkyBoxMaterial();
    const backgroundMaterial = new BackgroundMaterial();
    const uniforms = /* @__PURE__ */ new Map();
    const uniformDeclarations = [];
    const mrtWrites = [];
    for (const entry of values.gBuffer) {
      const t = typeof entry[1] === "number" ? "float" : `vec${[...entry[1]].length}`;
      uniforms.set(`pp_${entry[0]}`, new Uniform2(entry[1]));
      uniformDeclarations.push(`uniform ${t} pp_${entry[0]};`);
      mrtWrites.push(`	#ifdef out_${entry[0]}
		out_${entry[0]} = pp_${entry[0]};
#endif`);
    }
    const shaderCodeHead = uniformDeclarations.join("\n");
    const shaderCodeBody = mrtWrites.join("\n");
    for (const material of [skyBoxMaterial, backgroundMaterial]) {
      material.fragmentShader = material.fragmentShader.replace(
        /(void main\(\) {)/,
        `${shaderCodeHead}
$1
${shaderCodeBody}
`
      );
      for (const entry of uniforms) {
        material.uniforms[entry[0]] = entry[1];
      }
      material.onBeforeCompile = (shader, renderer) => {
        const renderTarget = renderer.getRenderTarget();
        if (renderTarget === null) {
          return;
        }
        const outputDefinitions = extractOutputDefinitions(renderTarget);
        shader.fragmentShader = outputDefinitions + "\n\n" + shader.fragmentShader;
      };
    }
    this.skyBox.material.dispose();
    this.background.material.dispose();
    this.skyBox.material = skyBoxMaterial;
    this.background.material = backgroundMaterial;
  }
  /**
   * Updates the background based on the background settings of a given scene.
   *
   * @param scene - A scene.
   */
  update(scene) {
    const { skyBox, background } = this;
    skyBox.visible = false;
    background.visible = false;
    if (scene === null || !(scene.background instanceof Texture6)) {
      return;
    }
    if (scene.background instanceof CubeTexture || scene.background.mapping === CubeUVReflectionMapping) {
      const flipEnvMap = scene.background.isRenderTargetTexture ? 1 : -1;
      euler.copy(scene.backgroundRotation);
      euler.x *= -1;
      euler.y *= -1;
      euler.z *= -1;
      euler.y *= flipEnvMap;
      euler.z *= flipEnvMap;
      skyBox.material.envMap = scene.background;
      skyBox.material.uniforms.flipEnvMap.value = flipEnvMap;
      skyBox.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      skyBox.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      const backgroundRotation = skyBox.material.uniforms.backgroundRotation.value;
      backgroundRotation.setFromMatrix4(matrix4.makeRotationFromEuler(euler));
      skyBox.visible = true;
    } else {
      background.material.map = scene.background;
      background.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      background.visible = true;
    }
  }
  dispose() {
    this.skyBox.material.dispose();
    this.background.material.dispose();
  }
};

// src/utils/ClearFlags.ts
var ClearFlags = class {
  /**
   * A collection of {@link GBuffer} components that should be cleared.
   */
  gBuffer;
  /**
   * Indicates whether the depth buffer should be cleared.
   */
  depth;
  /**
   * Indicates whether the stencil buffer should be cleared.
   */
  stencil;
  /**
   * Constructs new clear flags.
   *
   * @param color - The color clear flag.
   * @param depth - The depth clear flag.
   * @param stencil - The stencil clear flag.
   */
  constructor(color2 = true, depth = true, stencil = true) {
    this.gBuffer = /* @__PURE__ */ new Set([
      "Normal" /* NORMAL */,
      "ORM" /* ORM */,
      "Emission" /* EMISSION */
    ]);
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
  }
  /**
   * Indicates whether the color buffer should be cleared.
   *
   * Alias for the {@link gBuffer} entry {@link GBuffer.COLOR}.
   */
  get color() {
    return this.gBuffer.has("Color" /* COLOR */);
  }
  set color(value) {
    if (value) {
      this.gBuffer.add("Color" /* COLOR */);
    } else {
      this.gBuffer.delete("Color" /* COLOR */);
    }
  }
};

// src/utils/ClearValues.ts
import { EventDispatcher as EventDispatcher9 } from "three";
var ClearValues = class extends EventDispatcher9 {
  /**
   * @see {@link color}
   */
  _color;
  /**
   * @see {@link alpha}
   */
  _alpha;
  /**
   * A collection that maps {@link GBuffer} components to clear values.
   */
  gBuffer;
  /**
   * Constructs new clear values.
   */
  constructor() {
    super();
    this._color = null;
    this._alpha = null;
    const gBuffer = new ObservableMap([
      ["Normal" /* NORMAL */, [0, 0]],
      ["ORM" /* ORM */, [1, 0, 0, 1]],
      ["Emission" /* EMISSION */, [0, 0, 0, 1]]
    ]);
    gBuffer.addEventListener("change", () => this.setChanged());
    this.gBuffer = gBuffer;
  }
  /**
   * A clear color that overrides the clear color of the renderer.
   *
   * @defaultValue null
   */
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this.setChanged();
  }
  /**
   * A clear alpha value that overrides the clear alpha of the renderer.
   *
   * @defaultValue null
   */
  get alpha() {
    return this._alpha;
  }
  set alpha(value) {
    this._alpha = value;
    this.setChanged();
  }
  /**
   * Dispatches a `change` event.
   */
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
};

// src/passes/ClearPass.ts
var color = /* @__PURE__ */ new Color2();
var ClearPass = class extends Pass {
  /**
   * The clear flags.
   */
  clearFlags;
  /**
   * The clear values.
   *
   * - If an override clear color is set, the scene background will be ignored.
   * - The override alpha setting has no effect when a scene background is used.
   */
  clearValues;
  /**
   * G-Buffer texture indices.
   */
  gBufferIndices;
  /**
   * A background object.
   */
  background;
  /**
   * A background scene.
   */
  backgroundScene;
  /**
   * Constructs a new clear pass.
   *
   * @param color - The color clear flag.
   * @param depth - The depth clear flag.
   * @param stencil - The stencil clear flag.
   */
  constructor(color2 = true, depth = true, stencil = true) {
    super("ClearPass");
    this.clearFlags = new ClearFlags(color2, depth, stencil);
    this.clearValues = new ClearValues();
    this.gBufferIndices = null;
    this.background = new Background();
    this.background.setClearValues(this.clearValues);
    this.clearValues.addEventListener("change", () => this.background.setClearValues(this.clearValues));
    this.backgroundScene = new Scene3();
    this.backgroundScene.add(this.background);
    this.disposables.add(this.background);
  }
  /**
   * Clears G-Buffer components.
   *
   * @see https://www.khronos.org/opengl/wiki/Framebuffer#Buffer_clearing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/clearBuffer
   */
  clearGBuffer() {
    if (this.renderer === null || this.gBufferIndices === null) {
      return;
    }
    const flags = this.clearFlags;
    const values = this.clearValues;
    const gBufferTextureIndices = this.gBufferIndices;
    const gl = this.renderer.getContext();
    for (const entry of values.gBuffer) {
      const index = gBufferTextureIndices.get(entry[0]);
      if (!flags.gBuffer.has(entry[0]) || index === void 0) {
        continue;
      }
      gl.clearBufferfv(gl.COLOR, index, entry[1]);
    }
  }
  /**
   * Clears the default output buffer using the current clear values.
   *
   * @param overrideClearColor - An override clear color.
   */
  clear(overrideClearColor = this.clearValues.color) {
    const renderer = this.renderer;
    const flags = this.clearFlags;
    const overrideClearAlpha = this.clearValues.alpha;
    const hasOverrideClearColor = overrideClearColor !== null;
    const hasOverrideClearAlpha = overrideClearAlpha !== null;
    const clearAlpha = renderer.getClearAlpha();
    if (hasOverrideClearColor) {
      renderer.getClearColor(color);
      renderer.setClearColor(overrideClearColor);
    }
    if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(overrideClearAlpha);
    }
    renderer.clear(flags.color, flags.depth, flags.stencil);
    if (hasOverrideClearColor) {
      renderer.setClearColor(color, clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(clearAlpha);
    }
    this.clearGBuffer();
  }
  /**
   * Clears the default output buffer using the scene background.
   */
  clearWithBackground() {
    const scene = this.scene;
    const camera = this.camera;
    const renderer = this.renderer;
    const flags = this.clearFlags;
    if (scene.background instanceof Color2) {
      this.clear(scene.background);
    } else {
      if (flags.depth || flags.stencil) {
        renderer.clear(false, flags.depth, flags.stencil);
      }
      this.background.update(scene);
      renderer.render(this.backgroundScene, camera);
    }
  }
  onOutputChange() {
    const buffer = this.output.defaultBuffer?.value ?? null;
    this.gBufferIndices = buffer !== null ? extractIndices(buffer) : null;
  }
  async compile() {
    if (this.renderer === null || this.camera === null) {
      return;
    }
    await Promise.all([
      super.compile(),
      this.renderer.compileAsync(this.backgroundScene, this.camera)
    ]);
  }
  render() {
    if (this.renderer === null) {
      return;
    }
    const background = this.scene?.background ?? null;
    const hasOverrideClearColor = this.clearValues.color !== null;
    this.setRenderTarget(this.output.defaultBuffer?.value);
    if (!hasOverrideClearColor && this.camera !== null && background !== null) {
      this.clearWithBackground();
    } else {
      this.clear();
    }
  }
};

// src/passes/GeometryPass.ts
import {
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  FloatType as FloatType2,
  HalfFloatType as HalfFloatType2,
  LinearFilter,
  NearestFilter,
  NoColorSpace,
  RGBAFormat as RGBAFormat2,
  RGBFormat as RGBFormat2,
  RGFormat as RGFormat2,
  SRGBColorSpace as SRGBColorSpace2,
  UnsignedByteType as UnsignedByteType5,
  UnsignedInt248Type,
  WebGLRenderTarget as WebGLRenderTarget5
} from "three";

// src/utils/gbuffer/GBufferConfig.ts
import { EventDispatcher as EventDispatcher10 } from "three";

// src/enums/GData.ts
var GData = /* @__PURE__ */ ((GData2) => {
  GData2["COLOR"] = "color";
  GData2["DEPTH"] = "depth";
  GData2["NORMAL"] = "normal";
  GData2["POSITION"] = "position";
  GData2["ORM"] = "orm";
  GData2["EMISSION"] = "emission";
  GData2["LUMINANCE"] = "luminance";
  return GData2;
})(GData || {});

// src/utils/gbuffer/GBufferConfig.ts
var GBufferConfig = class extends EventDispatcher10 {
  /**
   * A collection that maps G-Buffer components to G-Buffer texture configurations.
   */
  textureConfigs;
  /**
   * A collection that maps G-Buffer components to G-Buffer struct field names that are used in effects.
   */
  gBufferStructFields;
  /**
   * A collection that maps G-Data to shader code that declares the G-Buffer struct.
   */
  gBufferStructDeclaration;
  /**
   * A collection that maps G-Data to shader code that declares the G-Data struct.
   */
  gDataStructDeclaration;
  /**
   * A collection that maps G-Data to shader code that fills the respective G-Data struct field.
   */
  gDataStructInitialization;
  /**
   * A collection that describes G-Data interdependencies.
   */
  gDataDependencies;
  /**
   * A collection that describes which G-Buffer components are required for the G-Data.
   */
  gDataBufferSources;
  /**
   * Constructs a new G-Buffer config.
   */
  constructor() {
    super();
    const textureConfigs = new ObservableMap();
    const gBufferStructFields = new ObservableMap([
      ["Color" /* COLOR */, "color"],
      ["Depth" /* DEPTH */, "depth"],
      ["Normal" /* NORMAL */, "normal"],
      ["ORM" /* ORM */, "orm"],
      ["Emission" /* EMISSION */, "emission"]
    ]);
    const gBufferStructDeclaration = new ObservableMap([
      ["Color" /* COLOR */, "FRAME_BUFFER_PRECISION sampler2D color;"],
      ["Depth" /* DEPTH */, "DEPTH_BUFFER_PRECISION sampler2D depth;"],
      ["Normal" /* NORMAL */, "mediump sampler2D normal;"],
      ["ORM" /* ORM */, "lowp sampler2D orm;"],
      ["Emission" /* EMISSION */, "mediump sampler2D emission;"]
    ]);
    const gDataStructDeclaration = new ObservableMap([
      ["color" /* COLOR */, "vec4 color;"],
      ["depth" /* DEPTH */, "float depth;"],
      ["normal" /* NORMAL */, "vec3 normal;"],
      ["position" /* POSITION */, "vec3 position;"],
      ["orm" /* ORM */, "vec3 orm;"],
      ["emission" /* EMISSION */, "vec3 emission;"],
      ["luminance" /* LUMINANCE */, "float luminance;"]
    ]);
    const gDataStructInitialization = new ObservableMap([
      ["color" /* COLOR */, "gData.color = texture(gBuffer.color, UV);"],
      ["depth" /* DEPTH */, "gData.depth = readDepth(gBuffer.depth, UV);"],
      ["normal" /* NORMAL */, "gData.normal = readNormal(gBuffer.normal, UV);"],
      ["position" /* POSITION */, "gData.position = getViewPosition(UV, gData.depth);"],
      ["orm" /* ORM */, "gData.orm = texture(gBuffer.orm, UV).xyz;"],
      ["emission" /* EMISSION */, "gData.emission = texture(gBuffer.emission, UV).rgb;"],
      ["luminance" /* LUMINANCE */, "gData.luminance = luminance(gData.color.rgb);"]
    ]);
    const gDataDependencies = new ObservableMap([
      ["position" /* POSITION */, /* @__PURE__ */ new Set(["depth" /* DEPTH */])],
      ["luminance" /* LUMINANCE */, /* @__PURE__ */ new Set(["color" /* COLOR */])]
    ]);
    const gDataBufferSources = new ObservableMap([
      ["color" /* COLOR */, /* @__PURE__ */ new Set(["Color" /* COLOR */])],
      ["depth" /* DEPTH */, /* @__PURE__ */ new Set(["Depth" /* DEPTH */])],
      ["normal" /* NORMAL */, /* @__PURE__ */ new Set(["Normal" /* NORMAL */])],
      ["position" /* POSITION */, /* @__PURE__ */ new Set(["Depth" /* DEPTH */])],
      ["orm" /* ORM */, /* @__PURE__ */ new Set(["ORM" /* ORM */])],
      ["emission" /* EMISSION */, /* @__PURE__ */ new Set(["Emission" /* EMISSION */])],
      ["luminance" /* LUMINANCE */, /* @__PURE__ */ new Set(["Color" /* COLOR */])]
    ]);
    const listener = () => this.dispatchEvent({ type: "change" });
    textureConfigs.addEventListener("change", listener);
    gBufferStructFields.addEventListener("change", listener);
    gBufferStructDeclaration.addEventListener("change", listener);
    gDataStructDeclaration.addEventListener("change", listener);
    gDataStructInitialization.addEventListener("change", listener);
    gDataDependencies.addEventListener("change", listener);
    gDataBufferSources.addEventListener("change", listener);
    this.textureConfigs = textureConfigs;
    this.gBufferStructFields = gBufferStructFields;
    this.gBufferStructDeclaration = gBufferStructDeclaration;
    this.gDataStructDeclaration = gDataStructDeclaration;
    this.gDataStructInitialization = gDataStructInitialization;
    this.gDataDependencies = gDataDependencies;
    this.gDataBufferSources = gDataBufferSources;
  }
};

// src/utils/Selection.ts
var Selection = class _Selection extends Set {
  /**
   * An ID manager.
   */
  static idManager = /* @__PURE__ */ new IdManager(2);
  /**
   * @see {@link layer}
   */
  _layer;
  /**
   * Indicates whether this selection is enabled.
   */
  enabled;
  /**
   * Controls whether objects that are added to this selection should be removed from all other layers.
   */
  exclusive;
  /**
   * Constructs a new selection.
   *
   * @param iterable - A collection of objects that should be added to this selection.
   * @param layer - A dedicated render layer for selected objects. Range is `[2, 31]`. Starts at 2 if omitted.
   */
  constructor(iterable, layer = _Selection.idManager.getNextId()) {
    super();
    this._layer = layer;
    if (this._layer < 1 || this._layer > 31) {
      console.warn("Layer out of range, resetting to 2");
      _Selection.idManager.reset(2);
      this._layer = _Selection.idManager.getNextId();
    }
    this.enabled = true;
    this.exclusive = false;
    if (iterable !== void 0 && iterable !== null) {
      this.set(iterable);
    }
  }
  /**
   * The render layer for selected objects.
   */
  get layer() {
    return this._layer;
  }
  set layer(value) {
    const currentLayer = this._layer;
    for (const object of this) {
      object.layers.disable(currentLayer);
      object.layers.enable(value);
    }
    this._layer = value;
  }
  /**
   * Clears this selection.
   */
  clear() {
    const layer = this.layer;
    for (const object of this) {
      object.layers.disable(layer);
    }
    super.clear();
  }
  /**
   * Adds an object to this selection.
   *
   * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.
   *
   * @param object - The object that should be selected.
   * @return This selection.
   */
  add(object) {
    if (this.exclusive) {
      object.layers.set(this.layer);
    } else {
      object.layers.enable(this.layer);
    }
    return super.add(object);
  }
  /**
   * Removes an object from this selection.
   *
   * @param object - The object that should be deselected.
   * @return Returns true if an object has successfully been removed from this selection; otherwise false.
   */
  delete(object) {
    if (this.has(object)) {
      object.layers.disable(this.layer);
    }
    return super.delete(object);
  }
  /**
   * Clears this selection and adds the given objects.
   *
   * @param objects - The objects that should be selected.
   * @return This selection.
   */
  set(objects) {
    this.clear();
    for (const object of objects) {
      this.add(object);
    }
    return this;
  }
  /**
   * Removes an existing object from the selection. If the object doesn't exist it's added instead.
   *
   * @param object - The object.
   * @return Returns true if the object is added, false otherwise.
   */
  toggle(object) {
    let result;
    if (this.has(object)) {
      this.delete(object);
      result = false;
    } else {
      this.add(object);
      result = true;
    }
    return result;
  }
  /**
   * Sets the visibility of all selected objects.
   *
   * This method enables or disables render layer 0 of all selected objects.
   *
   * @param visible - Whether the selected objects should be visible.
   * @return This selection.
   */
  setVisible(visible) {
    for (const object of this) {
      if (visible) {
        object.layers.enable(0);
      } else {
        object.layers.disable(0);
      }
    }
    return this;
  }
};

// src/materials/CopyMaterial.ts
import { AlwaysDepth, Uniform as Uniform3 } from "three";

// src/materials/shaders/copy.frag
var copy_default = `#include <common>
#include <pp_default_output_pars_fragment>
#ifdef COLOR_WRITE
#include <dithering_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#endif
#ifdef DEPTH_WRITE
#include <pp_depth_buffer_pars_fragment>
#endif
in vec2 vUv;void main(){
#ifdef COLOR_WRITE
out_Color=texture(inputBuffer,vUv);
#ifdef COLOR_SPACE_CONVERSION
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
#else
out_Color=vec4(0.0);
#endif
#ifdef DEPTH_WRITE
gl_FragDepth=texture(depthBuffer,vUv).r;
#endif
}`;

// src/materials/CopyMaterial.ts
var CopyMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new copy material.
   */
  constructor() {
    super({
      name: "CopyMaterial",
      fragmentShader: copy_default,
      vertexShader: common_default,
      defines: {
        COLOR_SPACE_CONVERSION: true,
        COLOR_WRITE: true
      },
      uniforms: {
        depthBuffer: new Uniform3(null)
      }
    });
    this.depthFunc = AlwaysDepth;
  }
  get inputBuffer() {
    return super.inputBuffer;
  }
  set inputBuffer(value) {
    const colorWrite = value !== null;
    if (this.colorWrite !== colorWrite) {
      if (colorWrite) {
        this.defines.COLOR_WRITE = true;
      } else {
        delete this.defines.COLOR_WRITE;
      }
      this.colorWrite = colorWrite;
      this.needsUpdate = true;
    }
    super.inputBuffer = value;
  }
  /**
   * A depth buffer that should be copied to the output buffer.
   */
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    const depthWrite = value !== null;
    if (this.depthWrite !== depthWrite) {
      if (depthWrite) {
        this.defines.DEPTH_WRITE = true;
      } else {
        delete this.defines.DEPTH_WRITE;
      }
      this.depthTest = depthWrite;
      this.depthWrite = depthWrite;
      this.needsUpdate = true;
    }
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * Indicates whether output color space conversion is enabled.
   */
  get colorSpaceConversion() {
    return this.defines.COLOR_SPACE_CONVERSION !== void 0;
  }
  set colorSpaceConversion(value) {
    if (this.colorSpaceConversion !== value) {
      if (value) {
        this.defines.COLOR_SPACE_CONVERSION = true;
      } else {
        delete this.defines.COLOR_SPACE_CONVERSION;
      }
      this.needsUpdate = true;
    }
  }
};

// src/passes/CopyPass.ts
var CopyPass = class _CopyPass extends Pass {
  /**
   * Indicates whether {@link WebGLRenderer.copyTextureToTexture} should be used for copying. Depending on the device
   * and graphics backend, this operation can be faster or slower than a fullscreen copy shader.
   *
   * This feature is disabled by default because it tends to be slower in most cases.
   *
   * @defaultValue false
   */
  static blitEnabled = false;
  /**
   * Constructs a new copy pass.
   *
   * @param outputBuffer - An output buffer. If not provided, a new framebuffer will be created.
   */
  constructor(outputBuffer) {
    super("CopyPass");
    this.output.defaultBuffer = outputBuffer ?? this.createFramebuffer();
    this.fullscreenMaterial = new CopyMaterial();
  }
  get renderer() {
    return super.renderer;
  }
  set renderer(value) {
    super.renderer = value;
    this.initializeOutputBuffer();
  }
  /**
   * Initializes the current output buffer.
   */
  initializeOutputBuffer() {
    const outputBuffer = this.output.defaultBuffer?.value ?? null;
    if (this.renderer !== null && outputBuffer !== null) {
      this.renderer.initRenderTarget(outputBuffer);
    }
  }
  /**
   * Configures the depth buffer for copying.
   */
  configureDepthBuffer() {
    const inputDepthBuffer = this.input.getBuffer("Depth" /* DEPTH */);
    const outputDepthBuffer = this.output.defaultBuffer?.value?.depthTexture ?? null;
    const inputIsOutput = inputDepthBuffer === outputDepthBuffer;
    this.fullscreenMaterial.depthBuffer = inputDepthBuffer === null || inputIsOutput ? null : inputDepthBuffer;
  }
  onInputChange() {
    this.configureDepthBuffer();
  }
  onOutputChange() {
    this.configureDepthBuffer();
    this.initializeOutputBuffer();
  }
  onResolutionChange() {
    this.initializeOutputBuffer();
  }
  /**
   * Rapidly copies the input buffer into the output buffer.
   *
   * @return True, if the operation was successful.
   */
  blit() {
    if (!_CopyPass.blitEnabled) {
      return false;
    }
    const inputBuffer = this.input.defaultBuffer?.value ?? null;
    const outputBuffer = this.output.defaultBuffer?.value ?? null;
    if (this.renderer === null || inputBuffer === null || outputBuffer === null) {
      return false;
    }
    const imgData = inputBuffer.source.data;
    if (imgData.width !== outputBuffer.width || imgData.height !== outputBuffer.height) {
      return false;
    }
    if (inputBuffer.type === outputBuffer.texture.type && inputBuffer.format === outputBuffer.texture.format) {
      this.renderer.copyTextureToTexture(inputBuffer, outputBuffer.texture);
    }
    const inputDepthTexture = this.input.getBuffer("Depth" /* DEPTH */);
    if (inputDepthTexture !== null && outputBuffer.depthTexture !== null && inputDepthTexture !== outputBuffer.depthTexture && inputDepthTexture.type === outputBuffer.depthTexture.type && inputDepthTexture.format === outputBuffer.depthTexture.format) {
      this.renderer.copyTextureToTexture(inputDepthTexture, outputBuffer.depthTexture);
    }
    return true;
  }
  render() {
    const inputBuffer = this.input.defaultBuffer?.value ?? null;
    if (this.renderer === null || inputBuffer === null) {
      return;
    }
    if (!this.blit()) {
      this.setRenderTarget(this.output.defaultBuffer?.value);
      this.renderFullscreen();
    }
  }
};

// src/utils/gbuffer/GBufferShaderPlugin.ts
import {
  ShaderMaterial as ShaderMaterial5
} from "three";
var GBufferShaderPlugin = class {
  /**
   * A collection of materials that have been modified with `onBeforeCompile`.
   */
  registeredMaterials = /* @__PURE__ */ new WeakSet();
  /**
   * @see {@link enabled}
   */
  _enabled;
  /**
   * @see {@link gBuffer}
   */
  _gBuffer;
  /**
   * Constructs a new G-Buffer shader plugin.
   */
  constructor() {
    this._enabled = true;
    this._gBuffer = null;
  }
  /**
   * Indicates whether this plugin is enabled.
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  /**
   * Returns the G-Buffer render target, or null if there is none.
   */
  get gBuffer() {
    return this._gBuffer;
  }
  set gBuffer(value) {
    this._gBuffer = value;
  }
  /**
   * Applies this plugin to the given material.
   *
   * @param material - The material.
   */
  applyTo(material) {
    if (this.registeredMaterials.has(material)) {
      return;
    }
    this.registeredMaterials.add(material);
    const onBeforeCompile = material.onBeforeCompile;
    const customProgramCacheKey = material.customProgramCacheKey;
    material.onBeforeCompile = (shader, renderer) => {
      if (material.onBeforeCompile !== onBeforeCompile) {
        onBeforeCompile.call(material, shader, renderer);
      }
      if (!this.enabled || this.gBuffer === null) {
        return;
      }
      if (material instanceof ShaderMaterial5 && // But custom materials may already include the required shader chunks.
      !shader.fragmentShader.includes("pp_normal_codec_pars_fragment")) {
        shader.fragmentShader = shader.fragmentShader.replace(
          /(^ *void\s+main\(\)\s+{.*)/m,
          "#include <pp_normal_codec_pars_fragment>\n\n$1\n\n#include <pp_default_output_fragment>"
        );
      }
      if (!shader.fragmentShader.includes("out_FragData")) {
        const outputDefinitions = extractOutputDefinitions(this.gBuffer);
        shader.fragmentShader = outputDefinitions + "\n\n" + shader.fragmentShader;
      }
    };
    material.customProgramCacheKey = () => {
      let key = "";
      if (material.customProgramCacheKey !== customProgramCacheKey) {
        key += customProgramCacheKey.call(material);
      }
      return key + this.enabled;
    };
  }
};

// src/passes/GeometryPass.ts
var GeometryPass = class extends Pass {
  selection;
  /**
   * A pass that copies the default input buffer to the output color buffer.
   */
  copyPass;
  /**
   * A shader plugin that enables rendering to G-Buffer render targets.
   */
  gBufferShaderPlugin;
  /**
   * A resource that wraps the G-Buffer.
   */
  gBufferResource;
  /**
   * Controls which G-Buffer components should be rendered by this pass.
   *
   * This will automatically be configured based on the requirements of other passes in the same pipeline.
   *
   * @internal
   */
  gBufferComponents;
  // #region Settings
  alpha;
  stencilBuffer;
  depthBuffer;
  frameBufferType;
  gBufferConfig;
  /**
   * @see {@link samples}
   */
  _samples;
  // #endregion
  /**
   * Constructs a new geometry pass.
   *
   * @param scene - A scene.
   * @param camera - A camera.
   * @param options - Additional options.
   */
  constructor(scene, camera, {
    alpha = false,
    stencilBuffer = false,
    depthBuffer = true,
    frameBufferType = HalfFloatType2,
    samples = 0,
    gBufferConfig = new GBufferConfig()
  } = {}) {
    super("GeometryPass");
    this.alpha = alpha;
    this.stencilBuffer = stencilBuffer;
    this.depthBuffer = depthBuffer;
    this.frameBufferType = frameBufferType;
    this._samples = samples;
    this.selection = new Selection();
    this.selection.enabled = false;
    this.gBufferConfig = gBufferConfig;
    this.copyPass = new CopyPass();
    this.copyPass.enabled = false;
    this.subpasses = [this.copyPass];
    const gBufferComponents = new ObservableSet();
    gBufferComponents.addEventListener("change", () => this.updateGBuffer());
    this.gBufferComponents = gBufferComponents;
    this.gBufferShaderPlugin = new GBufferShaderPlugin();
    this.gBufferResource = new RenderTargetResource();
    this.output.defaultBuffer = this.gBufferResource;
    this.scene = scene;
    this.camera = camera;
    this.updateTextureConfigs();
  }
  get enabled() {
    return super.enabled;
  }
  set enabled(value) {
    super.enabled = value;
    this.gBufferShaderPlugin.enabled = value;
    this.invalidateMaterials();
  }
  get scene() {
    return super.scene;
  }
  set scene(value) {
    super.scene = value;
    if (value !== null) {
      this.onSceneChildAdded(value);
    }
  }
  get samples() {
    return this._samples;
  }
  set samples(value) {
    this._samples = value;
    const buffer = this.output.defaultBuffer?.value ?? null;
    if (buffer !== null && buffer.samples !== value) {
      buffer.samples = value;
      buffer.dispose();
    }
  }
  /**
   * Returns the G-Buffer render target, or null if this pass renders to screen.
   */
  get gBuffer() {
    return this.gBufferResource.value;
  }
  /**
   * Indicates whether the primary frame buffer is capable of storing HDR values.
   */
  get frameBufferPrecisionHigh() {
    return this.frameBufferType === HalfFloatType2 || this.frameBufferType === FloatType2;
  }
  /**
   * Returns the G-Buffer texture configs that correspond to the current G-Buffer components.
   */
  get textureConfigs() {
    return Array.from(this.gBufferConfig.textureConfigs).filter((x) => this.gBufferComponents.has(x[0]));
  }
  get renderer() {
    return super.renderer;
  }
  set renderer(value) {
    super.renderer = value;
    this.updateOutputBufferColorSpace();
  }
  /**
   * Refreshes the material of the given object.
   *
   * @param object - The object to update.
   */
  invalidateMaterial(object) {
    if (!("material" in object)) {
      return;
    }
    const materials = Array.isArray(object.material) ? object.material : [object.material];
    for (const material of materials) {
      material.needsUpdate = true;
    }
  }
  /**
   * Refreshes the materials of the scene objects.
   */
  invalidateMaterials() {
    this.scene?.traverse((node) => this.invalidateMaterial(node));
  }
  /**
   * Defines all possible G-Buffer texture configs and updates the G-Buffer.
   */
  updateTextureConfigs() {
    const textureConfigs = this.gBufferConfig.textureConfigs;
    const useSmallFloatFormat = this.frameBufferPrecisionHigh && !this.alpha;
    textureConfigs.set("Color" /* COLOR */, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: this.frameBufferType,
      format: useSmallFloatFormat ? RGBFormat2 : RGBAFormat2,
      internalFormat: useSmallFloatFormat ? "R11F_G11F_B10F" : void 0,
      isColorBuffer: true
    });
    textureConfigs.set("Normal" /* NORMAL */, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: HalfFloatType2,
      format: RGFormat2
    });
    textureConfigs.set("ORM" /* ORM */, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: UnsignedByteType5,
      format: RGBAFormat2
    });
    textureConfigs.set("Emission" /* EMISSION */, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType2,
      format: RGBAFormat2
      // R11F_G11F_B10F causes artifacts in some scenes.
    });
    this.updateGBuffer();
  }
  /**
   * Enables rendering to {@link GBuffer} components for the materials of a given object.
   *
   * Should also be called when a material is added, removed or replaced at runtime.
   *
   * @param object - The object to update.
   */
  updateMaterial(object) {
    if (!("material" in object)) {
      return;
    }
    const materials = Array.isArray(object.material) ? object.material : [object.material];
    for (const material of materials) {
      this.gBufferShaderPlugin.applyTo(material);
    }
  }
  /**
   * Updates the color space of the output buffers.
   */
  updateOutputBufferColorSpace() {
    const gBuffer = this.gBuffer;
    const renderer = this.renderer;
    if (gBuffer === null || renderer === null) {
      return;
    }
    const indices = extractIndices(gBuffer);
    const useSRGB = !this.frameBufferPrecisionHigh && renderer.outputColorSpace === SRGBColorSpace2;
    const colorSpace = useSRGB ? SRGBColorSpace2 : NoColorSpace;
    for (const entry of this.textureConfigs) {
      if (entry[1].isColorBuffer === true && indices.has(entry[0])) {
        const index = indices.get(entry[0]);
        gBuffer.textures[index].colorSpace = colorSpace;
      }
    }
  }
  /**
   * Updates the G-Buffer configuration.
   */
  updateGBuffer() {
    const output = this.output;
    const gBufferComponents = this.gBufferComponents;
    if (!output.hasDefaultBuffer) {
      output.defaultBuffer = this.gBufferResource;
    } else if (output.defaultBuffer !== this.gBufferResource) {
      return;
    }
    output.defaultBuffer.value?.depthTexture?.dispose();
    output.defaultBuffer.value?.dispose();
    if (gBufferComponents.size === 0) {
      output.defaultBuffer = null;
      output.defines.clear();
      return;
    }
    const { width, height } = this.resolution;
    const textureConfigs = this.textureConfigs;
    const renderTarget = new WebGLRenderTarget5(width, height, {
      stencilBuffer: this.stencilBuffer,
      depthBuffer: this.depthBuffer,
      samples: this.samples,
      count: textureConfigs.length
    });
    for (let i = 0, l = textureConfigs.length; i < l; ++i) {
      const entry = textureConfigs[i];
      const texture = renderTarget.textures[i];
      const textureConfig = entry[1];
      texture.name = entry[0];
      texture.minFilter = textureConfig.minFilter;
      texture.magFilter = textureConfig.magFilter;
      texture.format = textureConfig.format;
      texture.type = textureConfig.type;
      if (textureConfig.internalFormat !== void 0) {
        texture.internalFormat = textureConfig.internalFormat;
      }
    }
    output.defaultBuffer = renderTarget;
    this.configureDepthTexture();
    this.updateOutputBufferColorSpace();
  }
  /**
   * Configures the depth texture.
   *
   * Uses the current {@link GBuffer.DEPTH} texture if available, or creates a new one.
   */
  configureDepthTexture() {
    const output = this.output;
    if (output.defaultBuffer !== this.gBufferResource) {
      return;
    }
    const outputBuffer = output.defaultBuffer?.value ?? null;
    if (outputBuffer === null) {
      return;
    }
    if (!this.gBufferComponents.has("Depth" /* DEPTH */)) {
      outputBuffer.depthTexture?.dispose();
      outputBuffer.depthTexture = null;
      return;
    }
    const inputDepthTexture = this.input.getBuffer("Depth" /* DEPTH */);
    if (inputDepthTexture !== null) {
      if (outputBuffer.depthTexture !== inputDepthTexture) {
        outputBuffer.depthTexture?.dispose();
        outputBuffer.depthTexture = inputDepthTexture;
      }
    } else {
      const depthTexture = new DepthTexture(1, 1);
      depthTexture.name = "Depth" /* DEPTH */;
      depthTexture.format = this.stencilBuffer ? DepthStencilFormat : DepthFormat;
      depthTexture.type = this.stencilBuffer ? UnsignedInt248Type : FloatType2;
      outputBuffer.depthTexture?.dispose();
      outputBuffer.depthTexture = depthTexture;
    }
  }
  /**
   * Updates the settings of the internal copy pass.
   */
  updateCopyPass() {
    const inputBuffer = this.input.defaultBuffer?.value ?? null;
    const outputBuffer = this.output.defaultBuffer?.value ?? null;
    const inputIsOutput = inputBuffer === outputBuffer?.texture;
    const outputIsMRT = (outputBuffer?.textures.length ?? 0) > 1;
    this.copyPass.enabled = inputBuffer !== null && !inputIsOutput && !outputIsMRT;
  }
  onInputChange() {
    this.configureDepthTexture();
    const copyPass = this.copyPass;
    copyPass.input.defaultBuffer = this.input.defaultBuffer;
    this.updateCopyPass();
    if (this.input.buffers.has("Depth" /* DEPTH */)) {
      copyPass.input.buffers.set("Depth" /* DEPTH */, this.input.buffers.get("Depth" /* DEPTH */));
    } else {
      copyPass.input.buffers.delete("Depth" /* DEPTH */);
    }
  }
  onOutputChange() {
    if (!this.output.hasDefaultBuffer) {
      this.gBufferResource.mute();
      this.updateGBuffer();
      this.gBufferResource.unmute();
    } else {
      this.configureDepthTexture();
    }
    this.gBufferShaderPlugin.gBuffer = this.output.defaultBuffer?.value ?? null;
    this.copyPass.output.defaultBuffer = this.output.defaultBuffer;
    this.updateCopyPass();
  }
  onResolutionChange() {
    this.copyPass.resolution.copy(this.resolution);
  }
  onSceneChildAdded(object) {
    object.traverse((node) => this.updateMaterial(node));
  }
  async compile() {
    if (this.renderer === null || this.scene === null || this.camera === null) {
      return;
    }
    const promises = [];
    promises.push(super.compile());
    promises.push(this.renderer.compileAsync(this.scene, this.camera));
    await Promise.all(promises);
  }
  render() {
    const { renderer, scene, camera } = this;
    if (renderer === null || scene === null || camera === null) {
      return;
    }
    const mask = camera.layers.mask;
    const background = scene.background;
    scene.background = null;
    if (this.selection.enabled) {
      camera.layers.set(this.selection.layer);
    }
    if (this.copyPass.enabled) {
      this.copyPass.render();
    }
    this.setRenderTarget(this.output.defaultBuffer?.value);
    renderer.render(scene, camera);
    camera.layers.mask = mask;
    scene.background = background;
  }
};

// src/core/io/ResourceManager.ts
function gatherResources(pass, result) {
  for (const input of pass.input.buffers.values()) {
    result.add(input);
  }
  for (const output of pass.output.buffers.values()) {
    result.add(output);
  }
  for (const subpass of pass.subpasses) {
    gatherResources(subpass, result);
  }
}
var ResourceManager = class {
  /**
   * A collection of active render pipelines.
   */
  pipelines;
  /**
   * A set of resources that are currently being used in the render pipelines.
   */
  activeResources;
  /**
   * Constructs a new resource manager.
   */
  constructor(pipelines) {
    this.pipelines = pipelines;
    this.activeResources = /* @__PURE__ */ new Set();
  }
  /**
   * Gathers all resources from all pipelines.
   *
   * @return The resources.
   */
  gatherResources() {
    const result = /* @__PURE__ */ new Set();
    for (const pipeline of this.pipelines) {
      for (const pass of pipeline.passes) {
        gatherResources(pass, result);
      }
    }
    return result;
  }
  /**
   * Optimizes resources across all pipelines.
   */
  optimize() {
    const resources = this.gatherResources();
    for (const resource of this.activeResources) {
      if (resource instanceof DisposableResource && !resources.has(resource)) {
        resource.dispose();
      }
    }
    this.activeResources = resources;
  }
};

// src/core/io/IOManager.ts
var IOManager = class _IOManager {
  /**
   * A collection of active render pipelines.
   */
  pipelines;
  /**
   * A resource manager.
   */
  resourceManager;
  /**
   * Keeps track of the original output default buffers.
   *
   * @see {@link RenderPipeline.autoRenderToScreen}
   */
  outputDefaultBuffers;
  /**
   * Indicates whether this manager is currently updating resources.
   */
  updating;
  /**
   * Constructs a new I/O manager.
   */
  constructor() {
    this.pipelines = /* @__PURE__ */ new Set();
    this.resourceManager = new ResourceManager(this.pipelines);
    this.outputDefaultBuffers = /* @__PURE__ */ new WeakMap();
    this.updating = false;
  }
  /**
   * Updates the input buffers of all passes in a given pipeline.
   *
   * @param pipeline - The pipeline to update.
   */
  updateInput(pipeline) {
    const geoPass = _IOManager.findMainGeometryPass(pipeline);
    const passes = pipeline.passes.filter((x) => x.enabled);
    for (let i = 0, j = 1, l = passes.length; i < l; ++i, ++j) {
      const pass = passes[i];
      if (pass === geoPass) {
        continue;
      }
      if (j < l && pass instanceof ClearPass) {
        const nextPass = passes[j];
        pass.scene = nextPass.scene;
        pass.camera = nextPass.camera;
      } else if (!(pass instanceof GeometryPass) && geoPass !== void 0) {
        pass.scene = geoPass.scene;
        pass.camera = geoPass.camera;
      }
      _IOManager.assignGBufferTextures(pass, geoPass);
    }
    let outputBuffer;
    for (let i = 0, j = 1, l = passes.length; j < l; ++i, ++j) {
      const pass = passes[i];
      const nextPass = passes[j];
      if (!(pass instanceof ClearPass) && pass.output.hasDefaultBuffer && pass.output.defaultBuffer.value !== null) {
        outputBuffer = pass.output.defaultBuffer;
      }
      pass.output.defines.forEach((value, key) => nextPass.input.defines.set(key, value));
      pass.output.uniforms.forEach((value, key) => nextPass.input.uniforms.set(key, value));
      if (outputBuffer === void 0) {
        nextPass.input.buffers.delete(Input.BUFFER_DEFAULT);
      } else if (outputBuffer !== void 0) {
        nextPass.input.defaultBuffer = outputBuffer.texture;
      }
    }
  }
  /**
   * Restores the original output buffers.
   *
   * @param passes - The passes to update.
   */
  restoreOutputBuffers(passes) {
    const outputDefaultBuffers = this.outputDefaultBuffers;
    for (const pass of passes) {
      if (pass.output.defaultBuffer === null) {
        continue;
      }
      if (outputDefaultBuffers.has(pass.output.defaultBuffer)) {
        const originalBuffer = outputDefaultBuffers.get(pass.output.defaultBuffer);
        outputDefaultBuffers.delete(pass.output.defaultBuffer);
        pass.output.defaultBuffer = originalBuffer;
      }
    }
  }
  /**
   * Updates the output buffers of all passes in a given pipeline.
   *
   * @param pipeline - The pipeline to update.
   */
  updateOutput(pipeline) {
    const passes = pipeline.passes.filter((x) => x.enabled);
    if (pipeline.autoRenderToScreen && passes.length > 0) {
      this.restoreOutputBuffers(passes);
      const outputDefaultBuffers = this.outputDefaultBuffers;
      const lastPass = passes[passes.length - 1];
      if (lastPass.output.defaultBuffer !== null) {
        outputDefaultBuffers.set(lastPass.output.defaultBuffer, lastPass.output.defaultBuffer.value);
        lastPass.output.defaultBuffer = null;
      }
    }
    for (let i = 0, j = 1, l = passes.length; j < l; ++i, ++j) {
      const pass = passes[i];
      if (pass instanceof ClearPass) {
        const nextPass = passes[j];
        nextPass.output.defines.forEach((value, key) => pass.output.defines.set(key, value));
        nextPass.output.uniforms.forEach((value, key) => pass.output.uniforms.set(key, value));
        pass.output.defaultBuffer = nextPass.output.defaultBuffer;
      }
    }
  }
  /**
   * Adds a render pipeline.
   *
   * @param pipeline - The pipeline to add.
   */
  addPipeline(pipeline) {
    this.pipelines.add(pipeline);
  }
  /**
   * Removes a render pipeline.
   *
   * @param pipeline - The pipeline to remove.
   */
  removePipeline(pipeline) {
    this.pipelines.delete(pipeline);
  }
  /**
   * Updates the input and output resources of a given pipeline.
   *
   * @param pipeline - The pipeline to update.
   */
  updatePipeline(pipeline) {
    _IOManager.gatherGBufferComponents(pipeline);
    this.updateOutput(pipeline);
    this.updateInput(pipeline);
  }
  /**
   * Updates the input and output resources of all pipelines.
   */
  update() {
    if (this.updating) {
      return;
    }
    this.updating = true;
    for (const pipeline of this.pipelines) {
      this.updatePipeline(pipeline);
    }
    this.resourceManager.optimize();
    this.updating = false;
  }
  /**
   * Returns the main geometry pass of the given pipeline.
   *
   * @param pipeline - A pipeline.
   * @return The geometry pass, or undefined if there is none.
   */
  static findMainGeometryPass(pipeline) {
    return pipeline.passes.find((x) => x.enabled && x instanceof GeometryPass);
  }
  /**
   * Collects all required G-Buffer components for a given pipeline.
   *
   * @param pipeline - The pipeline.
   */
  static gatherGBufferComponents(pipeline) {
    const geoPass = _IOManager.findMainGeometryPass(pipeline);
    if (geoPass === void 0) {
      return;
    }
    geoPass.gBufferComponents.clear();
    for (const pass of pipeline.passes.filter((x) => x.enabled)) {
      for (const component of pass.input.gBuffer) {
        geoPass.gBufferComponents.add(component);
      }
    }
    const geoPasses = pipeline.passes.filter((x) => x.enabled && x instanceof GeometryPass);
    if (geoPasses.length <= 1 || !geoPass.gBufferComponents.has("Color" /* COLOR */)) {
      return;
    }
    for (let i = 1, l = geoPasses.length; i < l; ++i) {
      const pass = geoPasses[i];
      pass.gBufferComponents.add("Color" /* COLOR */);
      if (pass.depthBuffer) {
        pass.gBufferComponents.add("Depth" /* DEPTH */);
        pass.input.gBuffer.add("Depth" /* DEPTH */);
        geoPass.gBufferComponents.add("Depth" /* DEPTH */);
      }
    }
  }
  /**
   * Assigns G-Buffer components to a given pass.
   *
   * @param pass - A pass.
   * @param geoPass - The main geometry pass.
   */
  static assignGBufferTextures(pass, geoPass) {
    if (geoPass === void 0 || geoPass.gBuffer === null) {
      return;
    }
    pass.input.gBufferConfig = geoPass.gBufferConfig;
    const indices = extractIndices(geoPass.gBuffer);
    for (const component of pass.input.gBuffer) {
      if (component === "Depth" /* DEPTH */) {
        pass.input.buffers.set(component, new TextureResource(geoPass.gBuffer.depthTexture));
      } else if (indices.has(component)) {
        const index = indices.get(component);
        pass.input.buffers.set(component, new TextureResource(geoPass.gBuffer.textures[index]));
      }
    }
  }
};

// src/core/RenderPipeline.ts
import { Timer, Vector2 as Vector24, Vector4 as Vector42 } from "three";

// src/shader-chunks/ShaderChunkExtensions.ts
import { ShaderChunk, ShaderLib as ShaderLib3 } from "three";

// src/shader-chunks/shaders/camera-pars.frag
var camera_pars_default = `uniform mat4 projectionMatrix;uniform mat4 projectionMatrixInverse;uniform vec3 cameraParams;
#define CAMERA_NEAR cameraParams.x
#define CAMERA_FAR cameraParams.y
#define CAMERA_ASPECT cameraParams.z
#ifdef PERSPECTIVE_CAMERA
#define getViewZ(depth) perspectiveDepthToViewZ(depth, CAMERA_NEAR, CAMERA_FAR)
#else
#define getViewZ(depth) orthographicDepthToViewZ(depth, CAMERA_NEAR, CAMERA_FAR)
#endif
vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(projectionMatrixInverse*clipPosition).xyz;}vec3 getViewPosition(const in vec2 screenPosition,const in float depth){return getViewPosition(screenPosition,depth,getViewZ(depth));}`;

// src/shader-chunks/shaders/colorspace-conversion-pars.frag
var colorspace_conversion_pars_default = `vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}`;

// src/shader-chunks/shaders/default-output-pars.frag
var default_output_pars_default = `#ifndef gl_FragColor
layout(location=0)out OUTPUT_COLOR_PRECISION vec4 out_FragData0;
#define gl_FragColor out_FragData0
#ifndef out_Color
#define out_Color out_FragData0
#endif
#endif`;

// src/shader-chunks/shaders/depth-buffer-pars.frag
var depth_buffer_pars_default = `#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif`;

// src/shader-chunks/shaders/depth-buffer-precision-pars.frag
var depth_buffer_precision_pars_default = `#ifdef GL_FRAGMENT_PRECISION_HIGH
#define DEPTH_BUFFER_PRECISION highp
#else
#define DEPTH_BUFFER_PRECISION mediump
#endif`;

// src/shader-chunks/shaders/depth-utils-pars.frag
var depth_utils_pars_default = `float readDepth(sampler2D depthBuffer,const in vec2 uv,const in float near,const in float far){float depth=texture(depthBuffer,uv).r;
#ifdef USE_REVERSEDEPTHBUF
return 1.0-depth;
#else
#ifdef USE_LOGDEPTHBUF
float d=pow(2.0,depth*log2(far+1.0))-1.0;float a=far/(far-near);float b=far*near/(near-far);depth=a+b/d;
#endif
return depth;
#endif
}
#if defined(CAMERA_NEAR) && defined(CAMERA_FAR)
#define readDepth(depthBuffer, uv) readDepth(depthBuffer, uv, CAMERA_NEAR, CAMERA_FAR);
#endif`;

// src/shader-chunks/shaders/frame-buffer-precision-pars.frag
var frame_buffer_precision_pars_default = `#ifdef FRAME_BUFFER_PRECISION_HIGH
#define FRAME_BUFFER_PRECISION mediump
#else
#define FRAME_BUFFER_PRECISION lowp
#endif`;

// src/shader-chunks/shaders/gbuffer-default-output.frag
var gbuffer_default_output_default = `#ifdef out_Color
out_Color=vec4(0.0);
#endif
#ifdef out_Emission
out_Emission=vec4(0.0);
#endif
#ifdef out_ORM
out_ORM=vec4(0.0);
#endif
#ifdef out_Normal
out_Normal=vec2(0.0);
#endif`;

// src/shader-chunks/shaders/input-buffer-pars.frag
var input_buffer_pars_default = `#ifdef FRAME_BUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif`;

// src/shader-chunks/shaders/normal-codec-pars.frag
var normal_codec_pars_default = `vec2 pp_encodeNormal(vec3 n){n/=(abs(n.x)+abs(n.y)+abs(n.z));n.xy=(n.z>=0.0)?n.xy:(1.0-abs(n.yx))*sign(n.xy);return n.xy;}vec3 pp_decodeNormal(vec2 f){vec3 n=vec3(f.x,f.y,1.0-abs(f.x)-abs(f.y));float t=clamp(-n.z,0.0,1.0);n.xy+=vec2(n.x>=0.0?-t:t,n.y>=0.0?-t:t);return normalize(n);}`;

// src/shader-chunks/shaders/normal-utils-pars.frag
var normal_utils_pars_default = `vec3 readNormal(mediump sampler2D normalBuffer,const in vec2 uv){return pp_decodeNormal(texture(normalBuffer,uv).xy);}`;

// src/shader-chunks/shaders/resolution-pars.frag
var resolution_pars_default = `uniform vec4 resolution;`;

// src/shader-chunks/shaders/world-utils-pars.frag
var world_utils_pars_default = `uniform mat4 viewMatrixInverse;
#define getWorldPosition(viewPosition) (viewMatrixInverse * vec4(viewPosition, 1.0)).xyz
#define getDistance(viewPosition) length(viewPosition)`;

// src/shader-chunks/shaders/gbuffer-normal.frag
var gbuffer_normal_default = `#ifdef out_Normal
out_Normal.xy=pp_encodeNormal(normal);
#endif`;

// src/shader-chunks/shaders/gbuffer-occlusion.frag
var gbuffer_occlusion_default = `#ifdef out_ORM
#ifdef USE_AOMAP
out_ORM.x=ambientOcclusion;
#else
out_ORM.x=1.0;
#endif
#endif`;

// src/shader-chunks/shaders/gbuffer-roughness.frag
var gbuffer_roughness_default = `#ifdef out_ORM
out_ORM.y=roughnessFactor;
#endif`;

// src/shader-chunks/shaders/gbuffer-metalness.frag
var gbuffer_metalness_default = `#ifdef out_ORM
out_ORM.z=metalnessFactor;
#endif`;

// src/shader-chunks/shaders/gbuffer-emission.frag
var gbuffer_emission_default = `#ifdef out_Emission
out_Emission=vec4(totalEmissiveRadiance,1.0);
#endif`;

// src/shader-chunks/ShaderChunkExtensions.ts
var ShaderChunkExtensions = class _ShaderChunkExtensions {
  /**
   * Indicates whether the custom shader chunks have been registered.
   */
  static registered = false;
  /**
   * Registers custom shader chunks.
   */
  static register() {
    if (_ShaderChunkExtensions.registered) {
      return;
    }
    _ShaderChunkExtensions.registered = true;
    Object.assign(ShaderChunk, {
      "pp_camera_pars_fragment": camera_pars_default,
      "pp_colorspace_conversion_pars_fragment": colorspace_conversion_pars_default,
      "pp_default_output_pars_fragment": default_output_pars_default,
      "pp_default_output_fragment": gbuffer_default_output_default,
      "pp_depth_buffer_pars_fragment": depth_buffer_pars_default,
      "pp_depth_buffer_precision_pars_fragment": depth_buffer_precision_pars_default,
      "pp_depth_utils_pars_fragment": depth_utils_pars_default,
      "pp_frame_buffer_precision_pars_fragment": frame_buffer_precision_pars_default,
      "pp_input_buffer_pars_fragment": input_buffer_pars_default,
      "pp_normal_codec_pars_fragment": normal_codec_pars_default,
      "pp_normal_utils_pars_fragment": normal_utils_pars_default,
      "pp_resolution_pars_fragment": resolution_pars_default,
      "pp_world_utils_pars_fragment": world_utils_pars_default
    });
    ShaderChunk.normal_fragment_maps += "\n" + gbuffer_normal_default;
    ShaderChunk.aomap_fragment += "\n" + gbuffer_occlusion_default;
    ShaderChunk.roughnessmap_fragment += "\n" + gbuffer_roughness_default;
    ShaderChunk.metalnessmap_fragment += "\n" + gbuffer_metalness_default;
    ShaderChunk.emissivemap_fragment += "\n" + gbuffer_emission_default;
    const shaders = [
      ShaderLib3.background,
      ShaderLib3.backgroundCube,
      ShaderLib3.basic,
      ShaderLib3.cube,
      ShaderLib3.dashed,
      ShaderLib3.lambert,
      ShaderLib3.matcap,
      ShaderLib3.phong,
      ShaderLib3.physical,
      ShaderLib3.points,
      ShaderLib3.sprite,
      ShaderLib3.standard,
      ShaderLib3.toon
    ];
    for (const shader of shaders) {
      shader.fragmentShader = shader.fragmentShader.replace(
        /(^ *void\s+main\(\)\s+{.*)/m,
        "#include <pp_normal_codec_pars_fragment>\n\n$1\n\n#include <pp_default_output_fragment>"
      );
    }
  }
};

// src/core/RenderPipeline.ts
var v2 = /* @__PURE__ */ new Vector24();
var RenderPipeline = class _RenderPipeline {
  /**
   * A shared I/O manager.
   */
  static ioManager = /* @__PURE__ */ new IOManager();
  /**
   * Keeps track of passes that have been added to a pipeline.
   */
  static registeredPasses = /* @__PURE__ */ new WeakSet();
  /**
   * A listener that triggers an I/O update.
   */
  static listener = () => _RenderPipeline.ioManager.update();
  // #region Backing Data
  /**
   * @see {@link timer}
   */
  _timer;
  /**
   * @see {@link passes}
   */
  _passes;
  /**
   * @see {@link renderer}
   */
  _renderer;
  /**
   * @see {@link autoRenderToScreen}
   */
  _autoRenderToScreen;
  // #endregion
  /**
   * The current resolution.
   *
   * @see {@link updateStyle} to control whether the style of the canvas should be updated.
   */
  resolution;
  /**
   * Determines whether the style of the canvas should be updated when the resolution is changed.
   *
   * @defaultValue true
   */
  updateStyle;
  /**
   * Constructs a new render pipeline.
   *
   * @param renderer - A renderer.
   */
  constructor(renderer = null) {
    ShaderChunkExtensions.register();
    _RenderPipeline.ioManager.addPipeline(this);
    this._timer = new Timer();
    this._passes = [];
    this._renderer = null;
    this._autoRenderToScreen = true;
    this.resolution = new Resolution();
    this.resolution.addEventListener("change", () => this.onResolutionChange());
    this.updateStyle = true;
    this.renderer = renderer;
  }
  /**
   * Determines whether the last pass should automatically render to screen.
   *
   * @defaultValue true
   */
  get autoRenderToScreen() {
    return this._autoRenderToScreen;
  }
  set autoRenderToScreen(value) {
    if (this.autoRenderToScreen !== value) {
      this._autoRenderToScreen = value;
      _RenderPipeline.ioManager.update();
    }
  }
  /**
   * The renderer.
   */
  get renderer() {
    return this._renderer;
  }
  set renderer(value) {
    this._renderer = value;
    for (const pass of this.passes) {
      pass.renderer = value;
    }
    if (value !== null) {
      value.autoClear = false;
      this.setPixelRatio(value.getPixelRatio());
      if (this.passes.length > 0) {
        _RenderPipeline.ioManager.update();
      }
    }
  }
  /**
   * The internal timer.
   */
  get timer() {
    return this._timer;
  }
  /**
   * A list of all registered passes.
   */
  get passes() {
    return this._passes;
  }
  /**
   * Registers a pass.
   *
   * @param pass - The pass.
   */
  registerPass(pass) {
    _RenderPipeline.registeredPasses.add(pass);
    pass.resolution.pixelRatio = this.resolution.scaledPixelRatio;
    pass.resolution.copyBaseSize(this.resolution);
    pass.renderer = this.renderer;
    pass.timer = this.timer;
    pass.attached = true;
    pass.addEventListener("toggle", _RenderPipeline.listener);
    pass.input.addEventListener("change", _RenderPipeline.listener);
    pass.output.addEventListener("change", _RenderPipeline.listener);
  }
  /**
   * Unregisters a pass.
   *
   * @param pass - The pass.
   */
  unregisterPass(pass) {
    _RenderPipeline.registeredPasses.delete(pass);
    pass.renderer = null;
    pass.timer = null;
    pass.attached = false;
    pass.removeEventListener("toggle", _RenderPipeline.listener);
    pass.input.removeEventListener("change", _RenderPipeline.listener);
    pass.output.removeEventListener("change", _RenderPipeline.listener);
  }
  /**
   * Adds one or more passes.
   *
   * @throws If one of the passes has already been added to a pipeline.
   * @param passes - The passes to add.
   */
  add(...passes) {
    for (const pass of passes) {
      if (_RenderPipeline.registeredPasses.has(pass)) {
        throw new Error(`The pass "${pass.name}" has already been added to a pipeline`);
      }
      this.registerPass(pass);
      this._passes.push(pass);
    }
    _RenderPipeline.ioManager.update();
  }
  /**
   * Removes one or more passes.
   *
   * @param passes - The passes to remove.
   */
  remove(...passes) {
    let removedAny = false;
    for (const pass of passes) {
      const passes2 = this._passes;
      const index = passes2.indexOf(pass);
      const exists = index !== -1;
      const removed = exists && passes2.splice(index, 1).length > 0;
      if (removed) {
        this.unregisterPass(pass);
        removedAny = true;
      }
    }
    if (removedAny) {
      _RenderPipeline.ioManager.update();
    }
  }
  /**
   * Removes all passes.
   */
  removeAllPasses() {
    for (const pass of this.passes) {
      this.unregisterPass(pass);
    }
    this._passes = [];
    _RenderPipeline.ioManager.update();
  }
  /**
   * Handles resolution change events.
   */
  onResolutionChange() {
    const renderer = this.renderer;
    if (renderer === null) {
      console.debug("Unable to update the render size because the renderer is null");
      return;
    }
    const { baseWidth, baseHeight, pixelRatio, scaledPixelRatio, scale } = this.resolution;
    const logicalSize = renderer.getSize(v2);
    if (renderer.getPixelRatio() !== pixelRatio) {
      renderer.setPixelRatio(pixelRatio);
    }
    if (scale === 1) {
      if (logicalSize.width !== baseWidth || logicalSize.height !== baseHeight) {
        renderer.setSize(baseWidth, baseHeight, this.updateStyle);
      }
    } else {
      const scaledWidth = baseWidth * scale;
      const scaledHeight = baseHeight * scale;
      if (logicalSize.width !== scaledWidth || logicalSize.height !== scaledHeight) {
        if (this.updateStyle) {
          renderer.setSize(baseWidth, baseHeight, true);
        }
        renderer.setSize(scaledWidth, scaledHeight, false);
      }
    }
    for (const pass of this.passes) {
      pass.resolution.pixelRatio = scaledPixelRatio;
      pass.resolution.setBaseSize(baseWidth, baseHeight);
    }
  }
  /**
   * Sets the device pixel ratio.
   *
   * @param pixelRatio - The pixel ratio.
   */
  setPixelRatio(pixelRatio) {
    const previousUpdateStyle = this.updateStyle;
    this.updateStyle = false;
    this.resolution.pixelRatio = pixelRatio;
    this.updateStyle = previousUpdateStyle;
  }
  /**
   * Sets the render size.
   *
   * @param width - The width in logical pixels (before pixel ratio).
   * @param height - The height in logical pixels (before pixel ratio).
   * @param updateStyle - Whether the style of the canvas should be updated. Default is `true`.
   */
  setSize(width, height, updateStyle = true) {
    if (this.renderer !== null) {
      this.setPixelRatio(this.renderer.getPixelRatio());
    }
    const previousUpdateStyle = this.updateStyle;
    this.updateStyle = updateStyle;
    this.resolution.setSize(width, height);
    this.updateStyle = previousUpdateStyle;
  }
  /**
   * Sets the viewport for all passes.
   *
   * Please note that viewport settings need to be enabled on a per-pass basis to take effect.
   *
   * @param x - The X-offset starting in the lower left corner, or a vector that describes the viewport.
   * @param y - The Y-offset starting in the lower left corner.
   * @param width - The width in logical pixels (before pixel ratio).
   * @param height - The height in logical pixels (before pixel ratio).
   */
  setViewport(x, y = 0, width = 0, height = 0) {
    if (x instanceof Vector42) {
      const v3 = x;
      x = v3.x;
      y = v3.y;
      width = v3.z;
      height = v3.w;
    }
    for (const pass of this.passes) {
      pass.viewport.set(x, y, width, height);
    }
  }
  /**
   * Sets the scissor region for all passes.
   *
   * Please note that scissor settings need to be enabled on a per-pass basis to take effect.
   *
   * @param x - The X-offset, or a vector that describes the scissor region.
   * @param y - The Y-offset starting in the lower left corner.
   * @param width - The width in logical pixels (before pixel ratio).
   * @param height - The height in logical pixels (before pixel ratio).
   */
  setScissor(x, y = 0, width = 0, height = 0) {
    if (x instanceof Vector42) {
      const v3 = x;
      x = v3.x;
      y = v3.y;
      width = v3.z;
      height = v3.w;
    }
    for (const pass of this.passes) {
      pass.scissor.set(x, y, width, height);
    }
  }
  /**
   * Compiles all passes in this pipeline.
   *
   * @return A promise that resolves when the compilation has finished.
   */
  async compile() {
    const promises = [];
    for (const pass of this.passes) {
      promises.push(pass.compile());
    }
    await Promise.all(promises);
  }
  /**
   * Renders this pipeline.
   *
   * This method should be called once per frame via `requestAnimationFrame`.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
   * @param timestamp - The current time in milliseconds.
   */
  render(timestamp) {
    if (this.renderer === null) {
      return;
    }
    this._timer.update(timestamp);
    for (const pass of this.passes) {
      if (pass.enabled) {
        pass.render();
      }
    }
  }
  dispose() {
    _RenderPipeline.ioManager.removePipeline(this);
    for (const pass of this.passes) {
      pass.dispose();
    }
    this.removeAllPasses();
    this._timer.dispose();
    Pass.fullscreenGeometry.dispose();
  }
};

// src/enums/ColorChannel.ts
var ColorChannel = /* @__PURE__ */ ((ColorChannel2) => {
  ColorChannel2[ColorChannel2["RED"] = 0] = "RED";
  ColorChannel2[ColorChannel2["GREEN"] = 1] = "GREEN";
  ColorChannel2[ColorChannel2["BLUE"] = 2] = "BLUE";
  ColorChannel2[ColorChannel2["ALPHA"] = 3] = "ALPHA";
  return ColorChannel2;
})(ColorChannel || {});

// src/enums/DepthCopyMode.ts
var DepthCopyMode = /* @__PURE__ */ ((DepthCopyMode2) => {
  DepthCopyMode2[DepthCopyMode2["FULL"] = 0] = "FULL";
  DepthCopyMode2[DepthCopyMode2["SINGLE"] = 1] = "SINGLE";
  return DepthCopyMode2;
})(DepthCopyMode || {});

// src/enums/DepthTestStrategy.ts
var DepthTestStrategy = /* @__PURE__ */ ((DepthTestStrategy2) => {
  DepthTestStrategy2[DepthTestStrategy2["DEFAULT"] = 0] = "DEFAULT";
  DepthTestStrategy2[DepthTestStrategy2["KEEP_MAX_DEPTH"] = 1] = "KEEP_MAX_DEPTH";
  DepthTestStrategy2[DepthTestStrategy2["DISCARD_MAX_DEPTH"] = 2] = "DISCARD_MAX_DEPTH";
  return DepthTestStrategy2;
})(DepthTestStrategy || {});

// src/enums/EffectShaderSection.ts
var EffectShaderSection = /* @__PURE__ */ ((EffectShaderSection2) => {
  EffectShaderSection2["FRAGMENT_HEAD_EFFECTS"] = "$FRAGMENT_HEAD_EFFECTS";
  EffectShaderSection2["FRAGMENT_HEAD_GBUFFER"] = "$FRAGMENT_HEAD_GBUFFER";
  EffectShaderSection2["FRAGMENT_HEAD_GDATA"] = "$FRAGMENT_HEAD_GDATA";
  EffectShaderSection2["FRAGMENT_MAIN_UV"] = "$FRAGMENT_MAIN_UV";
  EffectShaderSection2["FRAGMENT_MAIN_GDATA"] = "$FRAGMENT_MAIN_GDATA";
  EffectShaderSection2["FRAGMENT_MAIN_IMAGE"] = "$FRAGMENT_MAIN_IMAGE";
  EffectShaderSection2["VERTEX_HEAD"] = "$VERTEX_HEAD";
  EffectShaderSection2["VERTEX_MAIN_SUPPORT"] = "$VERTEX_MAIN_SUPPORT";
  return EffectShaderSection2;
})(EffectShaderSection || {});

// src/enums/GBufferDebug.ts
var GBufferDebug = /* @__PURE__ */ ((GBufferDebug2) => {
  GBufferDebug2["POSITION"] = "Position";
  GBufferDebug2["DISTANCE"] = "Distance";
  return GBufferDebug2;
})(GBufferDebug || {});

// src/enums/GlitchMode.ts
var GlitchMode = /* @__PURE__ */ ((GlitchMode2) => {
  GlitchMode2[GlitchMode2["DISABLED"] = 0] = "DISABLED";
  GlitchMode2[GlitchMode2["SPORADIC"] = 1] = "SPORADIC";
  GlitchMode2[GlitchMode2["CONSTANT_MILD"] = 2] = "CONSTANT_MILD";
  GlitchMode2[GlitchMode2["CONSTANT_WILD"] = 3] = "CONSTANT_WILD";
  return GlitchMode2;
})(GlitchMode || {});

// src/enums/HalftoneShape.ts
var HalftoneShape = /* @__PURE__ */ ((HalftoneShape2) => {
  HalftoneShape2[HalftoneShape2["DOT"] = 1] = "DOT";
  HalftoneShape2[HalftoneShape2["ELLIPSE"] = 2] = "ELLIPSE";
  HalftoneShape2[HalftoneShape2["LINE"] = 3] = "LINE";
  HalftoneShape2[HalftoneShape2["SQUARE"] = 4] = "SQUARE";
  return HalftoneShape2;
})(HalftoneShape || {});

// src/enums/KernelSize.ts
var KernelSize = /* @__PURE__ */ ((KernelSize2) => {
  KernelSize2[KernelSize2["VERY_SMALL"] = 0] = "VERY_SMALL";
  KernelSize2[KernelSize2["SMALL"] = 1] = "SMALL";
  KernelSize2[KernelSize2["MEDIUM"] = 2] = "MEDIUM";
  KernelSize2[KernelSize2["LARGE"] = 3] = "LARGE";
  KernelSize2[KernelSize2["VERY_LARGE"] = 4] = "VERY_LARGE";
  KernelSize2[KernelSize2["HUGE"] = 5] = "HUGE";
  return KernelSize2;
})(KernelSize || {});

// src/enums/MaskFunction.ts
var MaskFunction = /* @__PURE__ */ ((MaskFunction2) => {
  MaskFunction2[MaskFunction2["DISCARD"] = 0] = "DISCARD";
  MaskFunction2[MaskFunction2["MULTIPLY"] = 1] = "MULTIPLY";
  return MaskFunction2;
})(MaskFunction || {});

// src/enums/SMAAEdgeDetectionMode.ts
var SMAAEdgeDetectionMode = /* @__PURE__ */ ((SMAAEdgeDetectionMode2) => {
  SMAAEdgeDetectionMode2[SMAAEdgeDetectionMode2["DEPTH"] = 0] = "DEPTH";
  SMAAEdgeDetectionMode2[SMAAEdgeDetectionMode2["LUMA"] = 1] = "LUMA";
  SMAAEdgeDetectionMode2[SMAAEdgeDetectionMode2["COLOR"] = 2] = "COLOR";
  return SMAAEdgeDetectionMode2;
})(SMAAEdgeDetectionMode || {});

// src/enums/SMAAPredicationMode.ts
var SMAAPredicationMode = /* @__PURE__ */ ((SMAAPredicationMode2) => {
  SMAAPredicationMode2[SMAAPredicationMode2["DISABLED"] = 0] = "DISABLED";
  SMAAPredicationMode2[SMAAPredicationMode2["DEPTH"] = 1] = "DEPTH";
  SMAAPredicationMode2[SMAAPredicationMode2["CUSTOM"] = 2] = "CUSTOM";
  return SMAAPredicationMode2;
})(SMAAPredicationMode || {});

// src/enums/SMAAPreset.ts
var SMAAPreset = /* @__PURE__ */ ((SMAAPreset2) => {
  SMAAPreset2[SMAAPreset2["LOW"] = 0] = "LOW";
  SMAAPreset2[SMAAPreset2["MEDIUM"] = 1] = "MEDIUM";
  SMAAPreset2[SMAAPreset2["HIGH"] = 2] = "HIGH";
  SMAAPreset2[SMAAPreset2["ULTRA"] = 3] = "ULTRA";
  return SMAAPreset2;
})(SMAAPreset || {});

// src/enums/ToneMapping.ts
var ToneMapping = /* @__PURE__ */ ((ToneMapping2) => {
  ToneMapping2[ToneMapping2["LINEAR"] = 0] = "LINEAR";
  ToneMapping2[ToneMapping2["REINHARD"] = 1] = "REINHARD";
  ToneMapping2[ToneMapping2["CINEON"] = 2] = "CINEON";
  ToneMapping2[ToneMapping2["ACES_FILMIC"] = 3] = "ACES_FILMIC";
  ToneMapping2[ToneMapping2["AGX"] = 4] = "AGX";
  ToneMapping2[ToneMapping2["NEUTRAL"] = 5] = "NEUTRAL";
  ToneMapping2[ToneMapping2["CUSTOM"] = 6] = "CUSTOM";
  return ToneMapping2;
})(ToneMapping || {});

// src/enums/VignetteTechnique.ts
var VignetteTechnique = /* @__PURE__ */ ((VignetteTechnique2) => {
  VignetteTechnique2[VignetteTechnique2["DEFAULT"] = 0] = "DEFAULT";
  VignetteTechnique2[VignetteTechnique2["ESKIL"] = 1] = "ESKIL";
  return VignetteTechnique2;
})(VignetteTechnique || {});

// src/effects/blending/BlendFunction.ts
var BlendFunction = class _BlendFunction {
  /**
   * An ID manager.
   */
  static idManager = /* @__PURE__ */ new IdManager();
  id;
  /**
   * A unique blend function name.
   */
  name;
  /**
   * The shader code.
   */
  shader;
  /**
   * Indicates whether this blend function supports HDR colors.
   *
   * Shaders that assume a color value range of [0, 1] are not compatible with HDR.
   */
  supportsHDR;
  /**
   * Constructs a new blend function.
   *
   * @param name - A unique blend function name.
   * @param shader - The shader code.
   * @param supportsHDR - Indicates whether this blend function supports HDR colors.
   */
  constructor(name, shader, supportsHDR = false) {
    this.id = _BlendFunction.idManager.getNextId();
    this.name = name;
    this.shader = shader;
    this.supportsHDR = supportsHDR;
  }
};

// src/effects/blending/BlendMode.ts
import { EventDispatcher as EventDispatcher11, Uniform as Uniform4 } from "three";
var BlendMode = class extends EventDispatcher11 {
  /**
   * @see {@link blendFunction}
   */
  _blendFunction;
  /**
   * A uniform that controls the opacity of this blend mode.
   *
   * @see {@link opacity}
   */
  opacityUniform;
  /**
   * Constructs a new blend mode.
   *
   * @param blendFunction - The blend function.
   * @param opacity - The opacity of the new color that will be blended with the base color.
   */
  constructor(blendFunction, opacity = 1) {
    super();
    this._blendFunction = blendFunction;
    this.opacityUniform = new Uniform4(opacity);
  }
  /**
   * A convenience accessor for the opacity uniform value.
   *
   * @see {@link opacityUniform}
   */
  get opacity() {
    return this.opacityUniform.value;
  }
  set opacity(value) {
    this.opacityUniform.value = value;
  }
  /**
   * The blend function.
   */
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(value) {
    this._blendFunction = value;
    this.dispatchEvent({ type: "change" });
  }
};

// src/effects/blending/blend-functions/shaders/add.frag
var add_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),opacity);}`;

// src/effects/blending/blend-functions/AddBlendFunction.ts
var AddBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new add blend function.
   */
  constructor() {
    super("add", add_default, true);
  }
};

// src/effects/blending/blend-functions/shaders/alpha.frag
var alpha_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}`;

// src/effects/blending/blend-functions/AlphaBlendFunction.ts
var AlphaBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new alpha blend function.
   */
  constructor() {
    super("alpha", alpha_default, true);
  }
};

// src/effects/blending/blend-functions/shaders/average.frag
var average_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),opacity);}`;

// src/effects/blending/blend-functions/AverageBlendFunction.ts
var AverageBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new average blend function.
   */
  constructor() {
    super("average", average_default, true);
  }
};

// src/effects/blending/blend-functions/shaders/color.frag
var color_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/ColorBlendFunction.ts
var ColorBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new color blend function.
   */
  constructor() {
    super("color", color_default);
  }
};

// src/effects/blending/blend-functions/shaders/color-burn.frag
var color_burn_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/ColorBurnBlendFunction.ts
var ColorBurnBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new color burn blend function.
   */
  constructor() {
    super("color-burn", color_burn_default);
  }
};

// src/effects/blending/blend-functions/shaders/color-dodge.frag
var color_dodge_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/ColorDodgeBlendFunction.ts
var ColorDodgeBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new color dodge blend function.
   */
  constructor() {
    super("color-dodge", color_dodge_default);
  }
};

// src/effects/blending/blend-functions/shaders/darken.frag
var darken_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),opacity);}`;

// src/effects/blending/blend-functions/DarkenBlendFunction.ts
var DarkenBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new darken blend function.
   */
  constructor() {
    super("darken", darken_default, true);
  }
};

// src/effects/blending/blend-functions/shaders/difference.frag
var difference_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),opacity);}`;

// src/effects/blending/blend-functions/DifferenceBlendFunction.ts
var DifferenceBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new difference blend function.
   */
  constructor() {
    super("difference", difference_default, true);
  }
};

// src/effects/blending/blend-functions/shaders/divide.frag
var divide_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),opacity);}`;

// src/effects/blending/blend-functions/DivideBlendFunction.ts
var DivideBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new divide blend function.
   */
  constructor() {
    super("divide", divide_default, true);
  }
};

// src/effects/blending/blend-functions/DstBlendFunction.ts
var DstBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new DST blend function.
   */
  constructor() {
    super("dst", null, true);
  }
};

// src/effects/blending/blend-functions/shaders/exclusion.frag
var exclusion_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),opacity);}`;

// src/effects/blending/blend-functions/ExclusionBlendFunction.ts
var ExclusionBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new exclusion blend function.
   */
  constructor() {
    super("exclusion", exclusion_default);
  }
};

// src/effects/blending/blend-functions/shaders/hard-light.frag
var hard_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/HardLightBlendFunction.ts
var HardLightBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new hard light blend function.
   */
  constructor() {
    super("hard-light", hard_light_default);
  }
};

// src/effects/blending/blend-functions/shaders/hard-mix.frag
var hard_mix_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),opacity);}`;

// src/effects/blending/blend-functions/HardMixBlendFunction.ts
var HardMixBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new hard mix blend function.
   */
  constructor() {
    super("hard-mix", hard_mix_default);
  }
};

// src/effects/blending/blend-functions/shaders/hue.frag
var hue_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/HueBlendFunction.ts
var HueBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new hue blend function.
   */
  constructor() {
    super("hue", hue_default);
  }
};

// src/effects/blending/blend-functions/shaders/invert.frag
var invert_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),opacity);}`;

// src/effects/blending/blend-functions/InvertBlendFunction.ts
var InvertBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new invert blend function.
   */
  constructor() {
    super("invert", invert_default);
  }
};

// src/effects/blending/blend-functions/shaders/invert-rgb.frag
var invert_rgb_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),opacity);}`;

// src/effects/blending/blend-functions/InvertRGBBlendFunction.ts
var InvertRGBBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new invert RGB blend function.
   */
  constructor() {
    super("invert-rgb", invert_rgb_default);
  }
};

// src/effects/blending/blend-functions/shaders/lighten.frag
var lighten_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),opacity);}`;

// src/effects/blending/blend-functions/LightenBlendFunction.ts
var LightenBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new lighten blend function.
   */
  constructor() {
    super("lighten", lighten_default, true);
  }
};

// src/effects/blending/blend-functions/shaders/linear-burn.frag
var linear_burn_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}`;

// src/effects/blending/blend-functions/LinearBurnBlendFunction.ts
var LinearBurnBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new linear burn blend function.
   */
  constructor() {
    super("linear-burn", linear_burn_default);
  }
};

// src/effects/blending/blend-functions/shaders/linear-dodge.frag
var linear_dodge_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),opacity);}`;

// src/effects/blending/blend-functions/LinearDodgeBlendFunction.ts
var LinearDodgeBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new linear dodge blend function.
   */
  constructor() {
    super("linear-dodge", linear_dodge_default);
  }
};

// src/effects/blending/blend-functions/shaders/linear-light.frag
var linear_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}`;

// src/effects/blending/blend-functions/LinearLightBlendFunction.ts
var LinearLightBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new linear light blend function.
   */
  constructor() {
    super("linear-light", linear_light_default);
  }
};

// src/effects/blending/blend-functions/shaders/luminosity.frag
var luminosity_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/LuminosityBlendFunction.ts
var LuminosityBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new luminosity blend function.
   */
  constructor() {
    super("luminosity", luminosity_default);
  }
};

// src/effects/blending/blend-functions/shaders/mix.frag
var mix_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}`;

// src/effects/blending/blend-functions/MixBlendFunction.ts
var MixBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new mix blend function.
   */
  constructor() {
    super("mix", mix_default, true);
  }
};

// src/effects/blending/blend-functions/shaders/multiply.frag
var multiply_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),opacity);}`;

// src/effects/blending/blend-functions/MultiplyBlendFunction.ts
var MultiplyBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new multiply blend function.
   */
  constructor() {
    super("multiply", multiply_default, true);
  }
};

// src/effects/blending/blend-functions/shaders/negation.frag
var negation_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),opacity);}`;

// src/effects/blending/blend-functions/NegationBlendFunction.ts
var NegationBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new negation blend function.
   */
  constructor() {
    super("negation", negation_default);
  }
};

// src/effects/blending/blend-functions/shaders/overlay.frag
var overlay_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/OverlayBlendFunction.ts
var OverlayBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new overlay blend function.
   */
  constructor() {
    super("overlay", overlay_default);
  }
};

// src/effects/blending/blend-functions/shaders/pin-light.frag
var pin_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/PinLightBlendFunction.ts
var PinLightBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new pin light blend function.
   */
  constructor() {
    super("pin-light", pin_light_default);
  }
};

// src/effects/blending/blend-functions/shaders/reflect.frag
var reflect_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/ReflectBlendFunction.ts
var ReflectBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new reflect blend function.
   */
  constructor() {
    super("reflect", reflect_default);
  }
};

// src/effects/blending/blend-functions/shaders/saturation.frag
var saturation_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/SaturationBlendFunction.ts
var SaturationBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new saturation blend function.
   */
  constructor() {
    super("saturation", saturation_default);
  }
};

// src/effects/blending/blend-functions/shaders/src.frag
var src_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}`;

// src/effects/blending/blend-functions/SrcBlendFunction.ts
var SrcBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new SRC blend function.
   */
  constructor() {
    super("src", src_default, true);
  }
};

// src/effects/blending/blend-functions/shaders/screen.frag
var screen_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),opacity);}`;

// src/effects/blending/blend-functions/ScreenBlendFunction.ts
var ScreenBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new screen blend function.
   */
  constructor() {
    super("screen", screen_default);
  }
};

// src/effects/blending/blend-functions/shaders/soft-light.frag
var soft_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/SoftLightBlendFunction.ts
var SoftLightBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new soft light blend function.
   */
  constructor() {
    super("soft-light", soft_light_default);
  }
};

// src/effects/blending/blend-functions/shaders/subtract.frag
var subtract_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),opacity);}`;

// src/effects/blending/blend-functions/SubtractBlendFunction.ts
var SubtractBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new subtract blend function.
   */
  constructor() {
    super("subtract", subtract_default);
  }
};

// src/effects/blending/blend-functions/shaders/vivid-light.frag
var vivid_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),opacity);}`;

// src/effects/blending/blend-functions/VividLightBlendFunction.ts
var VividLightBlendFunction = class extends BlendFunction {
  /**
   * Constructs a new vivid light blend function.
   */
  constructor() {
    super("vivid-light", vivid_light_default);
  }
};

// src/effects/ASCIIEffect.ts
import { Color as Color3, Uniform as Uniform5, Vector4 as Vector43 } from "three";

// src/textures/ASCIITexture.ts
import { CanvasTexture, RepeatWrapping } from "three";
var ASCIITexture = class extends CanvasTexture {
  /**
   * The amount of characters in this texture.
   */
  characterCount;
  /**
   * The amount of cells along each side of the texture.
   */
  cellCount;
  /**
   * Constructs a new ASCIITexture.
   */
  constructor({
    characters = " .:,'-^=*+?!|0#X%WM@",
    font = "Arial",
    fontSize = 35,
    size = 1024,
    cellCount = 16
  } = {}) {
    super(
      document.createElement("canvas"),
      void 0,
      RepeatWrapping,
      RepeatWrapping
    );
    this.characterCount = characters.length;
    this.cellCount = cellCount;
    const canvas = this.image;
    canvas.width = canvas.height = size;
    const context = canvas.getContext("2d");
    const cellSize = size / cellCount;
    context.font = `${fontSize}px ${font}`;
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.fillStyle = "#ffffff";
    for (let i = 0, l = characters.length; i < l; ++i) {
      const char = characters[i];
      const x = i % cellCount;
      const y = Math.floor(i / cellCount);
      context.fillText(char, x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
    }
  }
};

// src/effects/Effect.ts
import { NoColorSpace as NoColorSpace2 } from "three";
var Effect = class extends Pass {
  /**
   * The blend mode.
   */
  blendMode;
  /**
   * @see {@link fragmentShader}
   */
  _fragmentShader;
  /**
   * @see {@link vertexShader}
   */
  _vertexShader;
  /**
   * @see {@link inputColorSpace}
   */
  _inputColorSpace;
  /**
   * @see {@link outputColorSpace}
   */
  _outputColorSpace;
  /**
   * A collection of required GBuffer data.
   *
   * This data depends on the current fragment shader and will be updated automatically.
   *
   * @internal
   */
  gData;
  /**
   * A hint that indicates whether this effect will be toggled at runtime.
   *
   * Toggling an effect will also set this flag to `true`.
   *
   * @defaultValue false
   */
  optional;
  /**
   * Constructs a new effect.
   *
   * @param name - A name that will be used for debugging purposes.
   */
  constructor(name) {
    super(name);
    this.blendMode = new BlendMode(new SrcBlendFunction());
    this.blendMode.addEventListener("change", () => this.setChanged());
    this.input.addEventListener("change", () => this.detectGDataUsage());
    this._fragmentShader = null;
    this._vertexShader = null;
    this._inputColorSpace = NoColorSpace2;
    this._outputColorSpace = NoColorSpace2;
    this.gData = /* @__PURE__ */ new Set();
    this.optional = false;
  }
  get enabled() {
    return super.enabled;
  }
  set enabled(value) {
    if (super.enabled !== value) {
      this.optional = true;
    }
    super.enabled = value;
  }
  /**
   * The fragment shader.
   */
  get fragmentShader() {
    return this._fragmentShader;
  }
  set fragmentShader(value) {
    this._fragmentShader = value;
    this.detectGDataUsage();
    this.setChanged();
  }
  /**
   * The vertex shader.
   */
  get vertexShader() {
    return this._vertexShader;
  }
  set vertexShader(value) {
    this._vertexShader = value;
    this.setChanged();
  }
  /**
   * The input color space. Default is `NoColorSpace`, meaning no change.
   *
   * Ensures that the input colors are in the specified color space, converting them if necessary.
   */
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  set inputColorSpace(value) {
    this._inputColorSpace = value;
    this.setChanged();
  }
  /**
   * The output color space. Default is `NoColorSpace`, meaning no change.
   *
   * Should only be defined if this effect converts the input colors to a different color space.
   */
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(value) {
    this._outputColorSpace = value;
    this.setChanged();
  }
  /**
   * Indicates whether this effect defines a `mainImage` function in its fragment shader.
   */
  get hasMainImageFunction() {
    if (this.fragmentShader === null) {
      return false;
    }
    const regExp = /vec4\s+mainImage\s*\([a-z\s]*vec4\s+\w+,[a-z\s]*vec2\s+\w+,[a-z\s]*GData\s+\w+\)/;
    return regExp.test(this.fragmentShader);
  }
  /**
   * Indicates whether this effect defines a `mainUv` function in its fragment shader.
   */
  get hasMainUvFunction() {
    if (this.fragmentShader === null) {
      return false;
    }
    const regExp = /void\s+mainUv\s*\(\s*inout\s+vec2\s+\w+\)/;
    return regExp.test(this.fragmentShader);
  }
  /**
   * Indicates whether this effect defines a `mainSupport` function in its vertex shader.
   */
  get hasMainSupportFunction() {
    if (this.vertexShader === null) {
      return false;
    }
    const regExp = /void\s+mainSupport\s*\([a-z\s]*vec2\s+\w+\)/;
    return regExp.test(this.vertexShader);
  }
  /**
   * Checks the fragment shader for `GData` usage.
   */
  detectGDataUsage() {
    this.gData.clear();
    if (this.input.gBufferConfig === null || !this.hasMainImageFunction) {
      return;
    }
    const shader = this.fragmentShader;
    const gBufferConfig = this.input.gBufferConfig;
    const gDataParamName = /GData\s+(\w+)/.exec(shader)[1];
    for (const value of Object.values(GData)) {
      if (!shader.includes(`${gDataParamName}.${value}`)) {
        continue;
      }
      for (const dependency of gBufferConfig.gDataDependencies.get(value) ?? []) {
        this.gData.add(dependency);
      }
      this.gData.add(value);
    }
    for (const gData of this.gData) {
      for (const component of gBufferConfig.gDataBufferSources.get(gData) ?? []) {
        if (!this.input.gBuffer.has(component)) {
          this.input.gBuffer.add(component);
          console.warn(`${this.name} uses ${gData} but does not declare input G-Buffer component ${component}`);
        }
      }
    }
  }
  /**
   * Validates this effect.
   *
   * @throws If the effect is invalid.
   */
  validate() {
    const fragmentShader = this.fragmentShader;
    if (fragmentShader === null) {
      throw new Error(`Missing fragment shader (${this.name})`);
    }
    if (!this.hasMainImageFunction && !this.hasMainUvFunction) {
      throw new Error(`Could not find a valid mainImage or mainUv function (${this.name})`);
    }
  }
  render() {
  }
};

// src/effects/shaders/ascii.frag
var ascii_default = `uniform sampler2D asciiTexture;uniform vec4 cellCount;
#ifdef USE_COLOR
uniform vec3 color;
#endif
vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){vec2 pixelizedUv=cellCount.zw*(0.5+floor(uv*cellCount.xy));vec4 texel=texture(gBuffer.color,pixelizedUv);float lum=min(luminance(texel.rgb),1.0);
#ifdef INVERTED
lum=1.0-lum;
#endif
float characterIndex=floor(CHAR_COUNT_MINUS_ONE*lum);vec2 characterPosition=vec2(mod(characterIndex,TEX_CELL_COUNT),floor(characterIndex*INV_TEX_CELL_COUNT));vec2 offset=vec2(characterPosition.x,-characterPosition.y)*INV_TEX_CELL_COUNT;vec2 characterUv=mod(uv*(cellCount.xy*INV_TEX_CELL_COUNT),INV_TEX_CELL_COUNT);characterUv=characterUv-vec2(0.0,INV_TEX_CELL_COUNT)+offset;float asciiCharacter=texture(asciiTexture,characterUv).r;
#ifdef USE_COLOR
return vec4(color*asciiCharacter,inputColor.a);
#else
return vec4(texel.rgb*asciiCharacter,inputColor.a);
#endif
}`;

// src/effects/ASCIIEffect.ts
var ASCIIEffect = class extends Effect {
  /**
   * @see {@link cellSize}
   */
  _cellSize;
  /**
   * Constructs a new ASCIIEffect.
   */
  constructor({
    asciiTexture = new ASCIITexture(),
    cellSize = 16,
    color: color2 = null,
    inverted = false
  } = {}) {
    super("ASCIIEffect");
    this.fragmentShader = ascii_default;
    const uniforms = this.input.uniforms;
    uniforms.set("asciiTexture", new Uniform5(null));
    uniforms.set("cellCount", new Uniform5(new Vector43()));
    uniforms.set("color", new Uniform5(new Color3()));
    this._cellSize = -1;
    this.asciiTexture = asciiTexture;
    this.cellSize = cellSize;
    this.color = color2;
    this.inverted = inverted;
  }
  get asciiTexture() {
    return this.input.uniforms.get("asciiTexture").value;
  }
  set asciiTexture(value) {
    const currentTexture = this.input.uniforms.get("asciiTexture").value;
    this.input.uniforms.get("asciiTexture").value = value;
    if (currentTexture !== null && currentTexture !== value) {
      currentTexture.dispose();
    }
    if (value !== null) {
      const cellCount = value.cellCount;
      this.input.defines.set("CHAR_COUNT_MINUS_ONE", (value.characterCount - 1).toFixed(1));
      this.input.defines.set("TEX_CELL_COUNT", cellCount.toFixed(1));
      this.input.defines.set("INV_TEX_CELL_COUNT", (1 / cellCount).toFixed(9));
      this.setChanged();
    }
  }
  get color() {
    return this.input.uniforms.get("color").value;
  }
  set color(value) {
    if (value !== null) {
      const color2 = this.input.uniforms.get("color").value;
      color2.set(value);
    }
    if (this.input.defines.has("USE_COLOR") && value === null) {
      this.input.defines.delete("USE_COLOR");
      this.setChanged();
    } else if (!this.input.defines.has("USE_COLOR") && value !== null) {
      this.input.defines.set("USE_COLOR", true);
      this.setChanged();
    }
  }
  get inverted() {
    return this.input.defines.has("INVERTED");
  }
  set inverted(value) {
    if (this.inverted !== value) {
      if (value) {
        this.input.defines.set("INVERTED", true);
      } else {
        this.input.defines.delete("INVERTED");
      }
      this.setChanged();
    }
  }
  get cellSize() {
    return this._cellSize;
  }
  set cellSize(value) {
    if (this._cellSize !== value) {
      this._cellSize = value;
      this.updateCellCount();
    }
  }
  /**
   * Updates the cell count uniform.
   */
  updateCellCount() {
    const cellCount = this.input.uniforms.get("cellCount").value;
    const resolution = this.resolution;
    cellCount.x = resolution.width / this.cellSize;
    cellCount.y = resolution.height / this.cellSize;
    cellCount.z = 1 / cellCount.x;
    cellCount.w = 1 / cellCount.y;
  }
  onResolutionChange() {
    this.updateCellCount();
  }
  dispose() {
    super.dispose();
    this.asciiTexture?.dispose();
  }
};

// src/effects/BloomEffect.ts
import { Uniform as Uniform8 } from "three";

// src/materials/LuminanceHighPassMaterial.ts
import { Uniform as Uniform6 } from "three";

// src/materials/shaders/luminance-high-pass.frag
var luminance_high_pass_default = `#include <common>
#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
uniform float threshold;uniform float smoothing;in vec2 vUv;void main(){vec4 texel=texture(inputBuffer,vUv);float l=luminance(texel.rgb);float mask=smoothstep(threshold,threshold+smoothing,l);out_Color=texel*mask;}`;

// src/materials/LuminanceHighPassMaterial.ts
var LuminanceHighPassMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new luminance high-pass material.
   */
  constructor() {
    super({
      name: "LuminanceHighPassMaterial",
      fragmentShader: luminance_high_pass_default,
      vertexShader: common_default,
      uniforms: {
        threshold: new Uniform6(0),
        smoothing: new Uniform6(0)
      }
    });
  }
  /**
   * The luminance threshold.
   */
  get threshold() {
    return this.uniforms.threshold.value;
  }
  set threshold(value) {
    this.uniforms.threshold.value = value;
  }
  /**
   * The luminance smoothing.
   */
  get smoothing() {
    return this.uniforms.smoothing.value;
  }
  set smoothing(value) {
    this.uniforms.smoothing.value = value;
  }
};

// src/passes/LuminancePass.ts
var LuminancePass = class _LuminancePass extends Pass {
  /**
   * Identifies the luminance output buffer.
   */
  static BUFFER_LUMINANCE = "BUFFER_LUMINANCE";
  /**
   * Constructs a new luminance pass.
   */
  constructor() {
    super("LuminancePass");
    this.output.setBuffer(_LuminancePass.BUFFER_LUMINANCE, this.createFramebuffer());
    this.fullscreenMaterial = new LuminanceHighPassMaterial();
  }
  /**
   * The luminance render target.
   */
  get renderTarget() {
    return this.output.getBuffer(_LuminancePass.BUFFER_LUMINANCE);
  }
  /**
   * The output texture.
   */
  get texture() {
    return this.output.buffers.get(_LuminancePass.BUFFER_LUMINANCE).texture;
  }
  onInputChange() {
    const inputTexture = this.input.defaultBuffer?.value ?? null;
    if (inputTexture === null) {
      return;
    }
    const texture = this.renderTarget.texture;
    texture.format = inputTexture.format;
    texture.internalFormat = inputTexture.internalFormat;
    texture.type = inputTexture.type;
    texture.colorSpace = inputTexture.colorSpace;
    texture.needsUpdate = true;
    if (this.input.frameBufferPrecisionHigh) {
      this.fullscreenMaterial.outputPrecision = "mediump";
    } else {
      this.fullscreenMaterial.outputPrecision = "lowp";
    }
  }
  onResolutionChange() {
    const resolution = this.resolution;
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
  render() {
    this.setRenderTarget(this.renderTarget);
    this.renderFullscreen();
  }
};

// src/materials/shaders/convolution.downsampling.frag
var convolution_downsampling_default = `#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
in vec2 vUv;in vec2 vUv00,vUv01,vUv02,vUv03;in vec2 vUv04,vUv05,vUv06,vUv07;in vec2 vUv08,vUv09,vUv10,vUv11;float clampToBorder(const in vec2 uv){
#ifdef CLAMP_TO_BORDER
return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);
#else
return 1.0;
#endif
}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture(inputBuffer,vUv00);c+=w.y*texture(inputBuffer,vUv01);c+=w.z*texture(inputBuffer,vUv02);c+=w.w*texture(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture(inputBuffer,vUv04);c+=w.y*texture(inputBuffer,vUv05);c+=w.z*texture(inputBuffer,vUv06);c+=w.w*texture(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture(inputBuffer,vUv08);c+=w.y*texture(inputBuffer,vUv09);c+=w.z*texture(inputBuffer,vUv10);c+=w.w*texture(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture(inputBuffer,vUv);out_Color=c;}`;

// src/materials/shaders/convolution.downsampling.vert
var convolution_downsampling_default2 = `#include <pp_resolution_pars_fragment>
out vec2 vUv;out vec2 vUv00,vUv01,vUv02,vUv03;out vec2 vUv04,vUv05,vUv06,vUv07;out vec2 vUv08,vUv09,vUv10,vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+resolution.zw*vec2(-1.0,1.0);vUv01=vUv+resolution.zw*vec2(1.0,1.0);vUv02=vUv+resolution.zw*vec2(-1.0,-1.0);vUv03=vUv+resolution.zw*vec2(1.0,-1.0);vUv04=vUv+resolution.zw*vec2(-2.0,2.0);vUv05=vUv+resolution.zw*vec2(0.0,2.0);vUv06=vUv+resolution.zw*vec2(2.0,2.0);vUv07=vUv+resolution.zw*vec2(-2.0,0.0);vUv08=vUv+resolution.zw*vec2(2.0,0.0);vUv09=vUv+resolution.zw*vec2(-2.0,-2.0);vUv10=vUv+resolution.zw*vec2(0.0,-2.0);vUv11=vUv+resolution.zw*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/DownsamplingMaterial.ts
var DownsamplingMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new downsampling material.
   */
  constructor({ clampToBorder = true } = {}) {
    super({
      name: "DownsamplingMaterial",
      fragmentShader: convolution_downsampling_default,
      vertexShader: convolution_downsampling_default2,
      defines: {
        CLAMP_TO_BORDER: true
      }
    });
    this.clampToBorder = clampToBorder;
  }
  get clampToBorder() {
    return this.defines.CLAMP_TO_BORDER !== void 0;
  }
  set clampToBorder(value) {
    if (this.clampToBorder === value) {
      return;
    }
    if (value) {
      this.defines.CLAMP_TO_BORDER = true;
    } else {
      delete this.defines.CLAMP_TO_BORDER;
    }
    this.needsUpdate = true;
  }
};

// src/materials/UpsamplingMaterial.ts
import { Uniform as Uniform7, Vector2 as Vector25 } from "three";

// src/materials/shaders/convolution.upsampling.frag
var convolution_upsampling_default = `#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#ifdef USE_SUPPORT_BUFFER
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;
#endif
in vec2 vUv;in vec2 vUv0,vUv1,vUv2,vUv3;in vec2 vUv4,vUv5,vUv6,vUv7;void main(){vec4 c=vec4(0.0);c+=texture(inputBuffer,vUv0)*0.0625;c+=texture(inputBuffer,vUv1)*0.125;c+=texture(inputBuffer,vUv2)*0.0625;c+=texture(inputBuffer,vUv3)*0.125;c+=texture(inputBuffer,vUv)*0.25;c+=texture(inputBuffer,vUv4)*0.125;c+=texture(inputBuffer,vUv5)*0.0625;c+=texture(inputBuffer,vUv6)*0.125;c+=texture(inputBuffer,vUv7)*0.0625;
#ifdef USE_SUPPORT_BUFFER
vec4 baseColor=texture(supportBuffer,vUv);out_Color=mix(baseColor,c,radius);
#else
out_Color=c;
#endif
}`;

// src/materials/shaders/convolution.upsampling.vert
var convolution_upsampling_default2 = `#include <pp_resolution_pars_fragment>
out vec2 vUv;out vec2 vUv0,vUv1,vUv2,vUv3;out vec2 vUv4,vUv5,vUv6,vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+resolution.zw*vec2(-1.0,1.0);vUv1=vUv+resolution.zw*vec2(0.0,1.0);vUv2=vUv+resolution.zw*vec2(1.0,1.0);vUv3=vUv+resolution.zw*vec2(-1.0,0.0);vUv4=vUv+resolution.zw*vec2(1.0,0.0);vUv5=vUv+resolution.zw*vec2(-1.0,-1.0);vUv6=vUv+resolution.zw*vec2(0.0,-1.0);vUv7=vUv+resolution.zw*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/UpsamplingMaterial.ts
var UpsamplingMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new upsampling material.
   */
  constructor({ radius = 0.85 } = {}) {
    super({
      name: "UpsamplingMaterial",
      fragmentShader: convolution_upsampling_default,
      vertexShader: convolution_upsampling_default2,
      defines: {
        USE_SUPPORT_BUFFER: true
      },
      uniforms: {
        supportBuffer: new Uniform7(null),
        texelSize: new Uniform7(new Vector25()),
        radius: new Uniform7(0)
      }
    });
    this.radius = radius;
  }
  /**
   * A support buffer.
   *
   * Assumed to use the same texture type as the main input buffer.
   */
  set supportBuffer(value) {
    this.uniforms.supportBuffer.value = value;
  }
  get radius() {
    return this.uniforms.radius.value;
  }
  set radius(value) {
    this.uniforms.radius.value = value;
    const b0 = this.defines.USE_SUPPORT_BUFFER !== void 0;
    const b1 = value < 1;
    if (b0 === b1) {
      return;
    }
    if (b1) {
      this.defines.USE_SUPPORT_BUFFER = true;
    } else {
      delete this.defines.USE_SUPPORT_BUFFER;
    }
    this.needsUpdate = true;
  }
};

// src/passes/MipmapBlurPass.ts
var MipmapBlurPass = class _MipmapBlurPass extends Pass {
  /**
   * Identifies the main output buffer.
   */
  static BUFFER_MAIN = "BUFFER_MAIN";
  /**
   * The mipmaps used for downsampling.
   */
  downsamplingMipmaps;
  /**
   * The mipmaps used for upsampling.
   */
  upsamplingMipmaps;
  /**
   * A downsampling material.
   */
  downsamplingMaterial;
  /**
   * An upsampling material.
  */
  upsamplingMaterial;
  /**
   * @see {@link fullResolutionUpsampling}
  */
  _fullResolutionUpsampling;
  /**
   * Constructs a new mipmap blur pass.
   *
   * @param options - The options.
   */
  constructor({ levels = 8, radius, fullResolutionUpsampling = false, clampToBorder } = {}) {
    super("MipmapBlurPass");
    const renderTarget = this.createFramebuffer();
    renderTarget.texture.name = _MipmapBlurPass.BUFFER_MAIN;
    this.output.setBuffer(_MipmapBlurPass.BUFFER_MAIN, renderTarget);
    this.downsamplingMipmaps = [];
    this.upsamplingMipmaps = [];
    this.downsamplingMaterial = new DownsamplingMaterial({ clampToBorder });
    this.upsamplingMaterial = new UpsamplingMaterial({ radius });
    this.materials.add(this.downsamplingMaterial);
    this.materials.add(this.upsamplingMaterial);
    this._fullResolutionUpsampling = fullResolutionUpsampling;
    this.levels = levels;
  }
  /**
   * The output texture.
   */
  get texture() {
    return this.output.buffers.get(_MipmapBlurPass.BUFFER_MAIN).texture;
  }
  get clampToBorder() {
    return this.downsamplingMaterial.clampToBorder;
  }
  set clampToBorder(value) {
    this.downsamplingMaterial.clampToBorder = value;
  }
  get radius() {
    return this.upsamplingMaterial.radius;
  }
  set radius(value) {
    this.upsamplingMaterial.radius = value;
  }
  get levels() {
    return this.downsamplingMipmaps.length;
  }
  set levels(value) {
    if (value <= 0) {
      throw new Error("The level count must be greater than 0");
    }
    if (this.levels !== value) {
      this.createMipmaps(value);
    }
  }
  get fullResolutionUpsampling() {
    return this._fullResolutionUpsampling;
  }
  set fullResolutionUpsampling(value) {
    if (this._fullResolutionUpsampling !== value) {
      this._fullResolutionUpsampling = value;
      this.createMipmaps(this.levels);
    }
  }
  /**
   * Updates the mipmap render targets.
   *
   * @param levels - The mipmap level count.
   */
  createMipmaps(levels) {
    const output = this.output;
    const mainBufferResource = output.buffers.get(_MipmapBlurPass.BUFFER_MAIN);
    const renderTarget = mainBufferResource.value;
    this.dispose();
    this.disposables.clear();
    output.buffers.clear();
    this.downsamplingMipmaps = [];
    this.upsamplingMipmaps = [];
    if (levels === 1 && !this.fullResolutionUpsampling) {
      output.setBuffer(_MipmapBlurPass.BUFFER_MAIN, mainBufferResource);
      this.downsamplingMipmaps.push(mainBufferResource);
      return;
    }
    for (let i = 0; i < levels; ++i) {
      const mipmap = renderTarget.clone();
      mipmap.texture.name = "DOWNSAMPLING_MIPMAP" + i;
      const mipmapResource = new RenderTargetResource(mipmap);
      output.setBuffer(mipmap.texture.name, mipmapResource);
      this.downsamplingMipmaps.push(mipmapResource);
    }
    output.setBuffer(_MipmapBlurPass.BUFFER_MAIN, mainBufferResource);
    this.upsamplingMipmaps.push(mainBufferResource);
    for (let i = 1, l = this.fullResolutionUpsampling ? levels : levels - 1; i < l; ++i) {
      const mipmap = renderTarget.clone();
      mipmap.texture.name = "UPSAMPLING_MIPMAP" + i;
      const mipmapResource = new RenderTargetResource(mipmap);
      output.setBuffer(mipmap.texture.name, mipmapResource);
      this.upsamplingMipmaps.push(mipmapResource);
    }
    this.onResolutionChange();
  }
  onInputChange() {
    const inputTexture = this.input.defaultBuffer?.value ?? null;
    if (inputTexture === null) {
      return;
    }
    const { format, internalFormat, type, colorSpace } = inputTexture;
    for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) {
      const renderTarget = mipmap.value;
      const texture = renderTarget.texture;
      texture.format = format;
      texture.internalFormat = internalFormat;
      texture.type = type;
      texture.colorSpace = colorSpace;
      renderTarget.dispose();
    }
    if (this.input.frameBufferPrecisionHigh) {
      this.downsamplingMaterial.outputPrecision = "mediump";
      this.upsamplingMaterial.outputPrecision = "mediump";
    } else {
      this.downsamplingMaterial.outputPrecision = "lowp";
      this.upsamplingMaterial.outputPrecision = "lowp";
    }
    this.onResolutionChange();
  }
  onResolutionChange() {
    const inputBuffer = this.input.defaultBuffer?.value ?? null;
    if (inputBuffer === null) {
      return;
    }
    const imgData = inputBuffer.source.data;
    let { width, height } = imgData;
    for (let i = 0, l = this.downsamplingMipmaps.length; i < l; ++i) {
      width = Math.round(width / 2);
      height = Math.round(height / 2);
      this.downsamplingMipmaps[i].value?.setSize(width, height);
    }
    if (this.fullResolutionUpsampling) {
      width = imgData.width;
      height = imgData.height;
    } else {
      width = Math.round(imgData.width / 2);
      height = Math.round(imgData.height / 2);
    }
    for (let i = 0, l = this.upsamplingMipmaps.length; i < l; ++i) {
      this.upsamplingMipmaps[i].value?.setSize(width, height);
      width = Math.round(width / 2);
      height = Math.round(height / 2);
    }
  }
  render() {
    if (this.renderer === null || this.input.defaultBuffer === null || this.input.defaultBuffer.value === null) {
      return;
    }
    const renderer = this.renderer;
    const downsamplingMaterial = this.downsamplingMaterial;
    const upsamplingMaterial = this.upsamplingMaterial;
    const downsamplingMipmaps = this.downsamplingMipmaps;
    const upsamplingMipmaps = this.upsamplingMipmaps;
    let previousBuffer = this.input.defaultBuffer.value;
    const imgData = previousBuffer.source.data;
    let { width, height } = imgData;
    this.fullscreenMaterial = downsamplingMaterial;
    for (let i = 0, l = downsamplingMipmaps.length; i < l; ++i) {
      const mipmap = downsamplingMipmaps[i].value;
      downsamplingMaterial.setSize(width, height);
      downsamplingMaterial.inputBuffer = previousBuffer;
      renderer.setRenderTarget(mipmap);
      this.renderFullscreen();
      previousBuffer = mipmap.texture;
      width = mipmap.width;
      height = mipmap.height;
    }
    this.fullscreenMaterial = upsamplingMaterial;
    for (let i = upsamplingMipmaps.length - 1; i >= 0; --i) {
      const j = this.fullResolutionUpsampling ? i - 1 : i;
      const supportBuffer = j >= 0 ? downsamplingMipmaps[j].value.texture : this.input.defaultBuffer.value;
      const mipmap = upsamplingMipmaps[i].value;
      upsamplingMaterial.setSize(width, height);
      upsamplingMaterial.inputBuffer = previousBuffer;
      upsamplingMaterial.supportBuffer = supportBuffer;
      renderer.setRenderTarget(mipmap);
      this.renderFullscreen();
      previousBuffer = mipmap.texture;
      width = mipmap.width;
      height = mipmap.height;
    }
  }
};

// src/effects/shaders/bloom.frag
var bloom_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){vec4 texel=texture(map,uv);return vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`;

// src/effects/BloomEffect.ts
var BloomEffect = class extends Effect {
  /**
   * A luminance pass.
   */
  luminancePass;
  /**
   * A mipmap blur pass.
   */
  mipmapBlurPass;
  /**
   * Constructs a new bloom effect.
   *
   * @param options - The options.
   */
  constructor({
    luminanceThreshold = 1,
    luminanceSmoothing = 0.03,
    intensity = 1,
    radius = 0.85,
    levels = 8,
    fullResolutionUpsampling,
    clampToBorder
  } = {}) {
    super("BloomEffect");
    this.fragmentShader = bloom_default;
    this.blendMode.blendFunction = new AddBlendFunction();
    const luminancePass = new LuminancePass();
    luminancePass.addEventListener("toggle", () => this.onInputChange());
    this.luminancePass = luminancePass;
    const luminanceMaterial = this.luminanceMaterial;
    luminanceMaterial.threshold = luminanceThreshold;
    luminanceMaterial.smoothing = luminanceSmoothing;
    const mipmapBlurPass = new MipmapBlurPass({ levels, radius, fullResolutionUpsampling, clampToBorder });
    this.mipmapBlurPass = mipmapBlurPass;
    const uniforms = this.input.uniforms;
    uniforms.set("intensity", new Uniform8(intensity));
    uniforms.set("map", new Uniform8(null));
    mipmapBlurPass.texture.bindUniform(uniforms.get("map"));
    this.subpasses = [luminancePass, mipmapBlurPass];
  }
  /**
   * The luminance high-pass material.
   */
  get luminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  get luminanceThreshold() {
    return this.luminanceMaterial.threshold;
  }
  set luminanceThreshold(value) {
    this.luminanceMaterial.threshold = value;
  }
  get luminanceSmoothing() {
    return this.luminanceMaterial.smoothing;
  }
  set luminanceSmoothing(value) {
    this.luminanceMaterial.smoothing = value;
  }
  get intensity() {
    return this.input.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.input.uniforms.get("intensity").value = value;
  }
  onInputChange() {
    if (this.input.defaultBuffer === null) {
      this.luminancePass.input.removeDefaultBuffer();
      this.mipmapBlurPass.input.removeDefaultBuffer();
      return;
    }
    if (this.luminancePass.enabled) {
      this.luminancePass.input.defaultBuffer = this.input.defaultBuffer;
      this.mipmapBlurPass.input.defaultBuffer = this.luminancePass.texture;
    } else {
      this.mipmapBlurPass.input.defaultBuffer = this.input.defaultBuffer;
    }
  }
  render() {
    if (this.luminancePass.enabled) {
      this.luminancePass.render();
    }
    this.mipmapBlurPass.render();
  }
};

// src/effects/ColorDepthEffect.ts
import { Uniform as Uniform9, Vector3 as Vector32 } from "three";

// src/effects/shaders/color-depth.frag
var color_depth_default = `uniform vec3 colorRanges;vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){return vec4(floor(inputColor.rgb*colorRanges)/colorRanges,inputColor.a);}`;

// src/effects/ColorDepthEffect.ts
var ColorDepthEffect = class extends Effect {
  /**
   * The current color bit depths.
   */
  bits;
  /**
   * Constructs a new color depth effect.
   *
   * @param options - The options.
   */
  constructor({ r = 16, g = 16, b = 16 } = {}) {
    super("ColorDepthEffect");
    this.fragmentShader = color_depth_default;
    const uniforms = this.input.uniforms;
    uniforms.set("colorRanges", new Uniform9(new Vector32()));
    this.bits = new Vector32(r, g, b);
    this.updateFactors();
  }
  /**
   * Updates the color ranges.
   */
  updateFactors() {
    const colorRanges = this.input.uniforms.get("colorRanges").value;
    const bits = this.bits;
    colorRanges.set(
      Math.pow(2, bits.x),
      Math.pow(2, bits.y),
      Math.pow(2, bits.z)
    );
  }
  get r() {
    return this.bits.x;
  }
  set r(value) {
    this.bits.x = value;
    this.updateFactors();
  }
  get g() {
    return this.bits.y;
  }
  set g(value) {
    this.bits.y = value;
    this.updateFactors();
  }
  get b() {
    return this.bits.z;
  }
  set b(value) {
    this.bits.z = value;
    this.updateFactors();
  }
};

// src/effects/shaders/fxaa.frag
var fxaa_default = `#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))
#define ONE_OVER_TWELVE 0.08333333333333333
in vec2 vUvDown;in vec2 vUvUp;in vec2 vUvLeft;in vec2 vUvRight;in vec2 vUvDownLeft;in vec2 vUvUpRight;in vec2 vUvUpLeft;in vec2 vUvDownRight;vec4 fxaa(sampler2D inputBuffer,const in vec4 inputColor,const in vec2 uv,const in float lumaCenter){float lumaDown=luminance(texture(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?resolution.w:resolution.z;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(resolution.z,0.0):vec2(0.0,resolution.w);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture(inputBuffer,finalUv);}vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){return fxaa(gBuffer.color,inputColor,uv,gData.luminance);}`;

// src/effects/shaders/fxaa.vert
var fxaa_default2 = `out vec2 vUvDown;out vec2 vUvUp;out vec2 vUvLeft;out vec2 vUvRight;out vec2 vUvDownLeft;out vec2 vUvUpRight;out vec2 vUvUpLeft;out vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*resolution.zw;vUvUp=uv+vec2(0.0,1.0)*resolution.zw;vUvRight=uv+vec2(1.0,0.0)*resolution.zw;vUvLeft=uv+vec2(-1.0,0.0)*resolution.zw;vUvDownLeft=uv+vec2(-1.0,-1.0)*resolution.zw;vUvUpRight=uv+vec2(1.0,1.0)*resolution.zw;vUvUpLeft=uv+vec2(-1.0,1.0)*resolution.zw;vUvDownRight=uv+vec2(1.0,-1.0)*resolution.zw;}`;

// src/effects/FXAAEffect.ts
var FXAAEffect = class extends Effect {
  /**
   * Constructs a new FXAA effect.
   *
   * @param options - The options.
   */
  constructor({
    minEdgeThreshold = 0.0312,
    maxEdgeThreshold = 0.125,
    subpixelQuality = 0.75,
    samples = 12
  } = {}) {
    super("FXAAEffect");
    this.fragmentShader = fxaa_default;
    this.vertexShader = fxaa_default2;
    this.minEdgeThreshold = minEdgeThreshold;
    this.maxEdgeThreshold = maxEdgeThreshold;
    this.subpixelQuality = subpixelQuality;
    this.samples = samples;
  }
  get minEdgeThreshold() {
    return Number(this.input.defines.get("EDGE_THRESHOLD_MIN"));
  }
  set minEdgeThreshold(value) {
    this.input.defines.set("EDGE_THRESHOLD_MIN", value.toFixed(9));
    this.setChanged();
  }
  get maxEdgeThreshold() {
    return Number(this.input.defines.get("EDGE_THRESHOLD_MAX"));
  }
  set maxEdgeThreshold(value) {
    this.input.defines.set("EDGE_THRESHOLD_MAX", value.toFixed(9));
    this.setChanged();
  }
  get subpixelQuality() {
    return Number(this.input.defines.get("SUBPIXEL_QUALITY"));
  }
  set subpixelQuality(value) {
    this.input.defines.set("SUBPIXEL_QUALITY", value.toFixed(9));
    this.setChanged();
  }
  get samples() {
    return this.input.defines.get("SAMPLES");
  }
  set samples(value) {
    this.input.defines.set("SAMPLES", value);
    this.setChanged();
  }
};

// src/effects/HalftoneEffect.ts
import { Uniform as Uniform10, Vector3 as Vector33 } from "three";

// src/effects/shaders/halftone.frag
var halftone_default = `#define SQRT2_MINUS_ONE 0.41421356
#define SQRT2_HALF_MINUS_ONE 0.20710678
#define SHAPE_DOT 1
#define SHAPE_ELLIPSE 2
#define SHAPE_LINE 3
#define SHAPE_SQUARE 4
uniform vec3 rotationRGB;uniform float radius;uniform float scatterFactor;struct Cell{vec2 n;vec2 p1;vec2 p2;vec2 p3;vec2 p4;float sample1;float sample2;float sample3;float sample4;};float getPattern(float cellSample,vec2 coord,vec2 n,vec2 p,float angle){float maxRadius=radius;float magnitude=length(coord-p);float r=cellSample;
#if SHAPE == SHAPE_DOT
r=pow(abs(r),1.125)*maxRadius;
#elif SHAPE == SHAPE_ELLIPSE
r=pow(abs(r),1.125)*maxRadius;if(magnitude!=0.0){float dotP=abs(dot((p-coord)/magnitude,n));magnitude=dot(vec2(magnitude,magnitude*dotP),vec2(1.0-SQRT2_HALF_MINUS_ONE,SQRT2_MINUS_ONE));}
#elif SHAPE == SHAPE_LINE
r=pow(abs(r),1.5)*maxRadius;float dotP=dot(p-coord,n);magnitude=length(n*dotP);
#elif SHAPE == SHAPE_SQUARE
float theta=atan(p.y-coord.y,p.x-coord.x)-angle;float sinT=abs(sin(theta));float cosT=abs(cos(theta));r=pow(abs(r),1.4);r+=(sinT>cosT)?r-sinT*r:r-cosT*r;r*=maxRadius;
#endif
return r-magnitude;}vec4 getSample(vec2 p){vec2 uv=p*resolution.zw;vec4 texel=texture(gBuffer.color,uv);float base=rand(floor(p))*PI2;float step=PI2*INV_SAMPLES;vec2 magnitude=radius*0.666667*resolution.zw;for(int i=0;i<SAMPLES;++i){float angle=base+step*float(i);vec2 offset=vec2(cos(angle),sin(angle))*magnitude;texel+=texture(gBuffer.color,uv+offset);}texel*=INV_SAMPLES_PLUS_ONE;return texel;}Cell getReferenceCell(vec2 p,vec2 origin,float angle){Cell cell;float step=radius;vec2 n=vec2(cos(angle),sin(angle));vec2 v=p-origin;float dotNormal=dot(v,n);float dotLine=dot(v,vec2(-n.y,n.x));float threshold=step*0.5;vec2 offset=n*dotNormal;float offsetNormal=mod(length(offset),step);float normalDir=(dotNormal<0.0)?1.0:-1.0;float normalScale=(offsetNormal<threshold)?-offsetNormal:step-offsetNormal;normalScale*=normalDir;float offsetLine=mod(length(v-offset),step);float lineDir=(dotLine<0.0)?1.0:-1.0;float lineScale=(offsetLine<threshold)?-offsetLine:step-offsetLine;lineScale*=lineDir;cell.n=n;cell.p1=p-n*normalScale+vec2(n.y,-n.x)*lineScale;if(scatterFactor!=0.0){float offMagnitude=scatterFactor*threshold*0.5;float offAngle=rand(floor(cell.p1))*PI2;cell.p1+=vec2(cos(offAngle),sin(offAngle))*offMagnitude;}float normalStep=normalDir*((offsetNormal<threshold)?step:-step);float lineStep=lineDir*((offsetLine<threshold)?step:-step);vec2 lineOffset=vec2(n.y,-n.x)*lineStep;cell.p2=cell.p1-n*normalStep;cell.p3=cell.p1+lineOffset;cell.p4=cell.p2+lineOffset;return cell;}float halftone(Cell cell,vec2 p,float angle,float aa){float distC1=getPattern(cell.sample1,cell.p1,cell.n,p,angle);float distC2=getPattern(cell.sample2,cell.p2,cell.n,p,angle);float distC3=getPattern(cell.sample3,cell.p3,cell.n,p,angle);float distC4=getPattern(cell.sample4,cell.p4,cell.n,p,angle);float result=clamp(distC1*aa,0.0,1.0);result+=clamp(distC2*aa,0.0,1.0);result+=clamp(distC3*aa,0.0,1.0);result+=clamp(distC4*aa,0.0,1.0);result=clamp(result,0.0,1.0);return result;}vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){vec2 p=uv*resolution.xy;vec2 origin=vec2(0.0);
#ifdef RGB_ROTATION
Cell cellR=getReferenceCell(p,origin,rotationRGB.r);Cell cellG=getReferenceCell(p,origin,rotationRGB.g);Cell cellB=getReferenceCell(p,origin,rotationRGB.b);cellR.sample1=getSample(cellR.p1).r;cellR.sample2=getSample(cellR.p2).r;cellR.sample3=getSample(cellR.p3).r;cellR.sample4=getSample(cellR.p4).r;cellG.sample1=getSample(cellG.p1).g;cellG.sample2=getSample(cellG.p2).g;cellG.sample3=getSample(cellG.p3).g;cellG.sample4=getSample(cellG.p4).g;cellB.sample1=getSample(cellB.p1).b;cellB.sample2=getSample(cellB.p2).b;cellB.sample3=getSample(cellB.p3).b;cellB.sample4=getSample(cellB.p4).b;
#else
Cell cell=getReferenceCell(p,origin,rotationRGB.r);Cell cellR=cell;Cell cellG=cell;Cell cellB=cell;vec3 sample1=getSample(cell.p1).rgb;vec3 sample2=getSample(cell.p2).rgb;vec3 sample3=getSample(cell.p3).rgb;vec3 sample4=getSample(cell.p4).rgb;cellR.sample1=sample1.r;cellR.sample2=sample2.r;cellR.sample3=sample3.r;cellR.sample4=sample4.r;cellG.sample1=sample1.g;cellG.sample2=sample2.g;cellG.sample3=sample3.g;cellG.sample4=sample4.g;cellB.sample1=sample1.b;cellB.sample2=sample2.b;cellB.sample3=sample3.b;cellB.sample4=sample4.b;
#endif
float aa=2.0/min(radius,2.5);vec3 pattern=vec3(halftone(cellR,p,rotationRGB.r,aa),halftone(cellG,p,rotationRGB.g,aa),halftone(cellB,p,rotationRGB.b,aa));return vec4(pattern,inputColor.a);}`;

// src/effects/HalftoneEffect.ts
var HalftoneEffect = class extends Effect {
  /**
   * @see {@link radius}
   */
  _radius;
  /**
   * Constructs a new halftone effect.
   *
   * @param options - The options.
   */
  constructor({
    shape = 1 /* DOT */,
    radius = 6,
    rotation = 0,
    rotationR = rotation,
    rotationG = rotationR,
    rotationB = rotationG,
    scatterFactor = 0,
    samples = 8
  } = {}) {
    super("HalftoneEffect");
    this.fragmentShader = halftone_default;
    this.blendMode.blendFunction = new LinearDodgeBlendFunction();
    const uniforms = this.input.uniforms;
    uniforms.set("radius", new Uniform10(1));
    uniforms.set("rotationRGB", new Uniform10(new Vector33(rotationR, rotationG, rotationB)));
    uniforms.set("scatterFactor", new Uniform10(scatterFactor));
    this._radius = radius;
    this.shape = shape;
    this.samples = samples;
    this.updateRGBRotation();
  }
  get shape() {
    return this.input.defines.get("SHAPE");
  }
  set shape(value) {
    this.input.defines.set("SHAPE", value);
    this.setChanged();
  }
  get samples() {
    return this.input.defines.get("SAMPLES");
  }
  set samples(value) {
    value = Math.max(value, 1);
    this.input.defines.set("SAMPLES", value);
    this.input.defines.set("INV_SAMPLES", (1 / value).toFixed(9));
    this.input.defines.set("INV_SAMPLES_PLUS_ONE", (1 / (value + 1)).toFixed(9));
    this.setChanged();
  }
  get radius() {
    return this._radius;
  }
  set radius(value) {
    this._radius = value;
    this.onResolutionChange();
  }
  get scatterFactor() {
    return this.input.uniforms.get("scatterFactor").value;
  }
  set scatterFactor(value) {
    this.input.uniforms.get("scatterFactor").value = value;
  }
  set rotation(value) {
    const rotationRGB = this.input.uniforms.get("rotationRGB").value;
    rotationRGB.setScalar(value);
    this.updateRGBRotation();
  }
  get rotationR() {
    const rotationRGB = this.input.uniforms.get("rotationRGB").value;
    return rotationRGB.x;
  }
  set rotationR(value) {
    const rotationRGB = this.input.uniforms.get("rotationRGB").value;
    rotationRGB.x = value;
    this.updateRGBRotation();
  }
  get rotationG() {
    const rotationRGB = this.input.uniforms.get("rotationRGB").value;
    return rotationRGB.y;
  }
  set rotationG(value) {
    const rotationRGB = this.input.uniforms.get("rotationRGB").value;
    rotationRGB.y = value;
    this.updateRGBRotation();
  }
  get rotationB() {
    const rotationRGB = this.input.uniforms.get("rotationRGB").value;
    return rotationRGB.z;
  }
  set rotationB(value) {
    const rotationRGB = this.input.uniforms.get("rotationRGB").value;
    rotationRGB.z = value;
    this.updateRGBRotation();
  }
  /**
   * Enables or disables RGB rotation based on the current rotation settings.
   */
  updateRGBRotation() {
    const currentlyEnabled = this.input.defines.has("RGB_ROTATION");
    const shouldBeEnabled = this.rotationR !== this.rotationG || this.rotationR !== this.rotationB || this.rotationG !== this.rotationB;
    if (shouldBeEnabled) {
      this.input.defines.set("RGB_ROTATION", true);
    } else {
      this.input.defines.delete("RGB_ROTATION");
    }
    if (currentlyEnabled !== shouldBeEnabled) {
      this.setChanged();
    }
  }
  onResolutionChange() {
    const r = this.radius * this.resolution.scaledPixelRatio;
    this.input.uniforms.get("radius").value = Math.max(r, 1e-9);
  }
};

// src/effects/LensDistortionEffect.ts
import { Uniform as Uniform11, Vector2 as Vector26 } from "three";

// src/effects/shaders/lens-distortion.frag
var lens_distortion_default = `uniform vec2 distortion;uniform vec2 principalPoint;uniform vec2 focalLength;uniform float skew;float mask(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void mainUv(inout vec2 uv){vec2 xn=2.0*(uv.st-0.5);vec3 xDistorted=vec3((1.0+distortion*dot(xn,xn))*xn,1.0);mat3 kk=mat3(vec3(focalLength.x,0.0,0.0),vec3(skew*focalLength.x,focalLength.y,0.0),vec3(principalPoint.x,principalPoint.y,1.0));uv=(kk*xDistorted).xy*0.5+0.5;}vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){return mask(uv)*inputColor;}`;

// src/effects/LensDistortionEffect.ts
var LensDistortionEffect = class extends Effect {
  /**
   * Constructs a new lens distortion effect.
   *
   * @param options - The options.
   */
  constructor({
    distortion = new Vector26(0, 0),
    principalPoint = new Vector26(0, 0),
    focalLength = new Vector26(1, 1),
    skew = 0
  } = {}) {
    super("LensDistortionEffect");
    this.fragmentShader = lens_distortion_default;
    const uniforms = this.input.uniforms;
    uniforms.set("distortion", new Uniform11(distortion));
    uniforms.set("principalPoint", new Uniform11(principalPoint));
    uniforms.set("focalLength", new Uniform11(focalLength));
    uniforms.set("skew", new Uniform11(skew));
  }
  get distortion() {
    return this.input.uniforms.get("distortion").value;
  }
  set distortion(value) {
    this.input.uniforms.get("distortion").value = value;
  }
  get principalPoint() {
    return this.input.uniforms.get("principalPoint").value;
  }
  set principalPoint(value) {
    this.input.uniforms.get("principalPoint").value = value;
  }
  get focalLength() {
    return this.input.uniforms.get("focalLength").value;
  }
  set focalLength(value) {
    this.input.uniforms.get("focalLength").value = value;
  }
  get skew() {
    return this.input.uniforms.get("skew").value;
  }
  set skew(value) {
    this.input.uniforms.get("skew").value = value;
  }
};

// src/effects/LUT1DEffect.ts
import { FloatType as FloatType3, HalfFloatType as HalfFloatType3, Uniform as Uniform12 } from "three";

// src/effects/shaders/lut-1d.frag
var lut_1d_default = `#ifdef LUT_PRECISION_HIGH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D lut;
#else
uniform mediump sampler2D lut;
#endif
#else
uniform lowp sampler2D lut;
#endif
vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){return vec4(texture(lut,vec2(inputColor.r,0.5)).r,texture(lut,vec2(inputColor.g,0.5)).r,texture(lut,vec2(inputColor.b,0.5)).r,inputColor.a);}`;

// src/effects/LUT1DEffect.ts
var LUT1DEffect = class extends Effect {
  /**
   * Constructs a new LUT effect.
   *
   * @param options - The options.
   */
  constructor({ lut = null } = {}) {
    super("LUT1DEffect");
    this.fragmentShader = lut_1d_default;
    this.input.uniforms.set("lut", new Uniform12(null));
    this.lut = lut;
  }
  /**
   * Indicates whether the LUT uses high precision.
   */
  get lutPrecisionHigh() {
    return this.input.defines.has("LUT_PRECISION_HIGH");
  }
  set lutPrecisionHigh(value) {
    if (this.lutPrecisionHigh !== value) {
      if (value) {
        this.input.defines.set("LUT_PRECISION_HIGH", true);
      } else {
        this.input.defines.delete("LUT_PRECISION_HIGH");
      }
      this.setChanged();
    }
  }
  get lut() {
    return this.input.uniforms.get("lut").value;
  }
  set lut(value) {
    this.input.uniforms.get("lut").value = value;
    this.lutPrecisionHigh = value?.type === FloatType3 || value?.type === HalfFloatType3;
  }
};

// src/effects/LUT3DEffect.ts
import {
  FloatType as FloatType4,
  HalfFloatType as HalfFloatType4,
  LinearFilter as LinearFilter2,
  NearestFilter as NearestFilter2,
  SRGBColorSpace as SRGBColorSpace3,
  Uniform as Uniform13,
  Vector3 as Vector34
} from "three";

// src/effects/shaders/lut-3d.frag
var lut_3d_default = `uniform vec3 scale;uniform vec3 offset;
#ifdef CUSTOM_INPUT_DOMAIN
uniform vec3 domainMin;uniform vec3 domainMax;
#endif
#ifdef LUT_PRECISION_HIGH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler3D lut;
#else
uniform mediump sampler3D lut;
#endif
#else
uniform lowp sampler3D lut;
#endif
vec4 applyLUT(in vec3 rgb){rgb=scale*rgb+offset;
#ifdef TETRAHEDRAL_INTERPOLATION
vec3 p=floor(rgb);vec3 f=rgb-p;vec3 v1=(p+0.5)*LUT_TEXEL_WIDTH;vec3 v4=(p+1.5)*LUT_TEXEL_WIDTH;vec3 v2,v3;vec3 frac;if(f.r>=f.g){if(f.g>f.b){frac=f.rgb;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else if(f.r>=f.b){frac=f.rbg;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v1.y,v4.z);}else{frac=f.brg;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v4.x,v1.y,v4.z);}}else{if(f.b>f.g){frac=f.bgr;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v1.x,v4.y,v4.z);}else if(f.r>=f.b){frac=f.grb;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else{frac=f.gbr;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v1.x,v4.y,v4.z);}}vec4 n1=texture(lut,v1);vec4 n2=texture(lut,v2);vec4 n3=texture(lut,v3);vec4 n4=texture(lut,v4);vec4 weights=vec4(1.0-frac.x,frac.x-frac.y,frac.y-frac.z,frac.z);vec4 result=weights*mat4(vec4(n1.r,n2.r,n3.r,n4.r),vec4(n1.g,n2.g,n3.g,n4.g),vec4(n1.b,n2.b,n3.b,n4.b),vec4(1.0));return vec4(result.rgb,1.0);
#else
return texture(lut,rgb);
#endif
}vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){vec3 c=inputColor.rgb;
#ifdef CUSTOM_INPUT_DOMAIN
if(c.r>=domainMin.r&&c.g>=domainMin.g&&c.b>=domainMin.b&&c.r<=domainMax.r&&c.g<=domainMax.g&&c.b<=domainMax.b){c=applyLUT(c).rgb;}else{c=inputColor.rgb;}
#else
#ifdef TETRAHEDRAL_INTERPOLATION
c=clamp(c,0.0,1.0);
#endif
c=applyLUT(c).rgb;
#endif
return vec4(c,inputColor.a);}`;

// src/effects/LUT3DEffect.ts
var LUT3DEffect = class extends Effect {
  /**
   * Constructs a new LUT effect.
   *
   * @param options - The options.
   */
  constructor({
    lut = null,
    tetrahedralInterpolation = false,
    inputColorSpace = SRGBColorSpace3
  } = {}) {
    super("LUT3DEffect");
    this.fragmentShader = lut_3d_default;
    const uniforms = this.input.uniforms;
    uniforms.set("lut", new Uniform13(null));
    uniforms.set("scale", new Uniform13(new Vector34()));
    uniforms.set("offset", new Uniform13(new Vector34()));
    uniforms.set("domainMin", new Uniform13(null));
    uniforms.set("domainMax", new Uniform13(null));
    const defines = this.input.defines;
    defines.set("LUT_SIZE", "0");
    defines.set("LUT_TEXEL_WIDTH", "0");
    defines.set("LUT_TEXEL_HEIGHT", "0");
    this.tetrahedralInterpolation = tetrahedralInterpolation;
    this.inputColorSpace = inputColorSpace;
    this.lut = lut;
  }
  /**
   * Indicates whether the LUT uses high precision.
   */
  get lutPrecisionHigh() {
    return this.input.defines.has("LUT_PRECISION_HIGH");
  }
  set lutPrecisionHigh(value) {
    if (this.lutPrecisionHigh !== value) {
      if (value) {
        this.input.defines.set("LUT_PRECISION_HIGH", true);
      } else {
        this.input.defines.delete("LUT_PRECISION_HIGH");
      }
      this.setChanged();
    }
  }
  get lut() {
    return this.input.uniforms.get("lut").value;
  }
  set lut(value) {
    const { defines, uniforms } = this.input;
    uniforms.get("lut").value = value;
    if (value === null) {
      return;
    }
    const image = value.image;
    defines.set("LUT_SIZE", Math.min(image.width, image.height).toFixed(16));
    defines.set("LUT_TEXEL_WIDTH", (1 / image.width).toFixed(16));
    defines.set("LUT_TEXEL_HEIGHT", (1 / image.height).toFixed(16));
    this.lutPrecisionHigh = value.type === FloatType4 || value.type === HalfFloatType4;
    const domainData = value.userData;
    const min = domainData.domainMin;
    const max = domainData.domainMax;
    uniforms.get("domainMin").value = min.clone();
    uniforms.get("domainMax").value = max.clone();
    if (min.x !== 0 || min.y !== 0 || min.z !== 0 || max.x !== 1 || max.y !== 1 || max.z !== 1) {
      defines.set("CUSTOM_INPUT_DOMAIN", true);
    } else {
      defines.delete("CUSTOM_INPUT_DOMAIN");
    }
    this.configureTetrahedralInterpolation();
    this.updateScaleOffset();
    this.setChanged();
  }
  /**
   * Updates the scale and offset for the LUT sampling coordinates.
   */
  updateScaleOffset() {
    const lut = this.lut;
    if (lut === null) {
      return;
    }
    const size = Math.min(lut.image.width, lut.image.height);
    const scale = this.input.uniforms.get("scale").value;
    const offset = this.input.uniforms.get("offset").value;
    const domainBounds = lut.userData;
    if (this.tetrahedralInterpolation) {
      if (this.input.defines.has("CUSTOM_INPUT_DOMAIN")) {
        const domainScale = domainBounds.domainMax.clone().sub(domainBounds.domainMin);
        scale.setScalar(size - 1).divide(domainScale);
        offset.copy(domainBounds.domainMin).negate().multiply(scale);
      } else {
        scale.setScalar(size - 1);
        offset.setScalar(0);
      }
    } else if (this.input.defines.has("CUSTOM_INPUT_DOMAIN")) {
      const domainScale = domainBounds.domainMax.clone().sub(domainBounds.domainMin).multiplyScalar(size);
      scale.setScalar(size - 1).divide(domainScale);
      offset.copy(domainBounds.domainMin).negate().multiply(scale).addScalar(1 / (2 * size));
    } else {
      scale.setScalar((size - 1) / size);
      offset.setScalar(1 / (2 * size));
    }
  }
  /**
   * Configures parameters for tetrahedral interpolation.
   */
  configureTetrahedralInterpolation() {
    const lut = this.lut;
    if (lut === null) {
      return;
    }
    lut.minFilter = LinearFilter2;
    lut.magFilter = LinearFilter2;
    if (this.tetrahedralInterpolation) {
      lut.minFilter = NearestFilter2;
      lut.magFilter = NearestFilter2;
    }
    lut.needsUpdate = true;
  }
  get tetrahedralInterpolation() {
    return this.input.defines.has("TETRAHEDRAL_INTERPOLATION");
  }
  set tetrahedralInterpolation(value) {
    if (value) {
      this.input.defines.set("TETRAHEDRAL_INTERPOLATION", true);
    } else {
      this.input.defines.delete("TETRAHEDRAL_INTERPOLATION");
    }
    this.configureTetrahedralInterpolation();
    this.updateScaleOffset();
    this.setChanged();
  }
};

// src/effects/NoiseEffect.ts
import { Uniform as Uniform14 } from "three";

// src/effects/shaders/noise.frag
var noise_default = `uniform float page;vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){vec2 p=uv*(SEED+page);
#ifdef RGB
vec2 pR=p;vec2 pG=vec2(p.x+1.0,p.y);vec2 pB=vec2(p.x,p.y+1.0);vec3 noise=vec3(rand(pR),rand(pG),rand(pB));
#else
vec3 noise=vec3(rand(p));
#endif
#ifdef PREMULTIPLY
noise*=inputColor.rgb;
#endif
return vec4(noise,inputColor.a);}`;

// src/effects/NoiseEffect.ts
var NoiseEffect = class extends Effect {
  /**
   * @see {@link fps}
   */
  _fps;
  /**
   * The animation update timeout in seconds.
   */
  timeout;
  /**
   * A time accumulator.
   */
  acc;
  /**
   * Constructs a new noise effect.
   */
  constructor({
    rgb = true,
    premultiply = false,
    fps = 24
  } = {}) {
    super("NoiseEffect");
    this.fragmentShader = noise_default;
    this.blendMode.blendFunction = new SoftLightBlendFunction();
    this.input.uniforms.set("page", new Uniform14(1));
    this.input.defines.set("SEED", Math.max(1, Math.round(Math.random() * 1e3)).toFixed(1));
    this._fps = 0;
    this.timeout = 0;
    this.acc = 0;
    this.rgb = rgb;
    this.premultiply = premultiply;
    this.fps = fps;
  }
  /**
   * The current noise page.
   */
  get page() {
    return this.input.uniforms.get("page").value;
  }
  set page(value) {
    this.input.uniforms.get("page").value = value;
  }
  get fps() {
    return this._fps;
  }
  set fps(value) {
    this._fps = value;
    this.timeout = value !== 0 ? 1 / value : 0;
  }
  get rgb() {
    return this.input.defines.has("RGB");
  }
  set rgb(value) {
    if (this.rgb !== value) {
      if (value) {
        this.input.defines.set("RGB", true);
      } else {
        this.input.defines.delete("RGB");
      }
      this.setChanged();
    }
  }
  get premultiply() {
    return this.input.defines.has("PREMULTIPLY");
  }
  set premultiply(value) {
    if (this.premultiply !== value) {
      if (value) {
        this.input.defines.set("PREMULTIPLY", true);
      } else {
        this.input.defines.delete("PREMULTIPLY");
      }
      this.setChanged();
    }
  }
  render() {
    if (this.timer === null || this.fps === 0) {
      return;
    }
    this.acc += this.timer.getDelta();
    if (this.acc >= this.timeout) {
      this.page = (this.page + 1) % 1e3;
      this.acc = 0;
    }
  }
};

// src/effects/ScanlineEffect.ts
import { Uniform as Uniform15, Vector2 as Vector27 } from "three";

// src/effects/shaders/scanline.frag
var scanline_default = `uniform vec2 params;
#ifdef SCROLL
uniform float scrollSpeed;
#endif
vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){float y=uv.y+params.x;
#ifdef SCROLL
y+=fract(time*scrollSpeed);
#endif
float f=y*params.y;vec2 sl=vec2(sin(f),cos(f));return vec4(sl.xyx,inputColor.a);}`;

// src/effects/ScanlineEffect.ts
var ScanlineEffect = class extends Effect {
  /**
   * @see {@link density}
   */
  _density;
  /**
   * Constructs a new scanline effect.
   *
   * @param options - The options.
   */
  constructor({
    density = 1,
    offset = 0,
    scrollSpeed = 0
  } = {}) {
    super("ScanlineEffectOptions");
    this.fragmentShader = scanline_default;
    this.blendMode.blendFunction = new OverlayBlendFunction();
    const uniforms = this.input.uniforms;
    uniforms.set("params", new Uniform15(new Vector27(offset, 0)));
    uniforms.set("scrollSpeed", new Uniform15(0));
    this._density = density;
    this.scrollSpeed = scrollSpeed;
  }
  get density() {
    return this._density;
  }
  set density(value) {
    this._density = value;
    this.onResolutionChange();
  }
  get offset() {
    const params = this.input.uniforms.get("params").value;
    return params.x;
  }
  set offset(value) {
    const params = this.input.uniforms.get("params").value;
    params.x = value;
  }
  get scrollSpeed() {
    return this.input.uniforms.get("scrollSpeed").value;
  }
  set scrollSpeed(value) {
    this.input.uniforms.get("scrollSpeed").value = value;
    if (value === 0) {
      if (this.input.defines.delete("SCROLL")) {
        this.setChanged();
      }
    } else if (!this.input.defines.has("SCROLL")) {
      this.input.defines.set("SCROLL", "1");
      this.setChanged();
    }
  }
  onResolutionChange() {
    const resolution = this.resolution;
    const params = this.input.uniforms.get("params").value;
    params.y = this.density * resolution.baseHeight;
  }
};

// src/effects/SMAAEffect.ts
import {
  Color as Color4,
  LinearFilter as LinearFilter3,
  LoadingManager,
  NearestFilter as NearestFilter3,
  Texture as Texture12,
  Uniform as Uniform18
} from "three";

// src/materials/SMAAEdgeDetectionMaterial.ts
import { Uniform as Uniform16, UnsignedByteType as UnsignedByteType6 } from "three";

// src/materials/shaders/smaa-edge-detection.frag
var smaa_edge_detection_default = `#include <pp_default_output_pars_fragment>
in vec2 vUv,vUv0,vUv1;
#if EDGE_DETECTION_MODE != 0
in vec2 vUv2,vUv3,vUv4,vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#include <pp_depth_buffer_pars_fragment>
#include <pp_depth_utils_pars_fragment>
#include <packing>
float getOrthographicDepth(sampler2D depthBuffer,const in vec2 uv,const in float near,const in float far){float depth=readDepth(depthBuffer,uv,near,far);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,near,far);return viewZToOrthographicDepth(viewZ,near,far);
#else
return depth;
#endif
}uniform vec2 cameraParams;vec3 gatherNeighbors(){float p=getOrthographicDepth(depthBuffer,vUv,cameraParams.x,cameraParams.y);float pLeft=getOrthographicDepth(depthBuffer,vUv0,cameraParams.x,cameraParams.y);float pTop=getOrthographicDepth(depthBuffer,vUv1,cameraParams.x,cameraParams.y);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
#ifdef PREDICATIONBUFFER_PRECISION_HIGH
uniform mediump sampler2D predicationBuffer;
#else
uniform lowp sampler2D predicationBuffer;
#endif
vec3 gatherNeighbors(){float p=texture(predicationBuffer,vUv).r;float pLeft=texture(predicationBuffer,vUv0).r;float pTop=texture(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
#include <pp_input_buffer_pars_fragment>
#endif
void main(){
#if PREDICATION_MODE != 0 && EDGE_DETECTION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}out_Color=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture(inputBuffer,vUv).rgb);float lLeft=luminance(texture(inputBuffer,vUv0).rgb);float lTop=luminance(texture(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture(inputBuffer,vUv2).rgb);float lBottom=luminance(texture(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);out_Color=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture(inputBuffer,vUv).rgb;vec3 cLeft=texture(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);out_Color=vec4(edges,0.0,1.0);
#endif
}`;

// src/materials/shaders/smaa-edge-detection.vert
var smaa_edge_detection_default2 = `#include <pp_resolution_pars_fragment>
out vec2 vUv,vUv0,vUv1;
#if EDGE_DETECTION_MODE != 0
out vec2 vUv2,vUv3,vUv4,vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+resolution.zw*vec2(-1.0,0.0);vUv1=vUv+resolution.zw*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+resolution.zw*vec2(1.0,0.0);vUv3=vUv+resolution.zw*vec2(0.0,1.0);vUv4=vUv+resolution.zw*vec2(-2.0,0.0);vUv5=vUv+resolution.zw*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/SMAAEdgeDetectionMaterial.ts
var SMAAEdgeDetectionMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new SMAA edge detection material.
   */
  constructor() {
    super({
      name: "SMAAEdgeDetectionMaterial",
      fragmentShader: smaa_edge_detection_default,
      vertexShader: smaa_edge_detection_default2,
      defines: {
        LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
        EDGE_DETECTION_MODE: 2 /* COLOR */,
        EDGE_THRESHOLD: "0.05",
        PREDICATION_MODE: 0 /* DISABLED */,
        PREDICATION_THRESHOLD: "0.0002",
        PREDICATION_SCALE: "2.0",
        PREDICATION_STRENGTH: "1.0"
      },
      uniforms: {
        depthBuffer: new Uniform16(null),
        predicationBuffer: new Uniform16(null)
      }
    });
  }
  /**
   * The depth buffer.
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The edge detection mode.
   *
   * @defaultValue {@link SMAAEdgeDetectionMode.COLOR}
   */
  get edgeDetectionMode() {
    return this.defines.EDGE_DETECTION_MODE;
  }
  set edgeDetectionMode(value) {
    this.defines.EDGE_DETECTION_MODE = value;
    this.needsUpdate = true;
  }
  /**
   * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.
   *
   * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.
   *
   * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a
   * direction, the perceptual contrast in the other neighbors will be hidden.
   *
   * @defaultValue 2
   */
  get localContrastAdaptationFactor() {
    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
  }
  set localContrastAdaptationFactor(value) {
    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed(9);
    this.needsUpdate = true;
  }
  /**
   * The edge detection threshold. Range: [0.0, 0.5].
   *
   * A lower value results in more edges being detected at the expense of performance.
   *
   * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05
   * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.
   *
   * If depth-based edge detection is used, the threshold must be adjusted to match the scene depth distribution.
   *
   * @defaultValue 0.05
   */
  get edgeDetectionThreshold() {
    return Number(this.defines.EDGE_THRESHOLD);
  }
  set edgeDetectionThreshold(value) {
    this.defines.EDGE_THRESHOLD = value.toFixed(9);
    this.needsUpdate = true;
  }
  /**
   * The predication mode.
   *
   * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional
   * buffer such as a light accumulation or depth buffer.
   *
   * @defaultValue {@link SMAAPredicationMode.DISABLED}
   */
  get predicationMode() {
    return this.defines.PREDICATION_MODE;
  }
  set predicationMode(value) {
    this.defines.PREDICATION_MODE = value;
    this.needsUpdate = true;
  }
  /**
   * Indicates whether the predication buffer uses high precision.
   */
  get predicationBufferPrecisionHigh() {
    return this.defines.PREDICATIONBUFFER_PRECISION_HIGH !== void 0;
  }
  set predicationBufferPrecisionHigh(value) {
    if (this.predicationBufferPrecisionHigh !== value) {
      if (value) {
        this.defines.PREDICATIONBUFFER_PRECISION_HIGH = true;
      } else {
        delete this.defines.PREDICATIONBUFFER_PRECISION_HIGH;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * The predication buffer.
   *
   * If this buffer uses high precision, the macro `PREDICATIONBUFFER_PRECISION_HIGH` will be defined.
   */
  set predicationBuffer(value) {
    this.predicationBufferPrecisionHigh = value !== null && value.type !== UnsignedByteType6;
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * The predication threshold.
   *
   * @defaultValue 0.0002
   */
  get predicationThreshold() {
    return Number(this.defines.PREDICATION_THRESHOLD);
  }
  set predicationThreshold(value) {
    this.defines.PREDICATION_THRESHOLD = value.toFixed(9);
    this.needsUpdate = true;
  }
  /**
   * The predication scale. Range: [1.0, 5.0].
   *
   * Determines how much the edge detection threshold should be scaled when using predication.
   *
   * @defaultValue 2
   */
  get predicationScale() {
    return Number(this.defines.PREDICATION_SCALE);
  }
  set predicationScale(value) {
    this.defines.PREDICATION_SCALE = value.toFixed(9);
    this.needsUpdate = true;
  }
  /**
   * The predication strength. Range: [0.0, 1.0].
   *
   * Determines how much the edge detection threshold should be decreased locally when using predication.
   *
   * @defaultValue 1
   */
  get predicationStrength() {
    return Number(this.defines.PREDICATION_STRENGTH);
  }
  set predicationStrength(value) {
    this.defines.PREDICATION_STRENGTH = value.toFixed(9);
    this.needsUpdate = true;
  }
};

// src/materials/SMAAWeightsMaterial.ts
import { Uniform as Uniform17 } from "three";

// src/materials/shaders/smaa-weights.frag
var smaa_weights_default = `#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#include <pp_resolution_pars_fragment>
#define sampleLevelZeroOffset(t, coord, offset) textureOffset(t, coord, offset, 0.0)
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;in vec2 vUv;in vec4 vOffset[3];in vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(resolution.zw,1.0);for(int i=0;i<MAX_SEARCH_STEPS;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*resolution.z;vec3 t=vec3(resolution.zw,1.0);for(int i=0;i<MAX_SEARCH_STEPS;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*resolution.zwzw+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,ivec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,ivec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,ivec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*resolution.zwzw+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,ivec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,ivec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,ivec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*resolution.zw+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return resolution.z*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*resolution.zw+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-resolution.z*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*resolution.zw+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return resolution.w*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*resolution.zw+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-resolution.w*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,ivec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,ivec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,ivec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,ivec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,ivec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,ivec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,ivec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,ivec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,ivec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,ivec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}out_Color=weights;}`;

// src/materials/shaders/smaa-weights.vert
var smaa_weights_default2 = `#include <pp_resolution_pars_fragment>
out vec2 vUv;out vec4 vOffset[3];out vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution.xy;vOffset[0]=vUv.xyxy+resolution.zwzw*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+resolution.zwzw*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*resolution.zzww*vec4(MAX_SEARCH_STEPS);gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/SMAAWeightsMaterial.ts
var SMAAWeightsMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new SMAA weights material.
   */
  constructor() {
    super({
      name: "SMAAWeightsMaterial",
      fragmentShader: smaa_weights_default,
      vertexShader: smaa_weights_default2,
      defines: {
        // Configurable settings:
        MAX_SEARCH_STEPS: 16,
        MAX_SEARCH_STEPS_DIAG: 8,
        CORNER_ROUNDING: 25,
        CORNER_ROUNDING_NORM: 0.25,
        // Non-configurable settings:
        AREATEX_MAX_DISTANCE: 16,
        AREATEX_MAX_DISTANCE_DIAG: 20,
        AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
        AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
        SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
        SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
      },
      uniforms: {
        searchTexture: new Uniform17(null),
        areaTexture: new Uniform17(null)
      }
    });
  }
  /**
   * The search lookup texture.
   */
  get searchTexture() {
    return this.uniforms.searchTexture.value;
  }
  set searchTexture(value) {
    this.uniforms.searchTexture.value = value;
  }
  /**
   * The area lookup texture.
   */
  get areaTexture() {
    return this.uniforms.areaTexture.value;
  }
  set areaTexture(value) {
    this.uniforms.areaTexture.value = value;
  }
  /**
   * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   * Range: [0, 112].
   *
   * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is
   * 64 (perfectly means that longer lines won't look as good, but are still antialiased).
   */
  get orthogonalSearchSteps() {
    return this.defines.MAX_SEARCH_STEPS;
  }
  set orthogonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 112);
    this.defines.MAX_SEARCH_STEPS = s;
    this.needsUpdate = true;
  }
  /**
   * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search
   * jumps one pixel at a time. Range: [0, 20].
   *
   * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a
   * significant impact on older machines.
   */
  get diagonalSearchSteps() {
    return this.defines.MAX_SEARCH_STEPS_DIAG;
  }
  set diagonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 20);
    this.defines.MAX_SEARCH_STEPS_DIAG = s;
    this.needsUpdate = true;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   */
  get diagonalDetection() {
    return this.defines.DISABLE_DIAG_DETECTION === void 0;
  }
  set diagonalDetection(value) {
    if (value) {
      delete this.defines.DISABLE_DIAG_DETECTION;
    } else {
      this.defines.DISABLE_DIAG_DETECTION = true;
    }
    this.needsUpdate = true;
  }
  /**
   * Specifies how much sharp corners will be rounded. Range: [0, 100].
   */
  get cornerRounding() {
    return Number(this.defines.CORNER_ROUNDING);
  }
  set cornerRounding(value) {
    const r = Math.min(Math.max(value, 0), 100);
    this.defines.CORNER_ROUNDING = r.toFixed(9);
    this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed(9);
    this.needsUpdate = true;
  }
  /**
   * Indicates whether corner detection is enabled.
   */
  get cornerDetection() {
    return this.defines.DISABLE_CORNER_DETECTION === void 0;
  }
  set cornerDetection(value) {
    if (value) {
      delete this.defines.DISABLE_CORNER_DETECTION;
    } else {
      this.defines.DISABLE_CORNER_DETECTION = true;
    }
    this.needsUpdate = true;
  }
};

// src/passes/ShaderPass.ts
var ShaderPass = class extends Pass {
  /**
   * The name of the input buffer uniform.
   *
   * Most fullscreen materials modify texels from an input texture. This pass automatically assigns the default input
   * buffer to the uniform identified by this name.
   */
  uniformName;
  /**
   * Constructs a new shader pass.
   *
   * @param material - A shader material.
   * @param uniformName - The name of the input buffer uniform. Default is `inputBuffer`.
   */
  constructor(material, uniformName = "inputBuffer") {
    super("ShaderPass");
    this.output.defaultBuffer = this.createFramebuffer();
    this.fullscreenMaterial = material;
    this.uniformName = uniformName;
  }
  onInputChange() {
    const uniforms = this.fullscreenMaterial.uniforms;
    if (this.input.hasDefaultBuffer && uniforms[this.uniformName] !== void 0) {
      uniforms[this.uniformName].value = this.input.defaultBuffer.value;
    }
  }
  render() {
    this.setRenderTarget(this.output.defaultBuffer?.value);
    this.renderFullscreen();
  }
};

// src/textures/smaa/searchImageDataURL.ts
var searchImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC";

// src/textures/smaa/areaImageDataURL.ts
var areaImageDataURL_default = "data:image/png;base64,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";

// src/effects/shaders/smaa.frag
var smaa_default = `uniform lowp sampler2D weightMap;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec4 smaa(sampler2D inputBuffer,const in vec4 inputColor,const in vec2 uv){vec4 a;a.x=textureOffset(weightMap,uv,ivec2(1,0)).a;a.y=textureOffset(weightMap,uv,ivec2(0,1)).g;a.wz=texture(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(resolution.zw,-resolution.zw)+uv.xyxy;color=blendingWeight.x*texture(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture(inputBuffer,blendingCoord.zw);}return color;}vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){return smaa(gBuffer.color,inputColor,uv);}`;

// src/effects/SMAAEffect.ts
var SMAAEffect = class _SMAAEffect extends Effect {
  /**
   * Identifies the SMAA edges buffer.
   */
  static BUFFER_EDGES = "BUFFER_EDGES";
  /**
   * Identifies the SMAA weights buffer.
   */
  static BUFFER_WEIGHTS = "BUFFER_WEIGHTS";
  /**
  * A clear pass for the edges buffer.
  */
  clearPass;
  /**
  * An edge detection pass.
  */
  edgeDetectionPass;
  /**
  * An SMAA weights pass.
  */
  weightsPass;
  /**
   * Constructs a new SMAA effect.
   *
   * @param options - The options.
   */
  constructor({
    preset = 1 /* MEDIUM */,
    edgeDetectionMode = 2 /* COLOR */,
    predicationMode = 1 /* DEPTH */
  } = {}) {
    super("SMAAEffect");
    this.fragmentShader = smaa_default;
    this.output.setBuffer(_SMAAEffect.BUFFER_EDGES, this.createFramebuffer());
    this.output.setBuffer(_SMAAEffect.BUFFER_WEIGHTS, this.createFramebuffer());
    this.input.gBuffer.add("Depth" /* DEPTH */);
    this.input.uniforms.set("weightMap", new Uniform18(null));
    this.weightsTexture.bindUniform(this.input.uniforms.get("weightMap"));
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.output.defaultBuffer = this.renderTargetEdges;
    this.clearPass.clearValues.color = new Color4(0);
    this.clearPass.clearValues.alpha = 1;
    this.edgeDetectionPass = new ShaderPass(new SMAAEdgeDetectionMaterial());
    this.edgeDetectionPass.output.defaultBuffer = this.renderTargetEdges;
    this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;
    this.edgeDetectionMaterial.predicationMode = predicationMode;
    this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());
    this.weightsPass.input.defaultBuffer = this.edgesTexture;
    this.weightsPass.output.defaultBuffer = this.renderTargetWeights;
    this.subpasses = [this.clearPass, this.edgeDetectionPass, this.weightsPass];
    this.loadTextures();
    this.applyPreset(preset);
  }
  get camera() {
    return super.camera;
  }
  set camera(value) {
    super.camera = value;
    if (value !== null) {
      this.edgeDetectionMaterial.copyCameraSettings(value);
    }
  }
  /**
   * A render target for the SMAA edge detection.
   */
  get renderTargetEdges() {
    return this.output.buffers.get(_SMAAEffect.BUFFER_EDGES);
  }
  /**
   * A render target for the SMAA edge weights.
   */
  get renderTargetWeights() {
    return this.output.buffers.get(_SMAAEffect.BUFFER_WEIGHTS);
  }
  /**
   * The edges texture.
   */
  get edgesTexture() {
    return this.output.buffers.get(_SMAAEffect.BUFFER_EDGES).texture;
  }
  /**
   * The edge weights texture.
   */
  get weightsTexture() {
    return this.output.buffers.get(_SMAAEffect.BUFFER_WEIGHTS).texture;
  }
  /**
   * The edge detection material.
   */
  get edgeDetectionMaterial() {
    return this.edgeDetectionPass.fullscreenMaterial;
  }
  get edgeDetectionMode() {
    return this.edgeDetectionMaterial.edgeDetectionMode;
  }
  set edgeDetectionMode(value) {
    this.edgeDetectionMaterial.edgeDetectionMode = value;
  }
  get predicationMode() {
    return this.edgeDetectionMaterial.predicationMode;
  }
  set predicationMode(value) {
    this.edgeDetectionMaterial.predicationMode = value;
  }
  /**
   * The edge weights material.
   */
  get weightsMaterial() {
    return this.weightsPass.fullscreenMaterial;
  }
  /**
   * Loads the SMAA lookup textures.
   */
  loadTextures() {
    const loadingManager = new LoadingManager();
    let searchImage;
    let areaImage;
    loadingManager.onLoad = () => {
      const searchTexture = new Texture12(searchImage);
      searchTexture.name = "SMAA.Search";
      searchTexture.magFilter = NearestFilter3;
      searchTexture.minFilter = NearestFilter3;
      searchTexture.generateMipmaps = false;
      searchTexture.needsUpdate = true;
      searchTexture.flipY = true;
      const areaTexture = new Texture12(areaImage);
      areaTexture.name = "SMAA.Area";
      areaTexture.magFilter = LinearFilter3;
      areaTexture.minFilter = LinearFilter3;
      areaTexture.generateMipmaps = false;
      areaTexture.needsUpdate = true;
      areaTexture.flipY = false;
      this.disposables.add(searchTexture);
      this.disposables.add(areaTexture);
      this.weightsMaterial.searchTexture = searchTexture;
      this.weightsMaterial.areaTexture = areaTexture;
    };
    loadingManager.itemStart("search");
    loadingManager.itemStart("area");
    if (typeof Image !== "undefined") {
      searchImage = new Image();
      areaImage = new Image();
      searchImage.addEventListener("load", () => loadingManager.itemEnd("search"));
      areaImage.addEventListener("load", () => loadingManager.itemEnd("area"));
      searchImage.src = searchImageDataURL_default;
      areaImage.src = areaImageDataURL_default;
    } else {
      console.warn("Failed to create search/area images");
    }
  }
  /**
   * Applies the given quality preset.
   *
   * @param preset - The preset.
   */
  applyPreset(preset) {
    const edgeDetectionMaterial = this.edgeDetectionMaterial;
    const weightsMaterial = this.weightsMaterial;
    switch (preset) {
      case 0 /* LOW */:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.015;
        weightsMaterial.orthogonalSearchSteps = 4;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case 1 /* MEDIUM */:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.01;
        weightsMaterial.orthogonalSearchSteps = 8;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case 2 /* HIGH */:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.01;
        weightsMaterial.orthogonalSearchSteps = 16;
        weightsMaterial.diagonalSearchSteps = 8;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
      case 3 /* ULTRA */:
        edgeDetectionMaterial.edgeDetectionThreshold = 5e-3;
        weightsMaterial.orthogonalSearchSteps = 32;
        weightsMaterial.diagonalSearchSteps = 16;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
    }
  }
  onInputChange() {
    this.edgeDetectionMaterial.inputBuffer = this.input.defaultBuffer?.value ?? null;
    this.edgeDetectionMaterial.depthBuffer = this.input.getBuffer("Depth" /* DEPTH */);
  }
  onResolutionChange() {
    const { width, height } = this.resolution;
    this.renderTargetEdges.value.setSize(width, height);
    this.renderTargetWeights.value.setSize(width, height);
  }
  render() {
    this.clearPass.render();
    this.edgeDetectionPass.render();
    this.weightsPass.render();
  }
};

// src/effects/TextureEffect.ts
import { Uniform as Uniform19, UnsignedByteType as UnsignedByteType7 } from "three";

// src/effects/shaders/texture.frag
var texture_default = `#ifdef TEXTURE_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
#ifdef UV_TRANSFORM
in vec2 vUv2;
#endif
vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){
#ifdef UV_TRANSFORM
vec4 texel=texture(map,vUv2);
#else
vec4 texel=texture(map,uv);
#endif
vec4 result=TEXEL;return vec4(result.rgb,max(inputColor.a,result.a));}`;

// src/effects/shaders/texture.vert
var texture_default2 = `uniform mat3 uvTransform;out vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uvTransform*vec3(uv,1.0)).xy;}`;

// src/effects/TextureEffect.ts
var TextureEffect = class extends Effect {
  /**
   * Constructs a new texture effect.
   *
   * @param options - The options.
   */
  constructor({ texture = null } = {}) {
    super("TextureEffect");
    this.fragmentShader = texture_default;
    const defines = this.input.defines;
    defines.set("TEXEL", "texel");
    const uniforms = this.input.uniforms;
    uniforms.set("map", new Uniform19(null));
    uniforms.set("uvTransform", new Uniform19(null));
    this.texture = texture;
  }
  get texture() {
    return this.input.uniforms.get("map").value;
  }
  set texture(value) {
    const prevTexture = this.texture;
    const uniforms = this.input.uniforms;
    const defines = this.input.defines;
    if (prevTexture !== value) {
      uniforms.get("map").value = value;
      defines.delete("TEXTURE_PRECISION_HIGH");
      if (value !== null) {
        if (value.matrixAutoUpdate) {
          defines.set("UV_TRANSFORM", true);
          uniforms.get("uvTransform").value = value.matrix;
          this.vertexShader = texture_default2;
        } else {
          defines.delete("UV_TRANSFORM");
          uniforms.get("uvTransform").value = null;
          this.vertexShader = null;
        }
        if (value.type !== UnsignedByteType7) {
          defines.set("TEXTURE_PRECISION_HIGH", true);
        }
      }
      this.setChanged();
    }
  }
  /**
   * Sets the swizzles that will be applied to the components of a texel before it is written to the output color.
   *
   * @param r - The swizzle for the `r` component.
   * @param g - The swizzle for the `g` component. Defaults to the same value used for `r`.
   * @param b - The swizzle for the `b` component. Defaults to the same value used for `r`.
   * @param a - The swizzle for the `a` component. Defaults to the same value used for `r`.
   */
  setTextureSwizzleRGBA(r, g = r, b = r, a = r) {
    const rgba = "rgba";
    let swizzle = "";
    if (r !== 0 /* RED */ || g !== 1 /* GREEN */ || b !== 2 /* BLUE */ || a !== 3 /* ALPHA */) {
      swizzle = [".", rgba[r], rgba[g], rgba[b], rgba[a]].join("");
    }
    this.input.defines.set("TEXEL", "texel" + swizzle);
    this.setChanged();
  }
  render() {
    if (this.texture !== null && this.texture.matrixAutoUpdate) {
      this.texture.updateMatrix();
    }
  }
};

// src/effects/shaders/tone-mapping.frag
var tone_mapping_default = `#include <tonemapping_pars_fragment>
vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){return vec4(toneMapping(inputColor.rgb),inputColor.a);}`;

// src/effects/ToneMappingEffect.ts
var toneMappingOperators = /* @__PURE__ */ new Map([
  [0 /* LINEAR */, "LinearToneMapping(texel)"],
  [1 /* REINHARD */, "ReinhardToneMapping(texel)"],
  [2 /* CINEON */, "CineonToneMapping(texel)"],
  [3 /* ACES_FILMIC */, "ACESFilmicToneMapping(texel)"],
  [4 /* AGX */, "AgXToneMapping(texel)"],
  [5 /* NEUTRAL */, "NeutralToneMapping(texel)"],
  [6 /* CUSTOM */, "CustomToneMapping(texel)"]
]);
var ToneMappingEffect = class extends Effect {
  /**
   * Constructs a new tone mapping effect.
   *
   * @param options - The options.
   */
  constructor({ toneMapping = 4 /* AGX */ } = {}) {
    super("ToneMappingEffect");
    this.fragmentShader = tone_mapping_default;
    this.toneMapping = toneMapping;
  }
  get toneMapping() {
    return this.input.defines.get("TONE_MAPPING");
  }
  set toneMapping(value) {
    if (this.toneMapping !== value) {
      const defines = this.input.defines;
      defines.clear();
      defines.set("TONE_MAPPING", value);
      const operator = toneMappingOperators.get(value);
      if (operator === void 0) {
        throw new Error(`Invalid tone mapping: ${value}`);
      }
      defines.set("toneMapping(texel)", operator);
      this.setChanged();
    }
  }
};

// src/effects/VignetteEffect.ts
import { Color as Color5, Uniform as Uniform20, Vector2 as Vector28 } from "three";

// src/effects/shaders/vignette.frag
var vignette_default = `uniform vec2 offsetFeather;uniform vec3 color;vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){const vec2 center=vec2(0.5);vec3 result=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);float feather=1.0-offsetFeather.y;float factor=smoothstep(feather*0.799,0.8,d*(offsetFeather.x+feather));result=mix(result,color,factor);
#else
vec2 coord=(uv-center)*offsetFeather.xx;result=mix(result,offsetFeather.yyy*color,dot(coord,coord));
#endif
return vec4(result,inputColor.a);}`;

// src/effects/VignetteEffect.ts
var VignetteEffect = class extends Effect {
  /**
   * Constructs a new vignette effect.
   *
   * @param options - The options.
   */
  constructor({
    technique = 0 /* DEFAULT */,
    offset = 0.5,
    feather = 0.5,
    color: color2 = 0
  } = {}) {
    super("VignetteEffectOptions");
    this.fragmentShader = vignette_default;
    this.technique = technique;
    const uniforms = this.input.uniforms;
    uniforms.set("offsetFeather", new Uniform20(new Vector28(offset, feather)));
    uniforms.set("color", new Uniform20(new Color5(color2)));
  }
  get technique() {
    return this.input.defines.get("VIGNETTE_TECHNIQUE");
  }
  set technique(value) {
    if (this.technique !== value) {
      this.input.defines.set("VIGNETTE_TECHNIQUE", value);
      this.setChanged();
    }
  }
  get offset() {
    const offsetFeather = this.input.uniforms.get("offsetFeather").value;
    return offsetFeather.x;
  }
  set offset(value) {
    const offsetFeather = this.input.uniforms.get("offsetFeather").value;
    offsetFeather.x = value;
  }
  get feather() {
    const offsetFeather = this.input.uniforms.get("offsetFeather").value;
    return offsetFeather.y;
  }
  set feather(value) {
    const offsetFeather = this.input.uniforms.get("offsetFeather").value;
    offsetFeather.y = value;
  }
  get color() {
    return this.input.uniforms.get("color").value;
  }
  set color(value) {
    const color2 = this.input.uniforms.get("color").value;
    color2.set(value);
  }
};

// src/materials/AdaptiveLuminanceMaterial.ts
import { Uniform as Uniform21 } from "three";

// src/materials/shaders/adaptive-luminance.frag
var adaptive_luminance_default = `#include <pp_default_output_pars_fragment>
#include <packing>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
uniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;in vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture(luminanceBuffer0,vUv));float l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;l0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));out_Color=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}`;

// src/materials/AdaptiveLuminanceMaterial.ts
var AdaptiveLuminanceMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new adaptive luminance material.
   */
  constructor() {
    super({
      name: "AdaptiveLuminanceMaterial",
      fragmentShader: adaptive_luminance_default,
      vertexShader: common_default,
      defines: {
        MIP_LEVEL_1X1: 0
      },
      uniforms: {
        luminanceBuffer0: new Uniform21(null),
        luminanceBuffer1: new Uniform21(null),
        minLuminance: new Uniform21(0.01),
        deltaTime: new Uniform21(0),
        tau: new Uniform21(1)
      }
    });
  }
  /**
   * The primary luminance buffer that contains the downsampled average luminance.
   */
  set luminanceBuffer0(value) {
    this.uniforms.luminanceBuffer0.value = value;
  }
  /**
   * The secondary luminance buffer.
   */
  set luminanceBuffer1(value) {
    this.uniforms.luminanceBuffer1.value = value;
  }
  /**
   * The 1x1 mipmap level.
   *
   * This level is used to identify the smallest mipmap of the primary luminance buffer.
   */
  set mipLevel1x1(value) {
    this.defines.MIP_LEVEL_1X1 = value;
    this.needsUpdate = true;
  }
  /**
   * The delta time.
   */
  set deltaTime(value) {
    this.uniforms.deltaTime.value = value;
  }
  /**
   * The lowest possible luminance value.
   */
  get minLuminance() {
    return this.uniforms.minLuminance.value;
  }
  set minLuminance(value) {
    this.uniforms.minLuminance.value = value;
  }
  /**
   * The luminance adaptation rate.
   */
  get adaptationRate() {
    return this.uniforms.tau.value;
  }
  set adaptationRate(value) {
    this.uniforms.tau.value = value;
  }
};

// src/materials/BokehMaterial.ts
import { Uniform as Uniform22 } from "three";

// src/materials/shaders/convolution.bokeh.frag
var convolution_bokeh_default = `#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#include <pp_resolution_pars_fragment>
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
uniform lowp sampler2D cocBuffer;uniform float scale;in vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 cocNearFar=texture(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;
#else
float coc=texture(cocBuffer,vUv).g*scale;
#endif
if(coc==0.0){out_Color=texture(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=resolution.zw*max(cocNearFar.x,cocNearFar.y);
#else
vec2 step=resolution.zw*coc;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture(inputBuffer,uv);}out_Color=acc/64.0;
#else
vec4 maxValue=texture(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture(inputBuffer,uv),maxValue);}out_Color=maxValue;
#endif
}}`;

// src/materials/BokehMaterial.ts
var BokehMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new bokeh material.
   *
   * @param fill - Enables or disables the bokeh highlight fill mode.
   * @param foreground - Determines whether this material will be applied to foreground colors.
   */
  constructor(fill = false, foreground = false) {
    super({
      name: "BokehMaterial",
      fragmentShader: convolution_bokeh_default,
      vertexShader: common_default,
      defines: {
        PASS: fill ? 2 : 1
      },
      uniforms: {
        cocBuffer: new Uniform22(null),
        kernel64: new Uniform22(null),
        kernel16: new Uniform22(null),
        scale: new Uniform22(1)
      }
    });
    if (foreground) {
      this.defines.FOREGROUND = true;
    }
    this.generateKernel();
  }
  /**
   * The circle of confusion buffer.
   */
  set cocBuffer(value) {
    this.uniforms.cocBuffer.value = value;
  }
  /**
   * The blur scale.
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Generates the blur kernel.
   */
  generateKernel() {
    const GOLDEN_ANGLE = 2.39996323;
    const points64 = new Float64Array(128);
    const points16 = new Float64Array(32);
    let i64 = 0, i16 = 0;
    for (let i = 0, sqrt80 = Math.sqrt(80); i < 80; ++i) {
      const theta = i * GOLDEN_ANGLE;
      const r = Math.sqrt(i) / sqrt80;
      const u = r * Math.cos(theta), v3 = r * Math.sin(theta);
      if (i % 5 === 0) {
        points16[i16++] = u;
        points16[i16++] = v3;
      } else {
        points64[i64++] = u;
        points64[i64++] = v3;
      }
    }
    this.uniforms.kernel64.value = points64;
    this.uniforms.kernel16.value = points16;
  }
};

// src/materials/BoxBlurMaterial.ts
import { Uniform as Uniform23 } from "three";

// src/utils/functions/camera.ts
function orthographicDepthToViewZ(depth, near, far) {
  return depth * (near - far) - near;
}
function viewZToOrthographicDepth(viewZ, near, far) {
  return Math.min(Math.max((viewZ + near) / (near - far), 0), 1);
}

// src/materials/shaders/convolution.box.frag
var convolution_box_default = `#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#ifdef BILATERAL
#include <pp_camera_pars_fragment>
#ifdef NORMAL_DEPTH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
#define getDepth(uv) texture(normalDepthBuffer, uv).a
#else
#include <pp_depth_buffer_pars_fragment>
#define getDepth(uv) texture(depthBuffer, uv).r
#endif
#include <packing>
#ifdef PERSPECTIVE_CAMERA
#define getViewZ(depth) perspectiveDepthToViewZ(depth, cameraParams.x, cameraParams.y)
#define linearDepth(uv) viewZToOrthographicDepth(getViewZ(getDepth(uv)), cameraParams.x, cameraParams.y)
#else
#define getViewZ(depth) orthographicDepthToViewZ(depth, cameraParams.x, cameraParams.y)
#define linearDepth(uv) getDepth(uv)
#endif
#endif
#define getTexel(uv) texture(inputBuffer, uv)
#if KERNEL_SIZE == 3
in vec2 vUv00,vUv01,vUv02;in vec2 vUv03,vUv04,vUv05;in vec2 vUv06,vUv07,vUv08;
#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13
in vec2 vUv00,vUv01,vUv02,vUv03,vUv04;in vec2 vUv05,vUv06,vUv07,vUv08,vUv09;in vec2 vUv10,vUv11,vUv12,vUv13,vUv14;in vec2 vUv15,vUv16,vUv17,vUv18,vUv19;in vec2 vUv20,vUv21,vUv22,vUv23,vUv24;
#else
#include <pp_resolution_pars_fragment>
uniform float scale;in vec2 vUv;
#endif
void main(){
#if KERNEL_SIZE == 3
vec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08));
#ifdef BILATERAL
float z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08));
#endif
#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13
vec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08),getTexel(vUv09),getTexel(vUv10),getTexel(vUv11),getTexel(vUv12),getTexel(vUv13),getTexel(vUv14),getTexel(vUv15),getTexel(vUv16),getTexel(vUv17),getTexel(vUv18),getTexel(vUv19),getTexel(vUv20),getTexel(vUv21),getTexel(vUv22),getTexel(vUv23),getTexel(vUv24));
#ifdef BILATERAL
float z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08),linearDepth(vUv09),linearDepth(vUv10),linearDepth(vUv11),linearDepth(vUv12),linearDepth(vUv13),linearDepth(vUv14),linearDepth(vUv15),linearDepth(vUv16),linearDepth(vUv17),linearDepth(vUv18),linearDepth(vUv19),linearDepth(vUv20),linearDepth(vUv21),linearDepth(vUv22),linearDepth(vUv23),linearDepth(vUv24));
#endif
#endif
vec4 result=vec4(0.0);
#ifdef BILATERAL
float w=0.0;
#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)
float centerDepth=z[KERNEL_SIZE_SQ_HALF];for(int i=0;i<KERNEL_SIZE_SQ;++i){float d=step(abs(z[i]-centerDepth),DISTANCE_THRESHOLD);result+=c[i]*d;w+=d;}
#else
float centerDepth=linearDepth(vUv);vec2 s=resolution.zw*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){vec2 coords=vUv+vec2(x,y)*s;vec4 c=getTexel(coords);float z=(x==0&&y==0)?centerDepth:linearDepth(coords);float d=step(abs(z-centerDepth),DISTANCE_THRESHOLD);result+=c*d;w+=d;}}
#endif
out_Color=result/max(w,1.0);
#else
#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)
for(int i=0;i<KERNEL_SIZE_SQ;++i){result+=c[i];}
#else
vec2 s=resolution.zw*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){result+=getTexel(uv+vec2(x,y)*s);}}
#endif
out_Color=result*INV_KERNEL_SIZE_SQ;
#endif
}`;

// src/materials/shaders/convolution.box.vert
var convolution_box_default2 = `#include <pp_resolution_pars_fragment>
uniform float scale;
#if KERNEL_SIZE == 3
out vec2 vUv00,vUv01,vUv02;out vec2 vUv03,vUv04,vUv05;out vec2 vUv06,vUv07,vUv08;
#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13
out vec2 vUv00,vUv01,vUv02,vUv03,vUv04;out vec2 vUv05,vUv06,vUv07,vUv08,vUv09;out vec2 vUv10,vUv11,vUv12,vUv13,vUv14;out vec2 vUv15,vUv16,vUv17,vUv18,vUv19;out vec2 vUv20,vUv21,vUv22,vUv23,vUv24;
#else
out vec2 vUv;
#endif
void main(){vec2 uv=position.xy*0.5+0.5;
#if KERNEL_SIZE == 3
vec2 s=resolution.zw*scale;vUv00=uv+s*vec2(-1.0,-1.0);vUv01=uv+s*vec2(0.0,-1.0);vUv02=uv+s*vec2(1.0,-1.0);vUv03=uv+s*vec2(-1.0,0.0);vUv04=uv;vUv05=uv+s*vec2(1.0,0.0);vUv06=uv+s*vec2(-1.0,1.0);vUv07=uv+s*vec2(0.0,1.0);vUv08=uv+s*vec2(1.0,1.0);
#elif KERNEL_SIZE == 5
vec2 s=resolution.zw*scale;vUv00=uv+s*vec2(-2.0,-2.0);vUv01=uv+s*vec2(-1.0,-2.0);vUv02=uv+s*vec2(0.0,-2.0);vUv03=uv+s*vec2(1.0,-2.0);vUv04=uv+s*vec2(2.0,-2.0);vUv05=uv+s*vec2(-2.0,-1.0);vUv06=uv+s*vec2(-1.0,-1.0);vUv07=uv+s*vec2(0.0,-1.0);vUv08=uv+s*vec2(1.0,-1.0);vUv09=uv+s*vec2(2.0,-1.0);vUv10=uv+s*vec2(-2.0,0.0);vUv11=uv+s*vec2(-1.0,0.0);vUv12=uv;vUv13=uv+s*vec2(1.0,0.0);vUv14=uv+s*vec2(2.0,0.0);vUv15=uv+s*vec2(-2.0,1.0);vUv16=uv+s*vec2(-1.0,1.0);vUv17=uv+s*vec2(0.0,1.0);vUv18=uv+s*vec2(1.0,1.0);vUv19=uv+s*vec2(2.0,1.0);vUv20=uv+s*vec2(-2.0,2.0);vUv21=uv+s*vec2(-1.0,2.0);vUv22=uv+s*vec2(0.0,2.0);vUv23=uv+s*vec2(1.0,2.0);vUv24=uv+s*vec2(2.0,2.0);
#else
vUv=uv;
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/BoxBlurMaterial.ts
var BoxBlurMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new box blur material.
   *
   * @param options - The options.
   */
  constructor({ bilateral = false, kernelSize = 5 } = {}) {
    super({
      name: "BoxBlurMaterial",
      fragmentShader: convolution_box_default,
      vertexShader: convolution_box_default2,
      defines: {
        DISTANCE_THRESHOLD: 0.1
      },
      uniforms: {
        depthBuffer: new Uniform23(null),
        normalDepthBuffer: new Uniform23(null),
        scale: new Uniform23(1)
      }
    });
    this.bilateral = bilateral;
    this.kernelSize = kernelSize;
    this.maxVaryingVectors = 8;
  }
  /**
   * The maximum amount of varying vectors.
   *
   * Should be synced with `renderer.capabilities.maxVaryings`.
   *
   * @defaultValue 8
   */
  set maxVaryingVectors(value) {
    this.defines.MAX_VARYING_VECTORS = value;
  }
  get kernelSize() {
    return this.defines.KERNEL_SIZE;
  }
  set kernelSize(value) {
    if (value % 2 === 0) {
      throw new Error("The kernel size must be an odd number");
    }
    this.defines.KERNEL_SIZE = value;
    this.defines.KERNEL_SIZE_HALF = Math.floor(value / 2);
    this.defines.KERNEL_SIZE_SQ = value ** 2;
    this.defines.KERNEL_SIZE_SQ_HALF = Math.floor(value ** 2 / 2);
    this.defines.INV_KERNEL_SIZE_SQ = 1 / value ** 2;
    this.needsUpdate = true;
  }
  /**
   * The blur scale.
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * The depth buffer.
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * A combined normal-depth buffer. Overrides {@link depthBuffer} if set.
   */
  set normalDepthBuffer(value) {
    this.uniforms.normalDepthBuffer.value = value;
    if (value !== null) {
      this.defines.NORMAL_DEPTH = true;
    } else {
      delete this.defines.NORMAL_DEPTH;
    }
    this.needsUpdate = true;
  }
  get bilateral() {
    return this.defines.BILATERAL !== void 0;
  }
  set bilateral(value) {
    if (value !== null) {
      this.defines.BILATERAL = true;
    } else {
      delete this.defines.BILATERAL;
    }
    this.needsUpdate = true;
  }
  /**
   * The bilateral filter distance threshold in world units.
   */
  get worldDistanceThreshold() {
    return -orthographicDepthToViewZ(this.defines.DISTANCE_THRESHOLD, this.near, this.far);
  }
  set worldDistanceThreshold(value) {
    const threshold = viewZToOrthographicDepth(-value, this.near, this.far);
    this.defines.DISTANCE_THRESHOLD = threshold;
    this.needsUpdate = true;
  }
};

// src/materials/BufferDebugMaterial.ts
import { Uniform as Uniform24 } from "three";

// src/materials/shaders/buffer-debug.frag
var buffer_debug_default = `#include <common>
#include <dithering_pars_fragment>
#include <packing>
#include <pp_camera_pars_fragment>
#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#include <pp_depth_buffer_pars_fragment>
#include <pp_depth_utils_pars_fragment>
#include <pp_normal_codec_pars_fragment>
#include <pp_normal_utils_pars_fragment>
#include <pp_world_utils_pars_fragment>
in vec2 vUv;void main(){
#if defined(DEPTH)
float depth=readDepth(depthBuffer,vUv);out_Color=vec4(vec3(depth),1.0);
#elif defined(NORMAL)
out_Color=vec4(readNormal(inputBuffer,vUv)*0.5+0.5,1.0);
#elif defined(POSITION)
float depth=readDepth(depthBuffer,vUv);vec3 viewPosition=getViewPosition(vUv,depth);out_Color=vec4(getWorldPosition(viewPosition),1.0);
#elif defined(DISTANCE)
float depth=readDepth(depthBuffer,vUv);vec3 viewPosition=getViewPosition(vUv,depth);const float scaleForVisualization=0.1;out_Color=vec4(vec3(getDistance(viewPosition)*scaleForVisualization),1.0);
#else
out_Color=texture(inputBuffer,vUv);
#ifdef COLOR_SPACE_CONVERSION
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
#endif
}`;

// src/materials/BufferDebugMaterial.ts
var BufferDebugMaterial = class extends FullscreenMaterial {
  /**
   * @see {@link bufferFocus}
   */
  _bufferFocus;
  /**
   * Constructs a new buffer debug material.
   */
  constructor() {
    super({
      name: "BufferDebugMaterial",
      fragmentShader: buffer_debug_default,
      vertexShader: common_default,
      uniforms: {
        depthBuffer: new Uniform24(null)
      }
    });
    this._bufferFocus = null;
  }
  /**
   * Sets the buffer focus.
   */
  get bufferFocus() {
    return this._bufferFocus;
  }
  set bufferFocus(value) {
    if (this._bufferFocus === value) {
      return;
    }
    if (this._bufferFocus !== null) {
      delete this.defines[this._bufferFocus];
    }
    if (value !== null) {
      value = value.toUpperCase();
      this.defines[value] = true;
    }
    this._bufferFocus = value;
    this.needsUpdate = true;
  }
  /**
   * A depth buffer.
   */
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * Indicates whether output color space conversion is enabled.
   */
  get colorSpaceConversion() {
    return this.defines.COLOR_SPACE_CONVERSION !== void 0;
  }
  set colorSpaceConversion(value) {
    if (this.colorSpaceConversion !== value) {
      if (value) {
        this.defines.COLOR_SPACE_CONVERSION = true;
      } else {
        delete this.defines.COLOR_SPACE_CONVERSION;
      }
      this.needsUpdate = true;
    }
  }
};

// src/materials/CircleOfConfusionMaterial.ts
import { Uniform as Uniform25 } from "three";

// src/materials/shaders/circle-of-confusion.frag
var circle_of_confusion_default = `#include <common>
#include <pp_camera_pars_fragment>
#include <pp_default_output_pars_fragment>
#include <pp_depth_buffer_pars_fragment>
#include <pp_depth_utils_pars_fragment>
uniform float focusDistance;uniform float focusRange;in vec2 vUv;void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraParams.x,cameraParams.y);depth=viewZToOrthographicDepth(viewZ,cameraParams.x,cameraParams.y);
#endif
float signedDistance=depth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));out_Color.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`;

// src/materials/CircleOfConfusionMaterial.ts
var CircleOfConfusionMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new circle of confusion material.
   */
  constructor() {
    super({
      name: "CircleOfConfusionMaterial",
      fragmentShader: circle_of_confusion_default,
      vertexShader: common_default,
      uniforms: {
        depthBuffer: new Uniform25(null),
        focusDistance: new Uniform25(0),
        focusRange: new Uniform25(0)
      }
    });
  }
  /**
   * The depth buffer.
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The focus distance. Range: [0.0, 1.0].
   */
  get focusDistance() {
    return this.uniforms.focusDistance.value;
  }
  set focusDistance(value) {
    this.uniforms.focusDistance.value = value;
  }
  /**
   * The focus distance in world units.
   */
  get worldFocusDistance() {
    return -orthographicDepthToViewZ(this.focusDistance, this.near, this.far);
  }
  set worldFocusDistance(value) {
    this.focusDistance = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * The focus range. Range: [0.0, 1.0].
   */
  get focusRange() {
    return this.uniforms.focusRange.value;
  }
  set focusRange(value) {
    this.uniforms.focusRange.value = value;
  }
  /**
   * The focus range in world units.
   */
  get worldFocusRange() {
    return -orthographicDepthToViewZ(this.focusRange, this.near, this.far);
  }
  set worldFocusRange(value) {
    this.focusRange = viewZToOrthographicDepth(-value, this.near, this.far);
  }
};

// src/materials/DepthCopyMaterial.ts
import { Uniform as Uniform26, Vector2 as Vector29 } from "three";

// src/materials/shaders/depth-copy.frag
var depth_copy_default = `#include <pp_default_output_pars_fragment>
in vec2 vUv;
#ifdef NORMAL_DEPTH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
#define getDepth(uv) texture(normalDepthBuffer, uv).a
#else
#include <pp_depth_buffer_pars_fragment>
#define getDepth(uv) texture(depthBuffer, uv).r
#endif
void main(){out_Color=vec4(getDepth(vUv));}`;

// src/materials/shaders/depth-copy.vert
var depth_copy_default2 = `out vec2 vUv;
#if DEPTH_COPY_MODE == 1
uniform vec2 texelPosition;
#endif
void main(){
#if DEPTH_COPY_MODE == 1
vUv=texelPosition;
#else
vUv=position.xy*0.5+0.5;
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/DepthCopyMaterial.ts
var DepthCopyMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new depth copy material.
   */
  constructor() {
    super({
      name: "DepthCopyMaterial",
      fragmentShader: depth_copy_default,
      vertexShader: depth_copy_default2,
      defines: {
        DEPTH_COPY_MODE: 0 /* FULL */
      },
      uniforms: {
        depthBuffer: new Uniform26(null),
        texelPosition: new Uniform26(new Vector29())
      }
    });
  }
  /**
   * The input depth buffer.
   */
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The screen space position used for single-texel copy operations.
   */
  get texelPosition() {
    return this.uniforms.texelPosition.value;
  }
  /**
   * The current depth copy mode.
   */
  get mode() {
    return this.defines.DEPTH_COPY_MODE;
  }
  set mode(value) {
    this.defines.DEPTH_COPY_MODE = value;
    this.needsUpdate = true;
  }
};

// src/materials/DepthDownsamplingMaterial.ts
import { Uniform as Uniform27 } from "three";

// src/materials/shaders/depth-downsampling.frag
var depth_downsampling_default = `#include <pp_default_output_pars_fragment>
#include <pp_depth_buffer_pars_fragment>
#include <pp_depth_utils_pars_fragment>
#include <packing>
#ifdef DOWNSAMPLE_NORMALS
uniform mediump sampler2D normalBuffer;
#endif
in vec2 vUv0,vUv1,vUv2,vUv3;int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture(normalBuffer,vUv0).rgb;n[1]=texture(normalBuffer,vUv1).rgb;n[2]=texture(normalBuffer,vUv2).rgb;n[3]=texture(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
out_Color=vec4(n[index],d[index]);}`;

// src/materials/shaders/depth-downsampling.vert
var depth_downsampling_default2 = `#include <pp_resolution_pars_fragment>
out vec2 vUv0,vUv1,vUv2,vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+resolution.w);vUv2=vec2(uv.x+resolution.z,uv.y);vUv3=uv+resolution.zw;gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/DepthDownsamplingMaterial.ts
var DepthDownsamplingMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new depth downsampling material.
   */
  constructor() {
    super({
      name: "DepthDownsamplingMaterial",
      fragmentShader: depth_downsampling_default,
      vertexShader: depth_downsampling_default2,
      uniforms: {
        depthBuffer: new Uniform27(null),
        normalBuffer: new Uniform27(null)
      }
    });
  }
  /**
   * The depth buffer.
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The normal buffer.
   */
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
    if (value !== null) {
      this.defines.DOWNSAMPLE_NORMALS = true;
    } else {
      delete this.defines.DOWNSAMPLE_NORMALS;
    }
    this.needsUpdate = true;
  }
};

// src/materials/EffectMaterial.ts
import { Uniform as Uniform28 } from "three";

// src/materials/shaders/effect.frag
var effect_default = `#include <common>
#include <dithering_pars_fragment>
#include <packing>
#include <pp_camera_pars_fragment>
#include <pp_colorspace_conversion_pars_fragment>
#include <pp_default_output_pars_fragment>
#include <pp_depth_buffer_precision_pars_fragment>
#include <pp_depth_utils_pars_fragment>
#include <pp_frame_buffer_precision_pars_fragment>
#include <pp_normal_codec_pars_fragment>
#include <pp_normal_utils_pars_fragment>
#include <pp_resolution_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
$FRAGMENT_HEAD_GDATA$FRAGMENT_HEAD_GBUFFER uniform GBuffer gBuffer;uniform float time;in vec2 vUv;$FRAGMENT_HEAD_EFFECTS void main(){$FRAGMENT_MAIN_UV$FRAGMENT_MAIN_GDATA vec4 color0=gData.color;vec4 color1=vec4(0.0);$FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);out_Color=color0;
#ifdef COLOR_SPACE_CONVERSION
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`;

// src/materials/shaders/effect.vert
var effect_default2 = `#include <pp_resolution_pars_fragment>
uniform vec3 cameraParams;uniform float time;out vec2 vUv;$VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;$VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/EffectMaterial.ts
var EffectMaterial = class extends FullscreenMaterial {
  /**
   * Keeps track of shader data.
   */
  shaderDataTracker;
  /**
   * Constructs a new effect material.
   */
  constructor() {
    super({
      name: "EffectMaterial",
      defines: {
        COLOR_SPACE_CONVERSION: true
      },
      uniforms: {
        gBuffer: new Uniform28(null),
        time: new Uniform28(0)
      }
    });
    this.shaderDataTracker = new ShaderDataTracker();
    this.fragmentShader = "#include <pp_default_output_pars_fragment>\n\n" + this.fragmentShader;
  }
  /**
   * The current gBuffer struct.
   */
  get gBuffer() {
    return this.uniforms.gBuffer.value;
  }
  set gBuffer(value) {
    this.uniforms.gBuffer.value = value;
  }
  /**
   * Indicates whether output color space conversion is enabled.
   */
  get colorSpaceConversion() {
    return this.defines.COLOR_SPACE_CONVERSION !== void 0;
  }
  set colorSpaceConversion(value) {
    if (this.colorSpaceConversion !== value) {
      if (value) {
        this.defines.COLOR_SPACE_CONVERSION = true;
      } else {
        delete this.defines.COLOR_SPACE_CONVERSION;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * The current animation time in seconds.
   */
  get time() {
    return this.uniforms.time.value;
  }
  set time(value) {
    this.uniforms.time.value = value;
  }
  /**
   * Sets the shader parts.
   *
   * @param shaderParts - A collection of shader code snippets. See {@link EffectShaderSection}.
   * @return This material.
   */
  setShaderParts(shaderParts) {
    this.fragmentShader = effect_default.replace("$FRAGMENT_MAIN_IMAGE" /* FRAGMENT_MAIN_IMAGE */, shaderParts.get("$FRAGMENT_MAIN_IMAGE" /* FRAGMENT_MAIN_IMAGE */)).replace("$FRAGMENT_MAIN_GDATA" /* FRAGMENT_MAIN_GDATA */, shaderParts.get("$FRAGMENT_MAIN_GDATA" /* FRAGMENT_MAIN_GDATA */)).replace("$FRAGMENT_MAIN_UV" /* FRAGMENT_MAIN_UV */, shaderParts.get("$FRAGMENT_MAIN_UV" /* FRAGMENT_MAIN_UV */)).replace("$FRAGMENT_HEAD_EFFECTS" /* FRAGMENT_HEAD_EFFECTS */, shaderParts.get("$FRAGMENT_HEAD_EFFECTS" /* FRAGMENT_HEAD_EFFECTS */)).replace("$FRAGMENT_HEAD_GBUFFER" /* FRAGMENT_HEAD_GBUFFER */, shaderParts.get("$FRAGMENT_HEAD_GBUFFER" /* FRAGMENT_HEAD_GBUFFER */)).replace("$FRAGMENT_HEAD_GDATA" /* FRAGMENT_HEAD_GDATA */, shaderParts.get("$FRAGMENT_HEAD_GDATA" /* FRAGMENT_HEAD_GDATA */));
    this.vertexShader = effect_default2.replace("$VERTEX_MAIN_SUPPORT" /* VERTEX_MAIN_SUPPORT */, shaderParts.get("$VERTEX_MAIN_SUPPORT" /* VERTEX_MAIN_SUPPORT */)).replace("$VERTEX_HEAD" /* VERTEX_HEAD */, shaderParts.get("$VERTEX_HEAD" /* VERTEX_HEAD */));
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader macros.
   *
   * Macros that have previously been set will be removed before the new ones are added.
   *
   * @param defines - A collection of preprocessor macro definitions.
   * @return This material.
   */
  setDefines(defines) {
    this.shaderDataTracker.applyDefines(this, defines).trackDefines(defines);
    return this;
  }
  /**
   * Sets the shader uniforms.
   *
   * Uniforms that have previously been set will be removed before the new ones are added.
   *
   * @param uniforms - A collection of uniforms.
   * @return This material.
   */
  setUniforms(uniforms) {
    this.shaderDataTracker.applyUniforms(this, uniforms).trackUniforms(uniforms);
    return this;
  }
  dispose() {
    super.dispose();
    this.shaderDataTracker.dispose();
  }
};

// src/materials/GaussianBlurMaterial.ts
import { Uniform as Uniform29, Vector2 as Vector210 } from "three";

// src/utils/GaussKernel.ts
function getCoefficients(n) {
  let result;
  if (n < 0) {
    throw new Error(`Invalid index: ${n}`);
  } else if (n === 0) {
    result = new Float64Array(0);
  } else if (n === 1) {
    result = new Float64Array([1]);
  } else {
    let row0 = new Float64Array(n);
    let row1 = new Float64Array(n);
    result = row1;
    for (let y = 1; y <= n; ++y) {
      for (let x = 0; x < y; ++x) {
        row1[x] = x === 0 || x === y - 1 ? 1 : row0[x - 1] + row0[x];
      }
      result = row1;
      row1 = row0;
      row0 = result;
    }
  }
  return result;
}
var GaussKernel = class {
  /**
   * The weights for discrete sampling.
   */
  weights;
  /**
   * The offsets for discrete sampling.
   */
  offsets;
  /**
   * The weights for linear sampling.
   */
  linearWeights;
  /**
   * The offsets for linear sampling.
   */
  linearOffsets;
  /**
   * Constructs a new Gauss kernel.
   *
   * @param kernelSize - The kernel size. Should be an odd number in the range [3, 1020].
   * @param edgeBias - Determines how many edge coefficients should be cut off for increased accuracy.
   */
  constructor(kernelSize, edgeBias = 2) {
    this.generate(kernelSize, edgeBias);
  }
  /**
   * The number of steps for discrete sampling.
   */
  get steps() {
    return this.offsets === null ? 0 : this.offsets.length;
  }
  /**
   * The number of steps for linear sampling.
   */
  get linearSteps() {
    return this.linearOffsets === null ? 0 : this.linearOffsets.length;
  }
  /**
   * Generates the kernel.
   *
   * @param kernelSize - The kernel size.
   * @param edgeBias - The amount of edge coefficients to ignore.
   */
  generate(kernelSize, edgeBias) {
    if (kernelSize < 3 || kernelSize > 1020) {
      throw new Error("The kernel size must be in the range [3, 1020]");
    }
    const n = kernelSize + edgeBias * 2;
    const coefficients = edgeBias > 0 ? getCoefficients(n).slice(edgeBias, -edgeBias) : getCoefficients(n);
    const mid = Math.floor((coefficients.length - 1) / 2);
    const sum = coefficients.reduce((a, b) => a + b, 0);
    const weights = coefficients.slice(mid);
    const offsets = [...Array(mid + 1).keys()];
    const linearWeights = new Float64Array(Math.floor(offsets.length / 2));
    const linearOffsets = new Float64Array(linearWeights.length);
    linearWeights[0] = weights[0] / sum;
    for (let i = 1, j = 1, l = offsets.length - 1; i < l; i += 2, ++j) {
      const offset0 = offsets[i], offset1 = offsets[i + 1];
      const weight0 = weights[i], weight1 = weights[i + 1];
      const w = weight0 + weight1;
      const o = (offset0 * weight0 + offset1 * weight1) / w;
      linearWeights[j] = w / sum;
      linearOffsets[j] = o;
    }
    for (let i = 0, l = weights.length, s = 1 / sum; i < l; ++i) {
      weights[i] *= s;
    }
    const linearWeightSum = (linearWeights.reduce((a, b) => a + b, 0) - linearWeights[0] * 0.5) * 2;
    if (linearWeightSum !== 0) {
      for (let i = 0, l = linearWeights.length, s = 1 / linearWeightSum; i < l; ++i) {
        linearWeights[i] *= s;
      }
    }
    this.weights = weights;
    this.offsets = new Float64Array(offsets);
    this.linearOffsets = linearOffsets;
    this.linearWeights = linearWeights;
  }
};

// src/materials/shaders/convolution.gaussian.frag
var convolution_gaussian_default = `#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
uniform vec2 kernel[STEPS];in vec2 vOffset;in vec2 vUv;void main(){vec4 result=texture(inputBuffer,vUv)*kernel[0].y;for(int i=1;i<STEPS;++i){vec2 offset=kernel[i].x*vOffset;vec4 c0=texture(inputBuffer,vUv+offset);vec4 c1=texture(inputBuffer,vUv-offset);result+=(c0+c1)*kernel[i].y;}out_Color=result;}`;

// src/materials/shaders/convolution.gaussian.vert
var convolution_gaussian_default2 = `#include <pp_resolution_pars_fragment>
uniform vec2 direction;uniform float scale;out vec2 vOffset;out vec2 vUv;void main(){vOffset=direction*resolution.zw*scale;vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/GaussianBlurMaterial.ts
var GaussianBlurMaterial = class extends FullscreenMaterial {
  /**
   * @see {@link kernelSize}
   */
  _kernelSize;
  /**
   * Constructs a new blur material.
   *
   * @param options - The options.
   */
  constructor({ kernelSize = 35 } = {}) {
    super({
      name: "GaussianBlurMaterial",
      fragmentShader: convolution_gaussian_default,
      vertexShader: convolution_gaussian_default2,
      defines: {
        STEPS: 0
      },
      uniforms: {
        direction: new Uniform29(new Vector210()),
        kernel: new Uniform29(null),
        scale: new Uniform29(1)
      }
    });
    this._kernelSize = 0;
    this.kernelSize = kernelSize;
  }
  get kernelSize() {
    return this._kernelSize;
  }
  set kernelSize(value) {
    this._kernelSize = value;
    this.generateKernel(value);
  }
  /**
   * The blur direction.
   */
  get direction() {
    return this.uniforms.direction.value;
  }
  /**
   * The blur kernel scale. Values greater than 1.0 may introduce artifacts.
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Generates the Gauss kernel.
   *
   * @param kernelSize - The kernel size.
   */
  generateKernel(kernelSize) {
    const kernel = new GaussKernel(kernelSize);
    const steps = kernel.linearSteps;
    const kernelData = new Float64Array(steps * 2);
    for (let i = 0, j = 0; i < steps; ++i) {
      kernelData[j++] = kernel.linearOffsets[i];
      kernelData[j++] = kernel.linearWeights[i];
    }
    this.uniforms.kernel.value = kernelData;
    this.defines.STEPS = steps;
    this.needsUpdate = true;
  }
};

// src/materials/KawaseBlurMaterial.ts
import { Uniform as Uniform30 } from "three";

// src/materials/shaders/convolution.kawase.frag
var convolution_kawase_default = `#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
in vec2 vUv0,vUv1,vUv2,vUv3;void main(){vec4 sum=texture(inputBuffer,vUv0);sum+=texture(inputBuffer,vUv1);sum+=texture(inputBuffer,vUv2);sum+=texture(inputBuffer,vUv3);out_Color=sum*0.25;}`;

// src/materials/shaders/convolution.kawase.vert
var convolution_kawase_default2 = `#include <pp_resolution_pars_fragment>
uniform float kernel;uniform float scale;out vec2 vUv0,vUv1,vUv2,vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.zw*vec2(kernel)+texelSize.zw*vec2(0.5))*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/KawaseBlurMaterial.ts
var kernelPresets = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
];
var KawaseBlurMaterial = class extends FullscreenMaterial {
  /**
   * The kernel size.
   */
  kernelSize;
  /**
   * Constructs a new blur material.
   */
  constructor() {
    super({
      name: "KawaseBlurMaterial",
      fragmentShader: convolution_kawase_default,
      vertexShader: convolution_kawase_default2,
      uniforms: {
        scale: new Uniform30(1),
        kernel: new Uniform30(0)
      }
    });
    this.kernelSize = 2 /* MEDIUM */;
  }
  /**
   * The kernel sequence for the current kernel size. Can be used to configure the {@link kernel}.
   */
  get kernelSequence() {
    return kernelPresets[this.kernelSize];
  }
  /**
   * The blur scale.
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * The current kernel. Can be configured using the {@link kernelSequence}.
   */
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(value) {
    this.uniforms.kernel.value = value;
  }
};

// src/materials/MaskMaterial.ts
import { Uniform as Uniform31, UnsignedByteType as UnsignedByteType8 } from "three";

// src/materials/shaders/mask.frag
var mask_default = `#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
in vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture(maskTexture,vUv).b;
#else
float mask=texture(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 3
vec4 texel=texture(inputBuffer,vUv);out_Color=vec4(mask*texel.rgb,texel.a);
#elif MASK_FUNCTION == 2
out_Color=vec4(mask*texture(inputBuffer,vUv).rgb,mask);
#else
out_Color=mask*texture(inputBuffer,vUv);
#endif
}`;

// src/materials/MaskMaterial.ts
var MaskMaterial = class extends FullscreenMaterial {
  /**
   * Constructs a new mask material.
   *
   * @param maskTexture - A mask texture.
   */
  constructor(maskTexture = null) {
    super({
      name: "MaskMaterial",
      fragmentShader: mask_default,
      vertexShader: common_default,
      defines: {
        COLOR_CHANNEL: 0 /* RED */,
        MASK_FUNCTION: 0 /* DISCARD */
      },
      uniforms: {
        maskTexture: new Uniform31(maskTexture),
        strength: new Uniform31(1)
      }
    });
  }
  /**
   * The mask texture.
   */
  set maskTexture(value) {
    this.uniforms.maskTexture.value = value;
    delete this.defines.MASK_PRECISION_HIGH;
    if (value?.type !== UnsignedByteType8) {
      this.defines.MASK_PRECISION_HIGH = true;
    }
    this.needsUpdate = true;
  }
  /**
   * The color channel to use for masking.
   *
   * @defaultValue ColorChannel.RED
   */
  get colorChannel() {
    return this.defines.COLOR_CHANNEL;
  }
  set colorChannel(value) {
    this.defines.COLOR_CHANNEL = value;
    this.needsUpdate = true;
  }
  /**
   * The masking technique.
   *
   * @defaultValue MaskFunction.DISCARD
   */
  get maskFunction() {
    return this.defines.MASK_FUNCTION;
  }
  set maskFunction(value) {
    this.defines.MASK_FUNCTION = value;
    this.needsUpdate = true;
  }
  /**
   * Indicates whether the masking is inverted.
   */
  get inverted() {
    return this.defines.INVERTED !== void 0;
  }
  set inverted(value) {
    if (this.inverted && !value) {
      delete this.defines.INVERTED;
    } else if (value) {
      this.defines.INVERTED = true;
    }
    this.needsUpdate = true;
  }
  /**
   * The current mask strength.
   *
   * Individual mask values will be clamped to [0.0, 1.0]. Has no effect when the mask function is set to `DISCARD`.
   *
   * @type {Number}
   */
  get strength() {
    return this.uniforms.strength.value;
  }
  set strength(value) {
    this.uniforms.strength.value = value;
  }
};

// src/materials/TiltShiftBlurMaterial.ts
import { Uniform as Uniform32, Vector2 as Vector211, Vector4 as Vector44 } from "three";

// src/materials/shaders/convolution.tilt-shift.frag
var convolution_tilt_shift_default = `#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
uniform vec4 maskParams;in vec2 vUv;in vec2 vUv2;in vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));out_Color=sum*0.25;}`;

// src/materials/shaders/convolution.tilt-shift.vert
var convolution_tilt_shift_default2 = `#include <pp_resolution_pars_fragment>
uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;out vec2 vUv;out vec2 vUv2;out vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.zw*vec2(kernel)+texelSize.zw*vec2(0.5))*scale;gl_Position=vec4(position.xy,1.0,1.0);}`;

// src/materials/TiltShiftBlurMaterial.ts
var TiltShiftBlurMaterial = class extends KawaseBlurMaterial {
  /**
   * @see {@link offset}
   */
  _offset;
  /**
   * @see {@link focusArea}
   */
  _focusArea;
  /**
   * @see {@link feather}
   */
  _feather;
  /**
   * Constructs a new tilt shift material.
   *
   * @param options - The options.
   */
  constructor({
    kernelSize = 2 /* MEDIUM */,
    offset = 0,
    rotation = 0,
    focusArea = 0.4,
    feather = 0.3
  } = {}) {
    super();
    this.fragmentShader = convolution_tilt_shift_default;
    this.vertexShader = convolution_tilt_shift_default2;
    this.uniforms.aspect = new Uniform32(1);
    this.uniforms.rotation = new Uniform32(new Vector211());
    this.uniforms.maskParams = new Uniform32(new Vector44());
    this._offset = offset;
    this._focusArea = focusArea;
    this._feather = feather;
    this.kernelSize = kernelSize;
    this.rotation = rotation;
    this.updateParams();
  }
  /**
   * The relative offset of the focus area.
   */
  updateParams() {
    const params = this.uniforms.maskParams.value;
    const a = Math.max(this.focusArea, 0);
    const b = Math.max(a - this.feather, 0);
    params.set(
      this.offset - a,
      this.offset - b,
      this.offset + a,
      this.offset + b
    );
  }
  get rotation() {
    const rotation = this.uniforms.rotation.value;
    return Math.acos(rotation.x);
  }
  set rotation(value) {
    const rotation = this.uniforms.rotation.value;
    rotation.set(Math.cos(value), Math.sin(value));
  }
  get offset() {
    return this._offset;
  }
  set offset(value) {
    this._offset = value;
    this.updateParams();
  }
  get focusArea() {
    return this._focusArea;
  }
  set focusArea(value) {
    this._focusArea = value;
    this.updateParams();
  }
  get feather() {
    return this._feather;
  }
  set feather(value) {
    this._feather = value;
    this.updateParams();
  }
  setSize(width, height) {
    super.setSize(width, height);
    this.uniforms.aspect.value = width / height;
  }
};

// src/passes/BufferDebugPass.ts
import {
  Mesh as Mesh3,
  MeshBasicMaterial,
  OrthographicCamera as OrthographicCamera5,
  PlaneGeometry as PlaneGeometry2,
  Scene as Scene5
} from "three";
var BufferDebugPass = class extends Pass {
  /**
   * The size of each texture view relative to the screen size.
   *
   * @defaultValue 0.1
   */
  viewSize;
  /**
   * Limits the amount of texture views per row.
   *
   * @defaultValue 4
   */
  columns;
  /**
   * @see {@link bufferFocus}
   */
  _bufferFocus;
  /**
   * A list of meshes that are used to render the input textures.
   */
  views;
  /**
   * A scene that contains the debug meshes.
   */
  debugScene;
  /**
   * A debug camera.
   */
  debugCamera;
  /**
   * Constructs a new buffer debug pass.
   *
   * @param gBufferComponents - G-Buffer components that should be rendered and visualized.
   */
  constructor(gBufferComponents) {
    super("BufferDebugPass");
    this.output.defaultBuffer = this.createFramebuffer();
    this.fullscreenMaterial = new BufferDebugMaterial();
    this.viewSize = 0.1;
    this.columns = 4;
    this.views = [];
    this._bufferFocus = null;
    this.debugScene = new Scene5();
    this.debugCamera = new OrthographicCamera5(-1, 1, 1, -1, 0, 1);
    if (gBufferComponents !== void 0) {
      for (const component of gBufferComponents) {
        this.input.gBuffer.add(component);
      }
    }
  }
  /**
   * The name of the buffer that should be rendered in fullscreen mode.
   *
   * The value must match with one of the buffer names. G-Buffer textures use the string value of the respective
   * {@link GBuffer} component as their name.
   *
   * @see {@link GBuffer} for rendering specific G-Buffer components.
   * @see {@link GBufferDebug} for computed G-Buffer components.
   */
  get bufferFocus() {
    return this._bufferFocus;
  }
  set bufferFocus(value) {
    this._bufferFocus = value;
    this.updateInputBuffer();
  }
  /**
   * Sets the input buffer based on the currently selected buffer.
   */
  updateInputBuffer() {
    const material = this.fullscreenMaterial;
    material.bufferFocus = this.bufferFocus;
    if (this.bufferFocus !== null && this.input.buffers.has(this.bufferFocus)) {
      material.inputBuffer = this.input.getBuffer(this.bufferFocus);
      material.colorSpaceConversion = false;
    } else {
      material.inputBuffer = this.input.defaultBuffer?.value ?? null;
      material.colorSpaceConversion = true;
    }
  }
  /**
   * Updates the texture views.
   */
  updateViews() {
    const { width, height } = this.resolution;
    const size = Math.min(Math.max(this.viewSize, 0), 1);
    const columns = Math.max(this.columns, 0);
    const views = this.views;
    const rows = Math.ceil(views.length / columns);
    if (views.length * size > 1 || views.length / rows * size > 1) {
      console.warn("Unable to fit texture views");
      return;
    }
    const sizeHalf = size * 0.5;
    const viewSizeX = size * width;
    const viewSizeY = size * height;
    const startX = width - sizeHalf * width;
    let offsetX = startX;
    let offsetY = sizeHalf * height;
    for (let i = 0, l = views.length, y = 0; y < rows; ++y) {
      for (let x = 0; x < columns && i < l; ++x, ++i) {
        const view = views[i];
        this.debugScene.add(view);
        view.scale.set(viewSizeX, viewSizeY, 1);
        view.position.set(offsetX, offsetY, 0);
        offsetX -= viewSizeX;
      }
      offsetX = startX;
      offsetY += viewSizeY;
    }
  }
  onResolutionChange() {
    const { width, height } = this.resolution;
    const debugCamera = this.debugCamera;
    debugCamera.left = 0;
    debugCamera.right = width;
    debugCamera.top = height;
    debugCamera.bottom = 0;
    debugCamera.updateProjectionMatrix();
    this.updateViews();
  }
  onInputChange() {
    this.fullscreenMaterial.depthBuffer = this.input.getBuffer("Depth" /* DEPTH */);
    for (const view of this.views) {
      view.geometry.dispose();
      this.debugScene.remove(view);
    }
    const capturedTextures = /* @__PURE__ */ new WeakSet();
    this.views = [];
    for (const entry of this.input.textures) {
      if (entry[0] === Input.BUFFER_DEFAULT || entry[1] === null || capturedTextures.has(entry[1].value)) {
        continue;
      }
      const view = new Mesh3(
        new PlaneGeometry2(),
        new MeshBasicMaterial({
          map: entry[1].value
        })
      );
      view.material.onBeforeCompile = (parameters) => {
        parameters.fragmentShader = parameters.fragmentShader.replace("#include <colorspace_fragment>", "");
      };
      view.name = entry[0];
      this.views.push(view);
      capturedTextures.add(entry[1].value);
    }
    this.updateViews();
    this.updateInputBuffer();
  }
  render() {
    this.setRenderTarget(this.output.defaultBuffer?.value);
    this.renderFullscreen();
    this.renderer?.render(this.debugScene, this.debugCamera);
  }
};

// src/passes/DepthDownsamplingPass.ts
import { FloatType as FloatType5, NearestFilter as NearestFilter4, WebGLRenderTarget as WebGLRenderTarget6 } from "three";
var DepthDownsamplingPass = class _DepthDownsamplingPass extends Pass {
  /**
   * Identifies the depth output buffer.
   */
  static BUFFER_DEPTH = "BUFFER_DEPTH";
  /**
   * Constructs a new depth downsampling pass.
   */
  constructor() {
    super("DepthDownsamplingPass");
    this.fullscreenMaterial = new DepthDownsamplingMaterial();
    this.input.gBuffer.add("Depth" /* DEPTH */);
    this.input.gBuffer.add("Normal" /* NORMAL */);
    this.output.setBuffer(
      _DepthDownsamplingPass.BUFFER_DEPTH,
      new WebGLRenderTarget6(1, 1, {
        minFilter: NearestFilter4,
        magFilter: NearestFilter4,
        depthBuffer: false,
        type: FloatType5
      })
    );
  }
  /**
   * The depth render target.
   */
  get renderTarget() {
    return this.output.getBuffer(_DepthDownsamplingPass.BUFFER_DEPTH);
  }
  /**
   * The output texture.
   */
  get texture() {
    return this.output.buffers.get(_DepthDownsamplingPass.BUFFER_DEPTH).texture;
  }
  onInputChange() {
    this.fullscreenMaterial.depthBuffer = this.input.getBuffer("Depth" /* DEPTH */);
    this.fullscreenMaterial.normalBuffer = this.input.getBuffer("Normal" /* NORMAL */);
    this.onResolutionChange();
  }
  onResolutionChange() {
    const inputBuffer = this.input.defaultBuffer?.value ?? null;
    if (inputBuffer === null) {
      return;
    }
    const imgData = inputBuffer.source.data;
    const { width, height } = imgData;
    this.fullscreenMaterial.setSize(width, height);
  }
  checkRequirements() {
    if (this.renderer === null) {
      return;
    }
    const gl = this.renderer.getContext();
    const renderable = gl.getExtension("EXT_color_buffer_float") ?? gl.getExtension("EXT_color_buffer_half_float");
    if (!renderable) {
      throw new Error("Rendering to a float texture is not supported");
    }
  }
  render() {
    this.setRenderTarget(this.renderTarget);
    this.renderFullscreen();
  }
};

// src/passes/DepthCopyPass.ts
import { FloatType as FloatType6, NearestFilter as NearestFilter5, WebGLRenderTarget as WebGLRenderTarget7 } from "three";
var DepthCopyPass = class _DepthCopyPass extends Pass {
  /**
   * Identifies the depth output buffer.
   */
  static BUFFER_DEPTH = "BUFFER_DEPTH";
  /**
   * Constructs a new depth copy pass.
   */
  constructor() {
    super("DepthCopyPass");
    this.fullscreenMaterial = new DepthCopyMaterial();
    this.input.gBuffer.add("Depth" /* DEPTH */);
    this.output.setBuffer(_DepthCopyPass.BUFFER_DEPTH, new WebGLRenderTarget7(1, 1, {
      minFilter: NearestFilter5,
      magFilter: NearestFilter5,
      depthBuffer: false,
      type: FloatType6
    }));
  }
  /**
   * The depth render target.
   */
  get renderTarget() {
    return this.output.getBuffer(_DepthCopyPass.BUFFER_DEPTH);
  }
  /**
   * The output texture.
   */
  get texture() {
    return this.output.buffers.get(_DepthCopyPass.BUFFER_DEPTH).texture;
  }
  /**
   * The current depth copy mode.
   */
  get mode() {
    return this.fullscreenMaterial.mode;
  }
  set mode(value) {
    this.fullscreenMaterial.mode = value;
    if (value === 1 /* SINGLE */) {
      this.resolution.setPreferredSize(1, 1);
    } else {
      this.resolution.resetPreferredSize();
    }
  }
  onInputChange() {
    this.fullscreenMaterial.depthBuffer = this.input.getBuffer("Depth" /* DEPTH */);
  }
  onResolutionChange() {
    const resolution = this.resolution;
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
  render() {
    this.setRenderTarget(this.renderTarget);
    this.renderFullscreen();
  }
};

// src/passes/DepthPickingPass.ts
var pixelBuffer = new Float32Array(4);
var DepthPickingPass = class extends DepthCopyPass {
  /**
   * A callback that handles picking results.
   */
  callback;
  /**
   * Constructs a new depth picking pass.
   *
   * @param mode - The depth copy mode.
   */
  constructor(mode = 1 /* SINGLE */) {
    super();
    this.name = "DepthPickingPass";
    this.fullscreenMaterial.mode = mode;
    this.callback = null;
    this.mode = mode;
  }
  /**
   * Reads depth at a specific texture position.
   *
   * @param x - The X-coordinate.
   * @param x - The Y-coordinate.
   * @return The depth value.
   */
  readDepthAt(x, y) {
    const renderer = this.renderer;
    if (renderer === null) {
      return 0;
    }
    renderer.readRenderTargetPixels(this.renderTarget, x, y, 1, 1, pixelBuffer);
    const depth = pixelBuffer[0];
    if (renderer.capabilities.reversedDepthBuffer) {
      return 1 - depth;
    } else if (renderer.capabilities.logarithmicDepthBuffer) {
      if (this.camera === null) {
        return 0;
      }
      const camera = this.camera;
      const d = Math.pow(2, depth * Math.log2(camera.far + 1)) - 1;
      const a = camera.far / (camera.far - camera.near);
      const b = camera.far * camera.near / (camera.near - camera.far);
      return a + b / d;
    }
    return depth;
  }
  /**
   * Reads depth at a specific screen position.
   *
   * If the mode is set to {@link DepthCopyMode.SINGLE}, only one depth value can be picked per frame. Calling this
   * method multiple times per frame will then overwrite the picking coordinates. Unresolved promises will be abandoned.
   *
   * @param ndc - Normalized device coordinates. Only X and Y are relevant.
   * @return A promise that returns the depth.
   * @example
   * const ndc = new Vector3();
   * const clientRect = myViewport.getBoundingClientRect();
   * const clientX = pointerEvent.clientX - clientRect.left;
   * const clientY = pointerEvent.clientY - clientRect.top;
   * ndc.x = (clientX / myViewport.clientWidth) * 2.0 - 1.0;
   * ndc.y = -(clientY / myViewport.clientHeight) * 2.0 + 1.0;
   * const depth = await depthPickingPass.readDepth(ndc);
   * ndc.z = depth * 2.0 - 1.0;
   * const worldPosition = ndc.unproject(camera);
   */
  readDepth(ndc) {
    this.fullscreenMaterial.texelPosition.set(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);
    return new Promise((resolve) => {
      if (this.fullscreenMaterial.mode === 1 /* SINGLE */) {
        this.callback = resolve;
      } else {
        const renderTarget = this.renderTarget;
        const texelPosition = this.fullscreenMaterial.texelPosition;
        const x = Math.round(texelPosition.x * renderTarget.width);
        const y = Math.round(texelPosition.y * renderTarget.height);
        resolve(this.readDepthAt(x, y));
      }
    });
  }
  render() {
    if (this.fullscreenMaterial.mode === 0 /* FULL */) {
      super.render();
    } else if (this.callback !== null) {
      super.render();
      this.callback(this.readDepthAt(0, 0));
      this.callback = null;
    }
  }
};

// src/utils/EffectMaterialManager.ts
import { SRGBColorSpace as SRGBColorSpace5 } from "three";

// src/utils/EffectShaderData.ts
import { LinearSRGBColorSpace, NoColorSpace as NoColorSpace3, SRGBColorSpace as SRGBColorSpace4 } from "three";

// src/utils/functions/string.ts
function prefixSubstrings(prefix, substrings, namedValues) {
  for (const substring of substrings) {
    const prefixed = "$1" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);
    const regExp = new RegExp("([^\\.])(\\b" + substring + "\\b)", "g");
    for (const entry of namedValues.entries()) {
      if (typeof entry[1] === "string") {
        namedValues.set(entry[0], entry[1].replace(regExp, prefixed));
      }
    }
  }
}

// src/utils/functions/sorting.ts
function dfs(vertex, graph, visited, result) {
  visited.add(vertex);
  for (const neighbor of graph.get(vertex) ?? []) {
    if (!visited.has(neighbor)) {
      dfs(neighbor, graph, visited, result);
    }
  }
  result.push(vertex);
}
function topologicalSort(graph, desc = false) {
  const result = [];
  const visited = /* @__PURE__ */ new Set();
  for (const vertex of graph.keys()) {
    if (!visited.has(vertex)) {
      dfs(vertex, graph, visited, result);
    }
  }
  return desc ? result : result.reverse();
}

// src/utils/EffectShaderData.ts
var functionRegExp = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g;
var structRegExp = /struct\s+(\w*)/g;
var defineRegExp = /^\s*#define\s+(\w*)/gm;
var EffectShaderData = class {
  defines;
  uniforms;
  /**
   * The shader parts.
   */
  shaderParts;
  /**
   * The blend modes of the individual effects.
   */
  blendModes;
  /**
   * A collection of required G-Buffer data.
   */
  gData;
  /**
   * A list of effects that use convolution operations.
   */
  convolutionEffects;
  /**
   * A list of effects that transform UV coordinates in the fragment shader.
   */
  uvTransformationEffects;
  /**
   * @see {@link colorSpace}
   */
  _colorSpace;
  /**
   * Constructs new shader data.
   */
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([
      ["$FRAGMENT_HEAD_EFFECTS" /* FRAGMENT_HEAD_EFFECTS */, ""],
      ["$FRAGMENT_HEAD_GBUFFER" /* FRAGMENT_HEAD_GBUFFER */, ""],
      ["$FRAGMENT_HEAD_GDATA" /* FRAGMENT_HEAD_GDATA */, ""],
      ["$FRAGMENT_MAIN_UV" /* FRAGMENT_MAIN_UV */, ""],
      ["$FRAGMENT_MAIN_GDATA" /* FRAGMENT_MAIN_GDATA */, ""],
      ["$FRAGMENT_MAIN_IMAGE" /* FRAGMENT_MAIN_IMAGE */, ""],
      ["$VERTEX_HEAD" /* VERTEX_HEAD */, ""],
      ["$VERTEX_MAIN_SUPPORT" /* VERTEX_MAIN_SUPPORT */, ""]
    ]);
    this.defines = /* @__PURE__ */ new Map();
    this.uniforms = /* @__PURE__ */ new Map();
    this.blendModes = /* @__PURE__ */ new Map();
    this.gData = /* @__PURE__ */ new Set(["color" /* COLOR */]);
    this.convolutionEffects = /* @__PURE__ */ new Set();
    this.uvTransformationEffects = /* @__PURE__ */ new Set();
    this._colorSpace = LinearSRGBColorSpace;
  }
  /**
   * Indicates whether any effect transforms UV coordinates in the fragment shader.
   */
  get uvTransformation() {
    return this.uvTransformationEffects.size > 0;
  }
  /**
   * The effective output color space of this effect shader data.
   */
  get colorSpace() {
    return this._colorSpace;
  }
  set colorSpace(value) {
    this._colorSpace = value;
  }
  /**
   * Extracts token names from a given vertex shader.
   *
   * @param prefix - A prefix.
   * @param shader - The vertex shader.
   * @param names - A set to be filled with the tokens.
   */
  gatherVertexShaderTokens(shader, names) {
    for (const m of shader.matchAll(/(?:out\s+\w+\s+(\w*?);)/g)) {
      for (const n of m[1].split(/\s*,\s*/)) {
        names.add(n);
      }
    }
    for (const m of shader.matchAll(functionRegExp)) {
      names.add(m[1]);
    }
    for (const m of shader.matchAll(structRegExp)) {
      names.add(m[1]);
    }
    for (const m of shader.matchAll(defineRegExp)) {
      names.add(m[1]);
    }
  }
  /**
   * Extracts token names from a given fragment shader.
   *
   * @param prefix - A prefix.
   * @param shader - The fragment shader.
   * @param names - A set to be filled with the tokens.
   */
  gatherFragmentShaderTokens(shader, names) {
    for (const m of shader.matchAll(functionRegExp)) {
      names.add(m[1]);
    }
    for (const m of shader.matchAll(structRegExp)) {
      names.add(m[1]);
    }
    for (const m of shader.matchAll(defineRegExp)) {
      names.add(m[1]);
    }
  }
  /**
   * Updates the current working color space based on the given effect.
   *
   * @param effect - The effect.
   */
  updateWorkingColorSpace(effect) {
    if (effect.outputColorSpace !== NoColorSpace3) {
      this.colorSpace = effect.outputColorSpace;
    } else if (effect.inputColorSpace !== NoColorSpace3) {
      this.colorSpace = effect.inputColorSpace;
    }
  }
  /**
   * Integrates the given effect by collecting relevant shader data.
   *
   * @param prefix - A prefix.
   * @param effect - The effect.
   * @throws If the effect is invalid.
   */
  integrateEffect(prefix, effect) {
    effect.validate();
    if (effect.isConvolutionPass(false)) {
      this.convolutionEffects.add(effect);
    }
    let fragmentShader = effect.fragmentShader;
    let vertexShader = effect.vertexShader;
    const shaderParts = this.shaderParts;
    let fragmentHead = shaderParts.get("$FRAGMENT_HEAD_EFFECTS" /* FRAGMENT_HEAD_EFFECTS */);
    let fragmentMainUv = shaderParts.get("$FRAGMENT_MAIN_UV" /* FRAGMENT_MAIN_UV */);
    let fragmentMainImage = shaderParts.get("$FRAGMENT_MAIN_IMAGE" /* FRAGMENT_MAIN_IMAGE */);
    let vertexHead = shaderParts.get("$VERTEX_HEAD" /* VERTEX_HEAD */);
    let vertexMainSupport = shaderParts.get("$VERTEX_MAIN_SUPPORT" /* VERTEX_MAIN_SUPPORT */);
    const names = /* @__PURE__ */ new Set();
    if (vertexShader !== null && effect.hasMainSupportFunction) {
      this.gatherVertexShaderTokens(vertexShader, names);
      const needsUv = /mainSupport\s*\([\w\s]*?uv\s*?\)/.test(vertexShader);
      vertexMainSupport += `	${prefix}MainSupport(`;
      vertexMainSupport += needsUv ? "vUv);\n" : ");\n";
    }
    if (effect.hasMainUvFunction) {
      fragmentMainUv += `	${prefix}MainUv(UV);
`;
      this.uvTransformationEffects.add(effect);
    }
    for (const gData of effect.gData) {
      this.gData.add(gData);
    }
    if (effect.hasMainImageFunction) {
      this.gatherFragmentShaderTokens(fragmentShader, names);
      if (effect.inputColorSpace !== NoColorSpace3 && effect.inputColorSpace !== this.colorSpace) {
        fragmentMainImage += effect.inputColorSpace === SRGBColorSpace4 ? "color0 = sRGBTransferOETF(color0);\n	" : "color0 = sRGBToLinear(color0);\n	";
      }
      fragmentMainImage += `color1 = ${prefix}MainImage(color0, UV, gData);
	`;
      const blendMode = effect.blendMode;
      this.blendModes.set(blendMode.blendFunction.id, blendMode);
      const blendOpacity = prefix + "BlendOpacity";
      this.uniforms.set(blendOpacity, blendMode.opacityUniform);
      fragmentMainImage += `color0 = blend${blendMode.blendFunction.id}(color0, color1, ${blendOpacity});

	`;
      fragmentHead += `uniform float ${blendOpacity};

`;
      this.updateWorkingColorSpace(effect);
    }
    for (const d of effect.input.defines.keys()) {
      names.add(d.replace(/\([\w\s,]*\)/g, ""));
    }
    for (const u of effect.input.uniforms.keys()) {
      names.add(u);
    }
    names.delete("while");
    names.delete("for");
    names.delete("if");
    effect.input.uniforms.forEach((v3, k) => this.uniforms.set(prefix + k.charAt(0).toUpperCase() + k.slice(1), v3));
    effect.input.defines.forEach((v3, k) => this.defines.set(prefix + k.charAt(0).toUpperCase() + k.slice(1), v3));
    const shaders = /* @__PURE__ */ new Map([["fragment", fragmentShader], ["vertex", vertexShader]]);
    prefixSubstrings(prefix, names, this.defines);
    prefixSubstrings(prefix, names, shaders);
    fragmentShader = shaders.get("fragment");
    vertexShader = shaders.get("vertex");
    fragmentHead += fragmentShader + "\n";
    if (vertexShader !== null) {
      vertexHead += vertexShader + "\n";
    }
    shaderParts.set("$FRAGMENT_HEAD_EFFECTS" /* FRAGMENT_HEAD_EFFECTS */, fragmentHead);
    shaderParts.set("$FRAGMENT_MAIN_UV" /* FRAGMENT_MAIN_UV */, fragmentMainUv);
    shaderParts.set("$FRAGMENT_MAIN_IMAGE" /* FRAGMENT_MAIN_IMAGE */, fragmentMainImage);
    shaderParts.set("$VERTEX_HEAD" /* VERTEX_HEAD */, vertexHead);
    shaderParts.set("$VERTEX_MAIN_SUPPORT" /* VERTEX_MAIN_SUPPORT */, vertexMainSupport);
    this.validate();
  }
  /**
   * Adds the given effect shader data to this data.
   *
   * @param data - The data to add.
   * @throws If the data cannot be merged.
   */
  add(data) {
    data.convolutionEffects.forEach((v3) => this.convolutionEffects.add(v3));
    data.uvTransformationEffects.forEach((v3) => this.uvTransformationEffects.add(v3));
    data.uniforms.forEach((v3, k) => this.uniforms.set(k, v3));
    data.defines.forEach((v3, k) => this.defines.set(k, v3));
    data.blendModes.forEach((v3, k) => this.blendModes.set(k, v3));
    data.gData.forEach((v3) => this.gData.add(v3));
    const shaderParts = this.shaderParts;
    let fragmentHead = shaderParts.get("$FRAGMENT_HEAD_EFFECTS" /* FRAGMENT_HEAD_EFFECTS */);
    let fragmentMainUv = shaderParts.get("$FRAGMENT_MAIN_UV" /* FRAGMENT_MAIN_UV */);
    let fragmentMainImage = shaderParts.get("$FRAGMENT_MAIN_IMAGE" /* FRAGMENT_MAIN_IMAGE */);
    let vertexHead = shaderParts.get("$VERTEX_HEAD" /* VERTEX_HEAD */);
    let vertexMainSupport = shaderParts.get("$VERTEX_MAIN_SUPPORT" /* VERTEX_MAIN_SUPPORT */);
    fragmentHead += data.shaderParts.get("$FRAGMENT_HEAD_EFFECTS" /* FRAGMENT_HEAD_EFFECTS */);
    fragmentMainUv += data.shaderParts.get("$FRAGMENT_MAIN_UV" /* FRAGMENT_MAIN_UV */);
    fragmentMainImage += data.shaderParts.get("$FRAGMENT_MAIN_IMAGE" /* FRAGMENT_MAIN_IMAGE */);
    vertexHead += data.shaderParts.get("$VERTEX_HEAD" /* VERTEX_HEAD */);
    vertexMainSupport += data.shaderParts.get("$VERTEX_MAIN_SUPPORT" /* VERTEX_MAIN_SUPPORT */);
    shaderParts.set("$FRAGMENT_HEAD_EFFECTS" /* FRAGMENT_HEAD_EFFECTS */, fragmentHead);
    shaderParts.set("$FRAGMENT_MAIN_UV" /* FRAGMENT_MAIN_UV */, fragmentMainUv);
    shaderParts.set("$FRAGMENT_MAIN_IMAGE" /* FRAGMENT_MAIN_IMAGE */, fragmentMainImage);
    shaderParts.set("$VERTEX_HEAD" /* VERTEX_HEAD */, vertexHead);
    shaderParts.set("$VERTEX_MAIN_SUPPORT" /* VERTEX_MAIN_SUPPORT */, vertexMainSupport);
    if (this.colorSpace !== data.colorSpace && data.colorSpace !== NoColorSpace3) {
      this.colorSpace = data.colorSpace;
    }
    this.validate();
  }
  /**
   * Checks if this data is valid.
   *
   * @throws If the data is invalid.
   */
  validate() {
    if (this.convolutionEffects.size > 1) {
      const effectNames = [...this.convolutionEffects].map((x) => x.name).join(", ");
      throw new Error(`Convolution effects cannot be merged (${effectNames})`);
    } else if (this.convolutionEffects.size > 0 && this.uvTransformation) {
      const effectNames = [...this.convolutionEffects, ...this.uvTransformationEffects].map((x) => x.name).join(", ");
      throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effectNames})`);
    }
  }
  /**
   * Creates shader code for a `GData` struct declaration.
   *
   * @param gBufferConfig - A G-Buffer config.
   * @return The shader code.
   */
  createGDataStructDeclaration(gBufferConfig) {
    return [
      "struct GData {",
      ...Array.from(gBufferConfig.gDataStructDeclaration).filter((x) => this.gData.has(x[0])).map((x) => `	${x[1]}`),
      "};\n"
    ].join("\n");
  }
  /**
   * Creates shader code for the `GData` struct initialization.
   *
   * @param gBufferConfig - A G-Buffer config.
   * @return The shader code.
   */
  createGDataStructInitialization(gBufferConfig) {
    const gDataDependencies = gBufferConfig.gDataDependencies;
    const gDataStructInitialization = gBufferConfig.gDataStructInitialization;
    const dependencyGraph = new Map(
      Array.from(this.gData).filter((x) => gDataStructInitialization.has(x)).map((x) => [x, gDataDependencies.get(x) ?? []])
    );
    return [
      "	GData gData;",
      ...topologicalSort(dependencyGraph, true).map((x) => `	${gDataStructInitialization.get(x)}`)
    ].join("\n");
  }
  /**
   * Creates the relevant blend function declarations.
   *
   * @return The shader code.
   */
  createBlendFunctions() {
    const blendRegExp = /\bblend\b/g;
    const parts = [];
    for (const blendMode of this.blendModes.values()) {
      const blendFunctionShader = blendMode.blendFunction.shader;
      const blendFunctionName = `blend${blendMode.blendFunction.id}`;
      parts.push(blendFunctionShader.replace(blendRegExp, blendFunctionName));
    }
    return parts.join("\n");
  }
};

// src/utils/EffectMaterialManager.ts
var EffectMaterialManager = class _EffectMaterialManager {
  /**
   * The maximum number of optional effects.
   *
   * If there are too many optional effects, materials will not be created ahead of time.
   */
  static MAX_OPTIONAL_EFFECTS = 6;
  /**
   * The ID of the default material.
   */
  static DEFAULT_MATERIAL_ID = "default";
  /**
   * A collection of shader data that will be applied to new materials.
   */
  shaderData;
  /**
   * A default effect material.
   *
   * The base `uniforms` and `defines` of this material are shared between all materials.
   */
  defaultMaterial;
  /**
   * A collection that maps combined effect IDs to effect materials.
   */
  materialCache;
  /**
   * A collection that maps effects to extracted shader data for integration into materials.
   */
  effectShaderDataCache;
  /**
   * A material that is currently active.
   */
  activeMaterial;
  // #region Backing Data
  /**
   * @see {@link gBufferConfig}
   */
  _gBufferConfig;
  /**
   * @see {@link gBufferConfig}
   */
  _gBuffer;
  /**
   * @see {@link dithering}
   */
  _dithering;
  // #endregion
  /**
   * Constructs a new effect material manager.
   *
   * @param shaderData - A collection of shader data that will be applied to new materials.
   */
  constructor(shaderData) {
    this.shaderData = shaderData;
    this.defaultMaterial = new EffectMaterial();
    this.materialCache = /* @__PURE__ */ new Map();
    this.effectShaderDataCache = /* @__PURE__ */ new Map();
    this.activeMaterial = null;
    this._gBufferConfig = null;
    this._gBuffer = null;
    this._dithering = false;
  }
  /**
   * The current materials.
   */
  get materials() {
    return this.materialCache.values();
  }
  /**
   * The current G-Buffer configuration.
   *
   * Assigning a new configuration will invalidate all caches.
   */
  get gBufferConfig() {
    return this._gBufferConfig;
  }
  set gBufferConfig(value) {
    if (this._gBufferConfig !== value) {
      this.dispose();
      this._gBufferConfig = value;
    }
  }
  /**
   * The current input G-Buffer components.
   *
   * Assigning a new G-Buffer will invalidate the material cache.
   */
  get gBuffer() {
    return this._gBuffer;
  }
  set gBuffer(value) {
    if (this._gBuffer !== value) {
      this.invalidateMaterialCache();
      this._gBuffer = value;
    }
  }
  /**
   * Indicates whether dithering is enabled.
   */
  get dithering() {
    return this._dithering;
  }
  set dithering(value) {
    if (this._dithering === value) {
      return;
    }
    this._dithering = value;
    for (const material of this.materialCache.values()) {
      if (value && material.outputPrecision !== "lowp") {
        console.info("Dithering only works on 8-bit colors");
        break;
      } else {
        material.dithering = value;
        material.needsUpdate = true;
      }
    }
  }
  /**
   * Creates effect shader data based on the given effects.
   *
   * @param effects - The effects.
   * @return The shader data.
   * @throws If the current effects cannot be merged.
   */
  getEffectShaderData(effects) {
    const result = new EffectShaderData();
    const effectShaderDataCache = this.effectShaderDataCache;
    for (const effect of effects) {
      if (!effectShaderDataCache.has(effect)) {
        const data = new EffectShaderData();
        data.integrateEffect(`e${effect.id}`, effect);
        effectShaderDataCache.set(effect, data);
      }
      if (effect.blendMode.blendFunction.shader !== null) {
        result.add(effectShaderDataCache.get(effect));
      }
    }
    return result;
  }
  /**
   * Creates shader code for a `GBuffer` struct declaration.
   *
   * @param gBufferConfig - A G-Buffer config.
   * @return The shader code.
   */
  createGBufferStructDeclaration(gBufferConfig) {
    if (this.gBuffer === null) {
      throw new Error("Missing G-Buffer information");
    }
    return [
      "struct GBuffer {",
      ...Array.from(gBufferConfig.gBufferStructDeclaration).filter((x) => this.gBuffer.has(x[0])).map((x) => `	${x[1]}`),
      "};\n"
    ].join("\n");
  }
  /**
   * Creates a material based on the given effects.
   *
   * @param effects - The effects that make up the material.
   * @return The material.
   * @throws If the material couldn't be created.
   */
  createMaterial(effects) {
    const id = _EffectMaterialManager.getMaterialId(effects);
    const result = id === _EffectMaterialManager.DEFAULT_MATERIAL_ID ? this.defaultMaterial : new EffectMaterial();
    const data = this.getEffectShaderData(effects);
    const gBufferConfig = this.gBufferConfig;
    if (gBufferConfig !== null) {
      data.shaderParts.set("$FRAGMENT_HEAD_GBUFFER" /* FRAGMENT_HEAD_GBUFFER */, this.createGBufferStructDeclaration(gBufferConfig));
      data.shaderParts.set("$FRAGMENT_HEAD_GDATA" /* FRAGMENT_HEAD_GDATA */, data.createGDataStructDeclaration(gBufferConfig));
      data.shaderParts.set("$FRAGMENT_MAIN_GDATA" /* FRAGMENT_MAIN_GDATA */, data.createGDataStructInitialization(gBufferConfig));
    }
    const fragmentHead = data.shaderParts.get("$FRAGMENT_HEAD_EFFECTS" /* FRAGMENT_HEAD_EFFECTS */);
    data.shaderParts.set("$FRAGMENT_HEAD_EFFECTS" /* FRAGMENT_HEAD_EFFECTS */, fragmentHead + data.createBlendFunctions());
    if (data.colorSpace === SRGBColorSpace5) {
      const fragmentMainImage = data.shaderParts.get("$FRAGMENT_MAIN_IMAGE" /* FRAGMENT_MAIN_IMAGE */);
      data.shaderParts.set("$FRAGMENT_MAIN_IMAGE" /* FRAGMENT_MAIN_IMAGE */, fragmentMainImage + "color0 = sRGBToLinear(color0);\n	");
    }
    if (data.uvTransformation) {
      const fragmentMainUv = data.shaderParts.get("$FRAGMENT_MAIN_UV" /* FRAGMENT_MAIN_UV */);
      data.shaderParts.set("$FRAGMENT_MAIN_UV" /* FRAGMENT_MAIN_UV */, "vec2 transformedUv = vUv;\n" + fragmentMainUv);
      data.defines.set("UV", "transformedUv");
    } else {
      data.defines.set("UV", "vUv");
    }
    data.shaderParts.forEach((v3, k, map) => map.set(k, v3.trim().replace(/^#/, "\n#")));
    for (const entry of this.shaderData.defines) {
      data.defines.set(entry[0], entry[1]);
    }
    for (const entry of this.shaderData.uniforms) {
      data.uniforms.set(entry[0], entry[1]);
    }
    if (result !== this.defaultMaterial) {
      for (const entry of Object.entries(this.defaultMaterial.uniforms)) {
        result.uniforms[entry[0]] = entry[1];
      }
      for (const entry of Object.entries(this.defaultMaterial.defines)) {
        result.defines[entry[0]] = entry[1];
      }
    }
    return result.setShaderParts(data.shaderParts).setDefines(data.defines).setUniforms(data.uniforms);
  }
  /**
   * Creates materials based on the possible effect combinations.
   *
   * If there are no optional effects or if there are too many optional effects, only the required material for the
   * currently active effects will be created.
   *
   * @param effects - The effects.
   * @throws If the materials couldn't be created.
   */
  createMaterials(effects) {
    const optionalEffects = effects.filter((x) => x.optional);
    const tooManyOptionalEffects = optionalEffects.length > _EffectMaterialManager.MAX_OPTIONAL_EFFECTS;
    if (optionalEffects.length === 0 || tooManyOptionalEffects) {
      const combination = effects.filter((x) => x.enabled);
      const id = _EffectMaterialManager.getMaterialId(combination);
      this.materialCache.set(id, this.createMaterial(combination));
      return;
    }
    for (const combination of this.getEffectCombinations(effects)) {
      const id = _EffectMaterialManager.getMaterialId(combination);
      if (!this.materialCache.has(id)) {
        this.materialCache.set(id, this.createMaterial(combination));
      }
    }
  }
  /**
   * Synchronizes the cached materials with the active material.
   *
   * This ensures that any changes to the backing data of the active material will be applied to all materials.
   */
  synchronizeMaterials() {
    if (this.activeMaterial === null) {
      return;
    }
    const activeMaterial = this.activeMaterial;
    const defaultMaterial = this.defaultMaterial;
    for (const entry of Object.entries(defaultMaterial.defines)) {
      if (entry[1] !== activeMaterial.defines[entry[0]]) {
        defaultMaterial.defines[entry[0]] = activeMaterial.defines[entry[0]];
        defaultMaterial.needsUpdate = true;
      }
    }
    if (!defaultMaterial.needsUpdate) {
      return;
    }
    for (const material of this.materialCache.values()) {
      if (material === defaultMaterial) {
        continue;
      }
      for (const entry of Object.entries(defaultMaterial.defines)) {
        material.defines[entry[0]] = entry[1];
      }
      material.needsUpdate = true;
    }
  }
  /**
   * Returns a shader material for the current effect configuration.
   *
   * The required material will be created if it doesn't exist yet. Materials for other possible effect combinations
   * will also be created and cached for later use.
   *
   * @throws If the current effects cannot be merged.
   */
  getMaterial(effects) {
    if (this.gBufferConfig === null) {
      return this.defaultMaterial;
    }
    this.synchronizeMaterials();
    const activeEffects = effects.filter((x) => x.enabled);
    const id = _EffectMaterialManager.getMaterialId(activeEffects);
    if (!this.materialCache.has(id)) {
      this.createMaterials(effects);
    }
    this.activeMaterial = this.materialCache.get(id);
    return this.activeMaterial;
  }
  /**
   * Returns all possible effect combinations based on the {@link Effect.optional} flag.
   *
   * @see https://www.geeksforgeeks.org/find-all-the-combinations-of-the-array-values-in-javascript
   * @param effects - The effects.
   * @return An iterator that returns the effect combinations.
   */
  *getEffectCombinations(effects) {
    const optionalEffects = effects.filter((x) => x.optional);
    const n = optionalEffects.length;
    const m = 1 << n;
    for (let i = 0; i < m; ++i) {
      const combination = [];
      for (let j = 0; j < n; ++j) {
        if (i & 1 << j) {
          combination.push(optionalEffects[j]);
        }
      }
      yield effects.filter((x) => !x.optional || combination.includes(x));
    }
  }
  /**
   * Invalidates the material cache.
   */
  invalidateMaterialCache() {
    for (const material of this.materialCache.values()) {
      material.dispose();
    }
    this.materialCache.clear();
  }
  /**
   * Invalidates the shader data associated with the given effect.
   *
   * @param effect - The effect for which the shader data should be deleted.
   */
  invalidateShaderData(effect) {
    this.effectShaderDataCache.delete(effect);
  }
  dispose() {
    this.invalidateMaterialCache();
    this.effectShaderDataCache.clear();
  }
  /**
   * Creates a material ID based on a given list of effects.
   *
   * The order of the effects matters.
   *
   * @param effects - A list of effects.
   * @return The ID.
   */
  static getMaterialId(effects) {
    return effects.length === 0 ? _EffectMaterialManager.DEFAULT_MATERIAL_ID : effects.map((x) => x.id).join("-");
  }
};

// src/passes/EffectPass.ts
var EffectPass = class extends Pass {
  /**
   * An effect material manager.
   */
  effectMaterialManager;
  /**
   * An event listener that calls {@link handleEffectEvent}.
   */
  effectListener;
  /**
   * An event listener that calls {@link handleGBufferConfigEvent}.
   */
  gBufferConfigListener;
  /**
   * Keeps track of the previous G-Buffer configuration.
   */
  previousGBufferConfig;
  /**
   * Indicates whether this pass has been disposed.
   *
   * If true, resources will be refreshed before the next render operation.
   */
  disposed;
  /**
   * An animation time scale.
   */
  timeScale;
  /**
   * Constructs a new effect pass.
   *
   * @param effects - The effects that will be rendered by this pass.
   */
  constructor(...effects) {
    super("EffectPass");
    this.output.defaultBuffer = this.createFramebuffer();
    this.effectMaterialManager = new EffectMaterialManager(this.input);
    this.effectMaterialManager.gBuffer = this.input.gBuffer;
    this.effectListener = (e) => this.handleEffectEvent(e);
    this.gBufferConfigListener = (e) => this.handleGBufferConfigEvent(e);
    this.previousGBufferConfig = null;
    this.effects = effects;
    this.disposed = false;
    this.timeScale = 1;
  }
  get subpasses() {
    return super.subpasses;
  }
  set subpasses(value) {
    for (const effect of super.subpasses) {
      effect.removeEventListener("change", this.effectListener);
      effect.removeEventListener("toggle", this.effectListener);
    }
    super.subpasses = value;
    this.input.gBuffer.clear();
    for (const effect of super.subpasses) {
      this.copyGBufferComponents(effect);
      effect.addEventListener("change", this.effectListener);
      effect.addEventListener("toggle", this.effectListener);
    }
    this.updateMaterial(true);
    this.disposed = false;
  }
  /**
   * The effects.
   *
   * @throws If there are duplicate effects or if the effects cannot be merged.
   */
  get effects() {
    return this.subpasses;
  }
  set effects(value) {
    const distinctEffects = new Set(value);
    if (distinctEffects.size < value.length) {
      const duplicates = value.filter((x) => !distinctEffects.has(x)).map((x) => x.name);
      throw new Error(`Encountered duplicate effects: ${duplicates.join(", ")}`);
    }
    this.subpasses = value;
  }
  /**
   * Controls whether dithering is enabled.
   */
  get dithering() {
    return this.effectMaterialManager.dithering;
  }
  set dithering(value) {
    this.effectMaterialManager.dithering = value;
  }
  /**
   * Copies the G-Buffer components of the given effect.
   *
   * @param effect - The effect.
   */
  copyGBufferComponents(effect) {
    for (const gBufferComponent of effect.input.gBuffer) {
      this.input.gBuffer.add(gBufferComponent);
    }
  }
  /**
   * Updates the fullscreen material based on the current effect combination.
   *
   * The required material will be swapped in if it exists. Otherwise, a new material will be created.
   *
   * @param invalidateCache - Controls whether the material cache should be rebuild.
   * @throws If the current effects cannot be merged.
   */
  updateMaterial(invalidateCache) {
    if (invalidateCache) {
      this.effectMaterialManager.invalidateMaterialCache();
      this.materials.clear();
    }
    this.fullscreenMaterial = this.effectMaterialManager.getMaterial(this.effects);
    for (const material of this.effectMaterialManager.materials) {
      this.materials.add(material);
    }
  }
  /**
   * Updates the G-Buffer struct uniform.
   */
  updateGBufferStruct() {
    const input = this.input;
    const gBufferConfig = input.gBufferConfig;
    if (gBufferConfig === null) {
      return;
    }
    const gBufferEntries = [];
    for (const component of input.gBuffer) {
      const useDefaultBuffer = component === "Color" /* COLOR */;
      const buffer = useDefaultBuffer ? input.defaultBuffer?.value : input.buffers.get(component)?.value;
      gBufferEntries.push([gBufferConfig.gBufferStructFields.get(component), buffer ?? null]);
    }
    this.fullscreenMaterial.gBuffer = Object.fromEntries(gBufferEntries);
  }
  // #region Event Handlers
  /**
   * Handles {@link Effect} events.
   *
   * @param event - An event.
   */
  handleEffectEvent(e) {
    switch (e.type) {
      case "change":
        this.copyGBufferComponents(e.target);
        this.effectMaterialManager.invalidateShaderData(e.target);
        this.updateMaterial(true);
        break;
      case "toggle":
        this.updateMaterial(false);
        break;
    }
  }
  /**
   * Handles {@link GBufferConfig} events.
   *
   * @param event - An event.
   */
  handleGBufferConfigEvent(e) {
    switch (e.type) {
      case "change":
        this.updateMaterial(true);
        break;
    }
  }
  // #endregion
  /**
   * Performs tasks when the {@link GBufferConfig} has changed.
   */
  onGBufferConfigChange() {
    const gBufferConfig = this.input.gBufferConfig;
    if (this.previousGBufferConfig !== null) {
      this.previousGBufferConfig.removeEventListener("change", this.gBufferConfigListener);
    }
    if (this.input.gBufferConfig !== null) {
      this.input.gBufferConfig.addEventListener("change", this.gBufferConfigListener);
    }
    this.effectMaterialManager.gBufferConfig = gBufferConfig;
    this.previousGBufferConfig = gBufferConfig;
    for (const effect of this.effects) {
      effect.input.gBufferConfig = gBufferConfig;
    }
    this.updateMaterial(true);
  }
  onInputChange() {
    this.updateGBufferStruct();
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.effectListener);
      effect.input.buffers.clear();
      for (const entry of this.input.buffers) {
        effect.input.buffers.set(entry[0], entry[1]);
      }
      effect.addEventListener("change", this.effectListener);
    }
    if (this.previousGBufferConfig !== this.input.gBufferConfig) {
      this.onGBufferConfigChange();
    } else {
      this.updateMaterial(true);
    }
  }
  checkRequirements() {
    for (const effect of this.effects) {
      effect.checkRequirements();
    }
  }
  async compile() {
    this.updateMaterial(false);
    return super.compile();
  }
  dispose() {
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.effectListener);
      effect.removeEventListener("toggle", this.effectListener);
    }
    if (this.input.gBufferConfig !== null) {
      this.input.gBufferConfig.removeEventListener("change", this.gBufferConfigListener);
    }
    this.effectMaterialManager.dispose();
    super.dispose();
    this.disposed = true;
  }
  render() {
    if (this.renderer === null || this.timer === null) {
      return;
    }
    if (this.disposed) {
      this.effects = [...this.effects];
    }
    for (const effect of this.effects) {
      if (effect.enabled) {
        effect.render();
      }
    }
    this.fullscreenMaterial.time += this.timer.getDelta() * this.timeScale;
    this.setRenderTarget(this.output.defaultBuffer?.value);
    this.renderFullscreen();
  }
};

// src/passes/GaussianBlurPass.ts
var GaussianBlurPass = class _GaussianBlurPass extends Pass {
  /**
   * Identifies the first blur buffer.
   */
  static BUFFER_A = "BUFFER_A";
  /**
   * Identifies the second blur buffer.
   */
  static BUFFER_B = "BUFFER_B";
  iterations;
  /**
   * Constructs a new Gaussian blur pass.
   *
   * @param options - The options.
   */
  constructor({ kernelSize = 35, iterations = 1 } = {}) {
    super("GaussianBlurPass");
    this.output.setBuffer(_GaussianBlurPass.BUFFER_A, this.createFramebuffer());
    this.output.setBuffer(_GaussianBlurPass.BUFFER_B, this.createFramebuffer());
    this.fullscreenMaterial = new GaussianBlurMaterial({ kernelSize });
    this.iterations = iterations;
  }
  /**
   * The blur material.
   */
  get blurMaterial() {
    return this.fullscreenMaterial;
  }
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(value) {
    this.blurMaterial.kernelSize = value;
  }
  /**
   * The first blur render target.
   */
  get renderTargetA() {
    return this.output.getBuffer(_GaussianBlurPass.BUFFER_A);
  }
  /**
   * The second blur render target.
   */
  get renderTargetB() {
    return this.output.getBuffer(_GaussianBlurPass.BUFFER_B);
  }
  /**
   * A texture that contains the blurred result.
   */
  get texture() {
    return this.output.buffers.get(_GaussianBlurPass.BUFFER_B).texture;
  }
  onInputChange() {
    const inputTexture = this.input.defaultBuffer?.value ?? null;
    if (inputTexture === null) {
      return;
    }
    const { format, internalFormat, type, colorSpace } = inputTexture;
    for (const renderTarget of [this.renderTargetA, this.renderTargetB]) {
      const texture = renderTarget.texture;
      texture.format = format;
      texture.internalFormat = internalFormat;
      texture.type = type;
      texture.colorSpace = colorSpace;
      renderTarget.dispose();
    }
    if (this.input.frameBufferPrecisionHigh) {
      this.blurMaterial.outputPrecision = "mediump";
    } else {
      this.blurMaterial.outputPrecision = "lowp";
    }
    this.onResolutionChange();
  }
  onResolutionChange() {
    const inputBuffer = this.input.defaultBuffer?.value ?? null;
    if (inputBuffer === null) {
      return;
    }
    const resolution = this.resolution;
    this.renderTargetA.setSize(resolution.width, resolution.height);
    this.renderTargetB.setSize(resolution.width, resolution.height);
    const imgData = inputBuffer.source.data;
    this.blurMaterial.setSize(imgData.width, imgData.height);
  }
  render() {
    if (this.renderer === null || this.input.defaultBuffer === null || this.input.defaultBuffer.value === null) {
      return;
    }
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    const blurMaterial = this.blurMaterial;
    let previousBuffer = this.input.defaultBuffer.value;
    for (let i = 0, l = Math.max(this.iterations, 1); i < l; ++i) {
      blurMaterial.direction.set(1, 0);
      blurMaterial.inputBuffer = previousBuffer;
      this.setRenderTarget(renderTargetA);
      this.renderFullscreen();
      blurMaterial.direction.set(0, 1);
      blurMaterial.inputBuffer = renderTargetA.texture;
      this.setRenderTarget(renderTargetB);
      this.renderFullscreen();
      if (i === 0 && l > 1) {
        previousBuffer = renderTargetB.texture;
      }
    }
  }
};

// src/passes/LambdaPass.ts
var LambdaPass = class extends Pass {
  /**
   * The function to execute.
   */
  f;
  /**
   * Constructs a new lambda pass.
   *
   * @param f - A function.
   */
  constructor(f) {
    super("LambdaPass");
    this.f = f;
  }
  render() {
    this.f();
  }
};

// src/textures/lut/LookupTexture.ts
import {
  Color as Color6,
  Data3DTexture,
  DataTexture,
  FloatType as FloatType7,
  LinearFilter as LinearFilter4,
  LinearSRGBColorSpace as LinearSRGBColorSpace2,
  RGBAFormat as RGBAFormat3,
  SRGBColorSpace as SRGBColorSpace6,
  UnsignedByteType as UnsignedByteType9,
  Vector3 as Vector35
} from "three";

// src/textures/RawImageData.ts
function createCanvas(width, height, data) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  canvas.width = width;
  canvas.height = height;
  if (context === null) {
    return canvas;
  } else if (data instanceof Image) {
    context.drawImage(data, 0, 0);
  } else {
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
  }
  return canvas;
}
var RawImageData = class _RawImageData {
  colorSpace;
  /**
   * The width of the image.
   */
  width;
  /**
   * The height of the image.
   */
  height;
  /**
   * The RGBA image data.
   */
  data;
  /**
   * Constructs a new image data container.
   *
   * @param width - The width of the image.
   * @param height - The height of the image.
   * @param data - The image data.
   */
  constructor(width = 0, height = 0, data) {
    this.colorSpace = "srgb";
    this.width = width;
    this.height = height;
    this.data = data;
  }
  /**
   * Creates a canvas from this image data.
   *
   * @return The canvas.
   */
  toCanvas() {
    if (typeof document === "undefined") {
      throw new Error("Failed to create canvas");
    }
    return createCanvas(this.width, this.height, this.data);
  }
  /**
   * Creates a new image data container.
   *
   * @param image - An image or plain image data.
   * @return The image data.
   */
  static from(image) {
    const { width, height } = image;
    let data;
    if (image instanceof Image) {
      const canvas = createCanvas(width, height, image);
      const context = canvas.getContext("2d");
      if (canvas === null || context === null) {
        throw new Error("Failed to create canvas");
      }
      data = context.getImageData(0, 0, width, height).data;
    } else {
      data = image.data;
    }
    return new _RawImageData(width, height, data);
  }
};

// temp/lut/worker.txt
var worker_default = '"use strict";(()=>{var B=Math.pow;var C=[new Float32Array(3),new Float32Array(3)],t=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],V=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function P(o,r,a,m){let F=a[0]-r[0],A=a[1]-r[1],e=a[2]-r[2],i=o[0]-r[0],w=o[1]-r[1],y=o[2]-r[2],s=A*y-e*w,c=e*i-F*y,p=F*w-A*i,h=Math.sqrt(s*s+c*c+p*p),X=h*.5,l=s/h,u=c/h,f=p/h,b=-(o[0]*l+o[1]*u+o[2]*f),M=m[0]*l+m[1]*u+m[2]*f;return Math.abs(M+b)*X/3}function Y(o,r,a,m,F,A){let e=(a+m*r+F*r*r)*4;A[0]=o[e+0],A[1]=o[e+1],A[2]=o[e+2]}function W(o,r,a,m,F,A){let e=a*(r-1),i=m*(r-1),w=F*(r-1),y=Math.floor(e),s=Math.floor(i),c=Math.floor(w),p=Math.ceil(e),h=Math.ceil(i),X=Math.ceil(w),l=e-y,u=i-s,f=w-c;if(y===e&&s===i&&c===w)Y(o,r,e,i,w,A);else{let b;l>=u&&u>=f?b=V[0]:l>=f&&f>=u?b=V[1]:f>=l&&l>=u?b=V[2]:u>=l&&l>=f?b=V[3]:u>=f&&f>=l?b=V[4]:b=V[5];let[M,g,d,v]=b,x=C[0];x[0]=l,x[1]=u,x[2]=f;let n=C[1],Z=p-y,U=h-s,L=X-c;n[0]=Z*M[0]+y,n[1]=U*M[1]+s,n[2]=L*M[2]+c,Y(o,r,n[0],n[1],n[2],t[0]),n[0]=Z*g[0]+y,n[1]=U*g[1]+s,n[2]=L*g[2]+c,Y(o,r,n[0],n[1],n[2],t[1]),n[0]=Z*d[0]+y,n[1]=U*d[1]+s,n[2]=L*d[2]+c,Y(o,r,n[0],n[1],n[2],t[2]),n[0]=Z*v[0]+y,n[1]=U*v[1]+s,n[2]=L*v[2]+c,Y(o,r,n[0],n[1],n[2],t[3]);let T=P(g,d,v,x)*6,q=P(M,d,v,x)*6,S=P(M,g,v,x)*6,E=P(M,g,d,x)*6;t[0][0]*=T,t[0][1]*=T,t[0][2]*=T,t[1][0]*=q,t[1][1]*=q,t[1][2]*=q,t[2][0]*=S,t[2][1]*=S,t[2][2]*=S,t[3][0]*=E,t[3][1]*=E,t[3][2]*=E,A[0]=t[0][0]+t[1][0]+t[2][0]+t[3][0],A[1]=t[0][1]+t[1][1]+t[2][1]+t[3][1],A[2]=t[0][2]+t[1][2]+t[2][2]+t[3][2]}}var k=class{static expand(r,a){let m=Math.cbrt(r.length/4),F=new r.constructor(B(a,3)*4),A=r instanceof Uint8Array?255:1,e=new Float32Array(3),i=B(a,2),w=1/(a-1);for(let y=0;y<a;++y)for(let s=0;s<a;++s)for(let c=0;c<a;++c){let p=c*w,h=s*w,X=y*w,l=Math.round(c+s*a+y*i)*4;W(r,m,p,h,X,e),F[l+0]=e[0],F[l+1]=e[1],F[l+2]=e[2],F[l+3]=A}return F}};self.addEventListener("message",o=>{let r=o.data,a=k.expand(r.data,r.size);self.postMessage(a,[a.buffer]),close()});})();\n';

// src/textures/lut/LookupTexture.ts
var c = new Color6();
var LookupTexture = class _LookupTexture extends Data3DTexture {
  /**
   * Constructs a cubic 3D lookup texture.
   *
   * @param data - The pixel data. The default format is RGBA.
   * @param size - The sidelength.
   */
  constructor(data, size) {
    super(data, size, size, size);
    this.type = FloatType7;
    this.minFilter = LinearFilter4;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
    this.userData = {
      domainMin: new Vector35(0, 0, 0),
      domainMax: new Vector35(1, 1, 1)
    };
  }
  /**
   * Creates an upscaled LUT using tetrahedral interpolation.
   *
   * @param size - The target sidelength.
   * @param transferData - Extra fast mode that modifies the data of this LUT. Disable to keep the original data intact.
   * @return A promise that resolves with a new LUT upon completion.
   */
  async scaleUp(size, transferData = true) {
    const image = this.image;
    if (size <= image.width) {
      return Promise.reject(new Error("The target size must be greater than the current size"));
    }
    return new Promise((resolve, reject) => {
      const workerURL = URL.createObjectURL(new Blob([worker_default], { type: "text/javascript" }));
      const worker = new Worker(workerURL);
      worker.addEventListener("error", (event) => reject(event.error));
      worker.addEventListener("message", (event) => {
        const lut = new _LookupTexture(event.data, size);
        lut.colorSpace = this.colorSpace;
        lut.type = this.type;
        lut.name = this.name;
        lut.userData = this.userData;
        URL.revokeObjectURL(workerURL);
        resolve(lut);
      });
      const transferList = transferData ? [image.data.buffer] : [];
      worker.postMessage({
        data: image.data,
        size
      }, transferList);
    });
  }
  /**
   * Applies the given LUT to this one.
   *
   * @param lut - A LUT. Must have the same dimensions, type and format as this LUT.
   * @return This texture.
   */
  applyLUT(lut) {
    const img0 = this.image;
    const img1 = lut.image;
    const size0 = Math.min(img0.width, img0.height, img0.depth);
    const size1 = Math.min(img1.width, img1.height, img1.depth);
    if (size0 !== size1) {
      throw new Error("Size mismatch");
    } else if (lut.type !== FloatType7 || this.type !== FloatType7) {
      throw new Error("Both LUTs must be FloatType textures");
    } else if (lut.format !== RGBAFormat3 || this.format !== RGBAFormat3) {
      throw new Error("Both LUTs must be RGBA textures");
    }
    const data0 = img0.data;
    const data1 = img1.data;
    const size = size0;
    const sizeSq = size ** 2;
    const s = size - 1;
    for (let i = 0, l = size ** 3; i < l; ++i) {
      const i4 = i * 4;
      const r = data0[i4 + 0] * s;
      const g = data0[i4 + 1] * s;
      const b = data0[i4 + 2] * s;
      const iRGB = Math.round(r + g * size + b * sizeSq) * 4;
      data0[i4 + 0] = data1[iRGB + 0];
      data0[i4 + 1] = data1[iRGB + 1];
      data0[i4 + 2] = data1[iRGB + 2];
    }
    this.needsUpdate = true;
    return this;
  }
  /**
   * Converts the LUT data into unsigned byte data.
   *
   * This is a lossy operation which should only be performed after all other transformations have been applied.
   *
   * @return This texture.
   */
  convertToUint8() {
    if (this.type === FloatType7) {
      const img = this.image;
      const floatData = img.data;
      const uint8Data = new Uint8Array(floatData.length);
      for (let i = 0, l = floatData.length; i < l; ++i) {
        uint8Data[i] = floatData[i] * 255 + 0.5;
      }
      this.source.data = Object.assign({}, img, { data: uint8Data });
      this.type = UnsignedByteType9;
      this.needsUpdate = true;
    }
    return this;
  }
  /**
   * Converts the LUT data into float data.
   *
   * @return This texture.
   */
  convertToFloat() {
    if (this.type === UnsignedByteType9) {
      const img = this.image;
      const uint8Data = img.data;
      const floatData = new Float32Array(uint8Data.length);
      for (let i = 0, l = uint8Data.length; i < l; ++i) {
        floatData[i] = uint8Data[i] / 255;
      }
      this.source.data = Object.assign({}, img, { data: floatData });
      this.type = FloatType7;
      this.needsUpdate = true;
    }
    return this;
  }
  /**
   * Converts the output of this LUT into sRGB color space.
   *
   * @return This texture.
   */
  convertLinearToSRGB() {
    const img = this.image;
    const data = img.data;
    if (this.type !== FloatType7) {
      throw new Error("Color space conversion requires FloatType data");
    }
    for (let i = 0, l = data.length; i < l; i += 4) {
      c.fromArray(data, i).convertLinearToSRGB().toArray(data, i);
    }
    this.colorSpace = SRGBColorSpace6;
    this.needsUpdate = true;
    return this;
  }
  /**
   * Converts the output of this LUT into linear color space.
   *
   * @return This texture.
   */
  convertSRGBToLinear() {
    const img = this.image;
    const data = img.data;
    if (this.type !== FloatType7) {
      throw new Error("Color space conversion requires FloatType data");
    }
    for (let i = 0, l = data.length; i < l; i += 4) {
      c.fromArray(data, i).convertSRGBToLinear().toArray(data, i);
    }
    this.colorSpace = LinearSRGBColorSpace2;
    this.needsUpdate = true;
    return this;
  }
  /**
   * Converts this LUT into a 2D data texture.
   *
   * Custom {@link LUTDomainBounds} are stored as `userData.domainBounds`.
   *
   * @return The texture.
   */
  toDataTexture() {
    const img = this.image;
    const width = img.width;
    const height = img.height * img.depth;
    const texture = new DataTexture(img.data, width, height);
    texture.name = this.name;
    texture.type = this.type;
    texture.format = this.format;
    texture.colorSpace = this.colorSpace;
    texture.minFilter = LinearFilter4;
    texture.magFilter = LinearFilter4;
    texture.wrapS = this.wrapS;
    texture.wrapT = this.wrapT;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    texture.userData = this.userData;
    return texture;
  }
  /**
   * Clones this texture.
   *
   * @return The cloned texture.
   */
  clone() {
    return _LookupTexture.from(this);
  }
  /**
   * Creates a new 3D LUT by copying a given LUT.
   *
   * Supports common image-based 2D textures.
   *
   * @param texture - The LUT. Assumed to be cubic.
   * @return A new 3D LUT.
   */
  static from(texture) {
    const image = texture.image;
    const { width, height } = image;
    const size = Math.min(width, height);
    let data;
    if (image instanceof Image) {
      const rawImageData = RawImageData.from(image);
      const src = rawImageData.data;
      if (width > height) {
        data = new Uint8Array(src.length);
        for (let z = 0; z < size; ++z) {
          for (let y = 0; y < size; ++y) {
            for (let x = 0; x < size; ++x) {
              const i4 = (x + z * size + y * size * size) * 4;
              const j4 = (x + y * size + z * size * size) * 4;
              data[j4 + 0] = src[i4 + 0];
              data[j4 + 1] = src[i4 + 1];
              data[j4 + 2] = src[i4 + 2];
              data[j4 + 3] = src[i4 + 3];
            }
          }
        }
      } else {
        data = new Uint8Array(src.buffer);
      }
    } else {
      data = image.data.slice();
    }
    const lut = new _LookupTexture(data, size);
    lut.colorSpace = texture.colorSpace;
    lut.type = texture.type;
    lut.name = texture.name;
    const domainDataSrc = texture.userData ?? {};
    const domainDataDst = lut.userData;
    if (domainDataSrc.domainMin !== void 0 && domainDataSrc.domainMax !== void 0) {
      domainDataDst.domainMin.copy(domainDataSrc.domainMin);
      domainDataDst.domainMax.copy(domainDataSrc.domainMax);
    }
    return lut;
  }
  /**
   * Creates a neutral 3D LUT.
   *
   * @param size - The sidelength.
   * @return A neutral 3D LUT.
   */
  static createNeutral(size) {
    const data = new Float32Array(size ** 3 * 4);
    const sizeSq = size ** 2;
    const s = 1 / (size - 1);
    for (let r = 0; r < size; ++r) {
      for (let g = 0; g < size; ++g) {
        for (let b = 0; b < size; ++b) {
          const i4 = (r + g * size + b * sizeSq) * 4;
          data[i4 + 0] = r * s;
          data[i4 + 1] = g * s;
          data[i4 + 2] = b * s;
          data[i4 + 3] = 1;
        }
      }
    }
    const lut = new _LookupTexture(data, size);
    lut.name = "neutral";
    return lut;
  }
};

// src/textures/lut/TetrahedralUpscaler.ts
var P = [
  new Float32Array(3),
  new Float32Array(3)
];
var C = [
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3)
];
var T = [
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ]
];
function calculateTetrahedronVolume(a, b, c2, d) {
  const bcX = c2[0] - b[0];
  const bcY = c2[1] - b[1];
  const bcZ = c2[2] - b[2];
  const baX = a[0] - b[0];
  const baY = a[1] - b[1];
  const baZ = a[2] - b[2];
  const crossX = bcY * baZ - bcZ * baY;
  const crossY = bcZ * baX - bcX * baZ;
  const crossZ = bcX * baY - bcY * baX;
  const length = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);
  const triangleArea = length * 0.5;
  const normalX = crossX / length;
  const normalY = crossY / length;
  const normalZ = crossZ / length;
  const constant = -(a[0] * normalX + a[1] * normalY + a[2] * normalZ);
  const dot = d[0] * normalX + d[1] * normalY + d[2] * normalZ;
  const height = Math.abs(dot + constant);
  return height * triangleArea / 3;
}
function sample(data, size, x, y, z, color2) {
  const i4 = (x + y * size + z * size * size) * 4;
  color2[0] = data[i4 + 0];
  color2[1] = data[i4 + 1];
  color2[2] = data[i4 + 2];
}
function tetrahedralSample(data, size, u, v3, w, color2) {
  const px = u * (size - 1);
  const py = v3 * (size - 1);
  const pz = w * (size - 1);
  const minX = Math.floor(px);
  const minY = Math.floor(py);
  const minZ = Math.floor(pz);
  const maxX = Math.ceil(px);
  const maxY = Math.ceil(py);
  const maxZ = Math.ceil(pz);
  const su = px - minX;
  const sv = py - minY;
  const sw = pz - minZ;
  if (minX === px && minY === py && minZ === pz) {
    sample(data, size, px, py, pz, color2);
  } else {
    let vertices;
    if (su >= sv && sv >= sw) {
      vertices = T[0];
    } else if (su >= sw && sw >= sv) {
      vertices = T[1];
    } else if (sw >= su && su >= sv) {
      vertices = T[2];
    } else if (sv >= su && su >= sw) {
      vertices = T[3];
    } else if (sv >= sw && sw >= su) {
      vertices = T[4];
    } else {
      vertices = T[5];
    }
    const [P0, P1, P2, P3] = vertices;
    const coords = P[0];
    coords[0] = su;
    coords[1] = sv;
    coords[2] = sw;
    const tmp = P[1];
    const diffX = maxX - minX;
    const diffY = maxY - minY;
    const diffZ = maxZ - minZ;
    tmp[0] = diffX * P0[0] + minX;
    tmp[1] = diffY * P0[1] + minY;
    tmp[2] = diffZ * P0[2] + minZ;
    sample(data, size, tmp[0], tmp[1], tmp[2], C[0]);
    tmp[0] = diffX * P1[0] + minX;
    tmp[1] = diffY * P1[1] + minY;
    tmp[2] = diffZ * P1[2] + minZ;
    sample(data, size, tmp[0], tmp[1], tmp[2], C[1]);
    tmp[0] = diffX * P2[0] + minX;
    tmp[1] = diffY * P2[1] + minY;
    tmp[2] = diffZ * P2[2] + minZ;
    sample(data, size, tmp[0], tmp[1], tmp[2], C[2]);
    tmp[0] = diffX * P3[0] + minX;
    tmp[1] = diffY * P3[1] + minY;
    tmp[2] = diffZ * P3[2] + minZ;
    sample(data, size, tmp[0], tmp[1], tmp[2], C[3]);
    const V0 = calculateTetrahedronVolume(P1, P2, P3, coords) * 6;
    const V1 = calculateTetrahedronVolume(P0, P2, P3, coords) * 6;
    const V2 = calculateTetrahedronVolume(P0, P1, P3, coords) * 6;
    const V3 = calculateTetrahedronVolume(P0, P1, P2, coords) * 6;
    C[0][0] *= V0;
    C[0][1] *= V0;
    C[0][2] *= V0;
    C[1][0] *= V1;
    C[1][1] *= V1;
    C[1][2] *= V1;
    C[2][0] *= V2;
    C[2][1] *= V2;
    C[2][2] *= V2;
    C[3][0] *= V3;
    C[3][1] *= V3;
    C[3][2] *= V3;
    color2[0] = C[0][0] + C[1][0] + C[2][0] + C[3][0];
    color2[1] = C[0][1] + C[1][1] + C[2][1] + C[3][1];
    color2[2] = C[0][2] + C[1][2] + C[2][2] + C[3][2];
  }
}
var TetrahedralUpscaler = class {
  /**
   * Expands the given data to the target size.
   *
   * @param data - The input RGBA data. Assumed to be cubic.
   * @param size - The target size.
   * @return The new data.
   */
  static expand(data, size) {
    const originalSize = Math.cbrt(data.length / 4);
    const array = new data.constructor(size ** 3 * 4);
    const maxValue = data instanceof Uint8Array ? 255 : 1;
    const rgb = new Float32Array(3);
    const sizeSq = size ** 2;
    const s = 1 / (size - 1);
    for (let z = 0; z < size; ++z) {
      for (let y = 0; y < size; ++y) {
        for (let x = 0; x < size; ++x) {
          const u = x * s;
          const v3 = y * s;
          const w = z * s;
          const i4 = Math.round(x + y * size + z * sizeSq) * 4;
          tetrahedralSample(data, originalSize, u, v3, w, rgb);
          array[i4 + 0] = rgb[0];
          array[i4 + 1] = rgb[1];
          array[i4 + 2] = rgb[2];
          array[i4 + 3] = maxValue;
        }
      }
    }
    return array;
  }
};

// src/utils/functions/math.ts
function lerp(a, b, p) {
  return a + (b - a) * p;
}
function saturate(a) {
  return Math.min(Math.max(a, 0), 1);
}

// src/textures/smaa/SMAAAreaImageData.ts
var area = [[0, 0], [0, 0]];
var ORTHOGONAL_SIZE = 16;
var DIAGONAL_SIZE = 20;
var DIAGONAL_SAMPLES = 30;
var SMOOTH_MAX_DISTANCE = 32;
var orthogonalSubsamplingOffsets = [0, -0.25, 0.25, -0.125, 0.125, -0.375, 0.375];
var diagonalSubsamplingOffsets = [
  [0, 0],
  [0.25, -0.25],
  [-0.25, 0.25],
  [0.125, -0.125],
  [-0.125, 0.125]
];
var orthogonalEdges = [
  [0, 0],
  [3, 0],
  [0, 3],
  [3, 3],
  [1, 0],
  [4, 0],
  [1, 3],
  [4, 3],
  [0, 1],
  [3, 1],
  [0, 4],
  [3, 4],
  [1, 1],
  [4, 1],
  [1, 4],
  [4, 4]
];
var diagonalEdges = [
  [0, 0],
  [1, 0],
  [0, 2],
  [1, 2],
  [2, 0],
  [3, 0],
  [2, 2],
  [3, 2],
  [0, 1],
  [1, 1],
  [0, 3],
  [1, 3],
  [2, 1],
  [3, 1],
  [2, 3],
  [3, 3]
];
function smoothArea(d) {
  const a1 = area[0];
  const a2 = area[1];
  const b1X = Math.sqrt(a1[0] * 2) * 0.5;
  const b1Y = Math.sqrt(a1[1] * 2) * 0.5;
  const b2X = Math.sqrt(a2[0] * 2) * 0.5;
  const b2Y = Math.sqrt(a2[1] * 2) * 0.5;
  const p = saturate(d / SMOOTH_MAX_DISTANCE);
  a1[0] = lerp(b1X, a1[0], p);
  a1[1] = lerp(b1Y, a1[1], p);
  a2[0] = lerp(b2X, a2[0], p);
  a2[1] = lerp(b2Y, a2[1], p);
}
function getOrthArea(p1X, p1Y, p2X, p2Y, x, result) {
  const dX = p2X - p1X;
  const dY = p2Y - p1Y;
  const x1 = x;
  const x2 = x + 1;
  const y1 = p1Y + dY * (x1 - p1X) / dX;
  const y2 = p1Y + dY * (x2 - p1X) / dX;
  if (x1 >= p1X && x1 < p2X || x2 > p1X && x2 <= p2X) {
    if (Math.sign(y1) === Math.sign(y2) || Math.abs(y1) < 1e-4 || Math.abs(y2) < 1e-4) {
      const a = (y1 + y2) / 2;
      if (a < 0) {
        result[0] = Math.abs(a);
        result[1] = 0;
      } else {
        result[0] = 0;
        result[1] = Math.abs(a);
      }
    } else {
      const t = -p1Y * dX / dY + p1X;
      const tInt = Math.trunc(t);
      const a1 = t > p1X ? y1 * (t - tInt) / 2 : 0;
      const a2 = t < p2X ? y2 * (1 - (t - tInt)) / 2 : 0;
      const a = Math.abs(a1) > Math.abs(a2) ? a1 : -a2;
      if (a < 0) {
        result[0] = Math.abs(a1);
        result[1] = Math.abs(a2);
      } else {
        result[0] = Math.abs(a2);
        result[1] = Math.abs(a1);
      }
    }
  } else {
    result[0] = 0;
    result[1] = 0;
  }
}
function getOrthAreaForPattern(pattern, left, right, offset, result) {
  const a1 = area[0];
  const a2 = area[1];
  const o1 = 0.5 + offset;
  const o2 = 0.5 + offset - 1;
  const d = left + right + 1;
  switch (pattern) {
    case 0: {
      result[0] = 0;
      result[1] = 0;
      break;
    }
    case 1: {
      if (left <= right) {
        getOrthArea(0, o2, d / 2, 0, left, result);
      } else {
        result[0] = 0;
        result[1] = 0;
      }
      break;
    }
    case 2: {
      if (left >= right) {
        getOrthArea(d / 2, 0, d, o2, left, result);
      } else {
        result[0] = 0;
        result[1] = 0;
      }
      break;
    }
    case 3: {
      getOrthArea(0, o2, d / 2, 0, left, a1);
      getOrthArea(d / 2, 0, d, o2, left, a2);
      smoothArea(d);
      result[0] = a1[0] + a2[0];
      result[1] = a1[1] + a2[1];
      break;
    }
    case 4: {
      if (left <= right) {
        getOrthArea(0, o1, d / 2, 0, left, result);
      } else {
        result[0] = 0;
        result[1] = 0;
      }
      break;
    }
    case 5: {
      result[0] = 0;
      result[1] = 0;
      break;
    }
    case 6: {
      if (Math.abs(offset) > 0) {
        getOrthArea(0, o1, d, o2, left, a1);
        getOrthArea(0, o1, d / 2, 0, left, a2);
        getOrthArea(d / 2, 0, d, o2, left, result);
        a2[0] = a2[0] + result[0];
        a2[1] = a2[1] + result[1];
        result[0] = (a1[0] + a2[0]) / 2;
        result[1] = (a1[1] + a2[1]) / 2;
      } else {
        getOrthArea(0, o1, d, o2, left, result);
      }
      break;
    }
    case 7: {
      getOrthArea(0, o1, d, o2, left, result);
      break;
    }
    case 8: {
      if (left >= right) {
        getOrthArea(d / 2, 0, d, o1, left, result);
      } else {
        result[0] = 0;
        result[1] = 0;
      }
      break;
    }
    case 9: {
      if (Math.abs(offset) > 0) {
        getOrthArea(0, o2, d, o1, left, a1);
        getOrthArea(0, o2, d / 2, 0, left, a2);
        getOrthArea(d / 2, 0, d, o1, left, result);
        a2[0] = a2[0] + result[0];
        a2[1] = a2[1] + result[1];
        result[0] = (a1[0] + a2[0]) / 2;
        result[1] = (a1[1] + a2[1]) / 2;
      } else {
        getOrthArea(0, o2, d, o1, left, result);
      }
      break;
    }
    case 10: {
      result[0] = 0;
      result[1] = 0;
      break;
    }
    case 11: {
      getOrthArea(0, o2, d, o1, left, result);
      break;
    }
    case 12: {
      getOrthArea(0, o1, d / 2, 0, left, a1);
      getOrthArea(d / 2, 0, d, o1, left, a2);
      smoothArea(d);
      result[0] = a1[0] + a2[0];
      result[1] = a1[1] + a2[1];
      break;
    }
    case 13: {
      getOrthArea(0, o2, d, o1, left, result);
      break;
    }
    case 14: {
      getOrthArea(0, o1, d, o2, left, result);
      break;
    }
    case 15: {
      result[0] = 0;
      result[1] = 0;
      break;
    }
  }
}
function isInsideArea(a1X, a1Y, a2X, a2Y, x, y) {
  let result = a1X === a2X && a1Y === a2Y;
  if (!result) {
    const xm = (a1X + a2X) / 2;
    const ym = (a1Y + a2Y) / 2;
    const a = a2Y - a1Y;
    const b = a1X - a2X;
    const c2 = a * (x - xm) + b * (y - ym);
    result = c2 > 0;
  }
  return result;
}
function getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, pX, pY) {
  let n = 0;
  for (let y = 0; y < DIAGONAL_SAMPLES; ++y) {
    for (let x = 0; x < DIAGONAL_SAMPLES; ++x) {
      const offsetX = x / (DIAGONAL_SAMPLES - 1);
      const offsetY = y / (DIAGONAL_SAMPLES - 1);
      if (isInsideArea(a1X, a1Y, a2X, a2Y, pX + offsetX, pY + offsetY)) {
        ++n;
      }
    }
  }
  return n / (DIAGONAL_SAMPLES * DIAGONAL_SAMPLES);
}
function getDiagArea(pattern, a1X, a1Y, a2X, a2Y, left, offset, result) {
  const e = diagonalEdges[pattern];
  const e1 = e[0];
  const e2 = e[1];
  if (e1 > 0) {
    a1X += offset[0];
    a1Y += offset[1];
  }
  if (e2 > 0) {
    a2X += offset[0];
    a2Y += offset[1];
  }
  result[0] = 1 - getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 0 + left);
  result[1] = getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 1 + left);
}
function getDiagAreaForPattern(pattern, left, right, offset, result) {
  const a1 = area[0];
  const a2 = area[1];
  const d = left + right + 1;
  switch (pattern) {
    case 0: {
      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 1: {
      getDiagArea(pattern, 1, 0, 0 + d, 0 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 2: {
      getDiagArea(pattern, 0, 0, 1 + d, 0 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 3: {
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, result);
      break;
    }
    case 4: {
      getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);
      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 5: {
      getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 6: {
      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, result);
      break;
    }
    case 7: {
      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 8: {
      getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 9: {
      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);
      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);
      break;
    }
    case 10: {
      getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 11: {
      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 12: {
      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, result);
      break;
    }
    case 13: {
      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 14: {
      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
    case 15: {
      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);
      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);
      result[0] = (a1[0] + a2[0]) / 2;
      result[1] = (a1[1] + a2[1]) / 2;
      break;
    }
  }
}
function generatePatterns(patterns, offset, orthogonal) {
  const result = [0, 0];
  for (let i = 0, l = patterns.length; i < l; ++i) {
    const pattern = patterns[i];
    const data = pattern.data;
    const size = pattern.width;
    for (let y = 0; y < size; ++y) {
      for (let x = 0; x < size; ++x) {
        if (orthogonal) {
          getOrthAreaForPattern(i, x, y, offset[0], result);
        } else {
          getDiagAreaForPattern(i, x, y, offset, result);
        }
        const c2 = (y * size + x) * 2;
        data[c2] = result[0] * 255;
        data[c2 + 1] = result[1] * 255;
      }
    }
  }
}
function assemble(baseX, baseY, patterns, edges2, size, orthogonal, target) {
  const dstData = target.data;
  const dstWidth = target.width;
  for (let i = 0, l = patterns.length; i < l; ++i) {
    const edge = edges2[i];
    const pattern = patterns[i];
    const srcData = pattern.data;
    const srcWidth = pattern.width;
    for (let y = 0; y < size; ++y) {
      for (let x = 0; x < size; ++x) {
        const pX = edge[0] * size + baseX + x;
        const pY = edge[1] * size + baseY + y;
        const c2 = (pY * dstWidth + pX) * 4;
        const d = orthogonal ? (y * y * srcWidth + x * x) * 2 : (y * srcWidth + x) * 2;
        dstData[c2] = srcData[d];
        dstData[c2 + 1] = srcData[d + 1];
        dstData[c2 + 2] = 0;
        dstData[c2 + 3] = 255;
      }
    }
  }
}
var SMAAAreaImageData = class {
  /**
   * Creates a new area image.
   *
   * @return The generated image data.
   */
  static generate() {
    const width = 2 * 5 * ORTHOGONAL_SIZE;
    const height = orthogonalSubsamplingOffsets.length * 5 * ORTHOGONAL_SIZE;
    const data = new Uint8ClampedArray(width * height * 4);
    const result = new RawImageData(width, height, data);
    const orthPatternSize = Math.pow(ORTHOGONAL_SIZE - 1, 2) + 1;
    const orthogonalPatterns = [];
    const diagonalPatterns = [];
    for (let i = 3, l = data.length; i < l; i += 4) {
      data[i] = 255;
    }
    for (let i = 0; i < 16; ++i) {
      orthogonalPatterns.push(new RawImageData(
        orthPatternSize,
        orthPatternSize,
        new Uint8ClampedArray(orthPatternSize * orthPatternSize * 2)
      ));
      diagonalPatterns.push(new RawImageData(
        DIAGONAL_SIZE,
        DIAGONAL_SIZE,
        new Uint8ClampedArray(DIAGONAL_SIZE * DIAGONAL_SIZE * 2)
      ));
    }
    for (let i = 0, l = orthogonalSubsamplingOffsets.length; i < l; ++i) {
      generatePatterns(orthogonalPatterns, [orthogonalSubsamplingOffsets[i]], true);
      assemble(
        0,
        5 * ORTHOGONAL_SIZE * i,
        orthogonalPatterns,
        orthogonalEdges,
        ORTHOGONAL_SIZE,
        true,
        result
      );
    }
    for (let i = 0, l = diagonalSubsamplingOffsets.length; i < l; ++i) {
      generatePatterns(diagonalPatterns, diagonalSubsamplingOffsets[i], false);
      assemble(
        5 * ORTHOGONAL_SIZE,
        4 * DIAGONAL_SIZE * i,
        diagonalPatterns,
        diagonalEdges,
        DIAGONAL_SIZE,
        false,
        result
      );
    }
    return result;
  }
};

// src/textures/smaa/SMAAImageGenerator.ts
import { LoadingManager as LoadingManager2 } from "three";

// temp/smaa/worker.txt
var worker_default2 = '"use strict";(()=>{var Z=Object.defineProperty;var j=(r,a,t)=>a in r?Z(r,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[a]=t;var E=(r,a,t)=>j(r,typeof a!="symbol"?a+"":a,t);function I(r,a,t){return r+(a-r)*t}function W(r){return Math.min(Math.max(r,0),1)}function U(r,a,t){let i=document.createElement("canvas"),n=i.getContext("2d");if(i.width=r,i.height=a,n===null)return i;if(t instanceof Image)n.drawImage(t,0,0);else{let o=n.createImageData(r,a);o.data.set(t),n.putImageData(o,0,0)}return i}var D=class r{constructor(a=0,t=0,i){E(this,"colorSpace");E(this,"width");E(this,"height");E(this,"data");this.colorSpace="srgb",this.width=a,this.height=t,this.data=i}toCanvas(){if(typeof document=="undefined")throw new Error("Failed to create canvas");return U(this.width,this.height,this.data)}static from(a){let{width:t,height:i}=a,n;if(a instanceof Image){let o=U(t,i,a),c=o.getContext("2d");if(o===null||c===null)throw new Error("Failed to create canvas");n=c.getImageData(0,0,t,i).data}else n=a.data;return new r(t,i,n)}};var p=[[0,0],[0,0]],x=16,v=20,C=30,J=32,H=[0,-.25,.25,-.125,.125,-.375,.375],T=[[0,0],[.25,-.25],[-.25,.25],[.125,-.125],[-.125,.125]],K=[[0,0],[3,0],[0,3],[3,3],[1,0],[4,0],[1,3],[4,3],[0,1],[3,1],[0,4],[3,4],[1,1],[4,1],[1,4],[4,4]],B=[[0,0],[1,0],[0,2],[1,2],[2,0],[3,0],[2,2],[3,2],[0,1],[1,1],[0,3],[1,3],[2,1],[3,1],[2,3],[3,3]];function F(r){let a=p[0],t=p[1],i=Math.sqrt(a[0]*2)*.5,n=Math.sqrt(a[1]*2)*.5,o=Math.sqrt(t[0]*2)*.5,c=Math.sqrt(t[1]*2)*.5,e=W(r/J);a[0]=I(i,a[0],e),a[1]=I(n,a[1],e),t[0]=I(o,t[0],e),t[1]=I(c,t[1],e)}function d(r,a,t,i,n,o){let c=t-r,e=i-a,m=n,b=n+1,h=a+e*(m-r)/c,w=a+e*(b-r)/c;if(m>=r&&m<t||b>r&&b<=t)if(Math.sign(h)===Math.sign(w)||Math.abs(h)<1e-4||Math.abs(w)<1e-4){let u=(h+w)/2;u<0?(o[0]=Math.abs(u),o[1]=0):(o[0]=0,o[1]=Math.abs(u))}else{let u=-a*c/e+r,A=Math.trunc(u),M=u>r?h*(u-A)/2:0,k=u<t?w*(1-(u-A))/2:0;(Math.abs(M)>Math.abs(k)?M:-k)<0?(o[0]=Math.abs(M),o[1]=Math.abs(k)):(o[0]=Math.abs(k),o[1]=Math.abs(M))}else o[0]=0,o[1]=0}function Q(r,a,t,i,n){let o=p[0],c=p[1],e=.5+i,m=.5+i-1,b=a+t+1;switch(r){case 0:{n[0]=0,n[1]=0;break}case 1:{a<=t?d(0,m,b/2,0,a,n):(n[0]=0,n[1]=0);break}case 2:{a>=t?d(b/2,0,b,m,a,n):(n[0]=0,n[1]=0);break}case 3:{d(0,m,b/2,0,a,o),d(b/2,0,b,m,a,c),F(b),n[0]=o[0]+c[0],n[1]=o[1]+c[1];break}case 4:{a<=t?d(0,e,b/2,0,a,n):(n[0]=0,n[1]=0);break}case 5:{n[0]=0,n[1]=0;break}case 6:{Math.abs(i)>0?(d(0,e,b,m,a,o),d(0,e,b/2,0,a,c),d(b/2,0,b,m,a,n),c[0]=c[0]+n[0],c[1]=c[1]+n[1],n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2):d(0,e,b,m,a,n);break}case 7:{d(0,e,b,m,a,n);break}case 8:{a>=t?d(b/2,0,b,e,a,n):(n[0]=0,n[1]=0);break}case 9:{Math.abs(i)>0?(d(0,m,b,e,a,o),d(0,m,b/2,0,a,c),d(b/2,0,b,e,a,n),c[0]=c[0]+n[0],c[1]=c[1]+n[1],n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2):d(0,m,b,e,a,n);break}case 10:{n[0]=0,n[1]=0;break}case 11:{d(0,m,b,e,a,n);break}case 12:{d(0,e,b/2,0,a,o),d(b/2,0,b,e,a,c),F(b),n[0]=o[0]+c[0],n[1]=o[1]+c[1];break}case 13:{d(0,m,b,e,a,n);break}case 14:{d(0,e,b,m,a,n);break}case 15:{n[0]=0,n[1]=0;break}}}function V(r,a,t,i,n,o){let c=r===t&&a===i;if(!c){let e=(r+t)/2,m=(a+i)/2,b=i-a,h=r-t;c=b*(n-e)+h*(o-m)>0}return c}function q(r,a,t,i,n,o){let c=0;for(let e=0;e<C;++e)for(let m=0;m<C;++m){let b=m/(C-1),h=e/(C-1);V(r,a,t,i,n+b,o+h)&&++c}return c/(C*C)}function s(r,a,t,i,n,o,c,e){let m=B[r],b=m[0],h=m[1];b>0&&(a+=c[0],t+=c[1]),h>0&&(i+=c[0],n+=c[1]),e[0]=1-q(a,t,i,n,1+o,0+o),e[1]=q(a,t,i,n,1+o,1+o)}function $(r,a,t,i,n){let o=p[0],c=p[1],e=a+t+1;switch(r){case 0:{s(r,1,1,1+e,1+e,a,i,o),s(r,1,0,1+e,0+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 1:{s(r,1,0,0+e,0+e,a,i,o),s(r,1,0,1+e,0+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 2:{s(r,0,0,1+e,0+e,a,i,o),s(r,1,0,1+e,0+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 3:{s(r,1,0,1+e,0+e,a,i,n);break}case 4:{s(r,1,1,0+e,0+e,a,i,o),s(r,1,1,1+e,0+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 5:{s(r,1,1,0+e,0+e,a,i,o),s(r,1,0,1+e,0+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 6:{s(r,1,1,1+e,0+e,a,i,n);break}case 7:{s(r,1,1,1+e,0+e,a,i,o),s(r,1,0,1+e,0+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 8:{s(r,0,0,1+e,1+e,a,i,o),s(r,1,0,1+e,1+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 9:{s(r,1,0,1+e,1+e,a,i,n),s(r,1,0,1+e,1+e,a,i,n);break}case 10:{s(r,0,0,1+e,1+e,a,i,o),s(r,1,0,1+e,0+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 11:{s(r,1,0,1+e,1+e,a,i,o),s(r,1,0,1+e,0+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 12:{s(r,1,1,1+e,1+e,a,i,n);break}case 13:{s(r,1,1,1+e,1+e,a,i,o),s(r,1,0,1+e,1+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 14:{s(r,1,1,1+e,1+e,a,i,o),s(r,1,1,1+e,0+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}case 15:{s(r,1,1,1+e,1+e,a,i,o),s(r,1,0,1+e,0+e,a,i,c),n[0]=(o[0]+c[0])/2,n[1]=(o[1]+c[1])/2;break}}}function N(r,a,t){let i=[0,0];for(let n=0,o=r.length;n<o;++n){let c=r[n],e=c.data,m=c.width;for(let b=0;b<m;++b)for(let h=0;h<m;++h){t?Q(n,h,b,a[0],i):$(n,h,b,a,i);let w=(b*m+h)*2;e[w]=i[0]*255,e[w+1]=i[1]*255}}}function _(r,a,t,i,n,o,c){let e=c.data,m=c.width;for(let b=0,h=t.length;b<h;++b){let w=i[b],u=t[b],A=u.data,M=u.width;for(let k=0;k<n;++k)for(let y=0;y<n;++y){let G=w[0]*n+r+y,S=((w[1]*n+a+k)*m+G)*4,P=o?(k*k*M+y*y)*2:(k*M+y)*2;e[S]=A[P],e[S+1]=A[P+1],e[S+2]=0,e[S+3]=255}}}var L=class{static generate(){let a=10*x,t=H.length*5*x,i=new Uint8ClampedArray(a*t*4),n=new D(a,t,i),o=Math.pow(x-1,2)+1,c=[],e=[];for(let m=3,b=i.length;m<b;m+=4)i[m]=255;for(let m=0;m<16;++m)c.push(new D(o,o,new Uint8ClampedArray(o*o*2))),e.push(new D(v,v,new Uint8ClampedArray(v*v*2)));for(let m=0,b=H.length;m<b;++m)N(c,[H[m]],!0),_(0,5*x*m,c,K,x,!0,n);for(let m=0,b=T.length;m<b;++m)N(e,T[m],!1),_(5*x,4*v*m,e,B,v,!1,n);return n}};var O=new Map([[g(0,0,0,0),[0,0,0,0]],[g(0,0,0,1),[0,0,0,1]],[g(0,0,1,0),[0,0,1,0]],[g(0,0,1,1),[0,0,1,1]],[g(0,1,0,0),[0,1,0,0]],[g(0,1,0,1),[0,1,0,1]],[g(0,1,1,0),[0,1,1,0]],[g(0,1,1,1),[0,1,1,1]],[g(1,0,0,0),[1,0,0,0]],[g(1,0,0,1),[1,0,0,1]],[g(1,0,1,0),[1,0,1,0]],[g(1,0,1,1),[1,0,1,1]],[g(1,1,0,0),[1,1,0,0]],[g(1,1,0,1),[1,1,0,1]],[g(1,1,1,0),[1,1,1,0]],[g(1,1,1,1),[1,1,1,1]]]);function g(r,a,t,i){let n=I(r,a,.75),o=I(t,i,1-.25);return I(n,o,1-.125)}function z(r,a){let t=0;return a[3]===1&&(t+=1),t===1&&a[2]===1&&r[1]!==1&&r[3]!==1&&(t+=1),t}function Y(r,a){let t=0;return a[3]===1&&r[1]!==1&&r[3]!==1&&(t+=1),t===1&&a[2]===1&&r[0]!==1&&r[2]!==1&&(t+=1),t}var R=class{static generate(){let c=new Uint8ClampedArray(2178),e=new Uint8ClampedArray(1024*4);for(let m=0;m<33;++m)for(let b=0;b<66;++b){let h=.03125*b,w=.03125*m;if(O.has(h)&&O.has(w)){let u=O.get(h),A=O.get(w),M=m*66+b;c[M]=127*z(u,A),c[M+33]=127*Y(u,A)}}for(let m=0,b=17;b<33;++b)for(let h=0;h<64;++h,m+=4)e[m]=c[b*66+h],e[m+3]=255;return new D(64,16,e)}};self.addEventListener("message",()=>{let r=L.generate(),a=R.generate();self.postMessage({areaImageData:r,searchImageData:a},[r.data.buffer,a.data.buffer]),close()});})();\n';

// src/textures/smaa/SMAAImageGenerator.ts
function generate(useCache = true) {
  const workerURL = URL.createObjectURL(new Blob([worker_default2], {
    type: "text/javascript"
  }));
  const worker = new Worker(workerURL);
  URL.revokeObjectURL(workerURL);
  return new Promise((resolve, reject) => {
    worker.addEventListener("error", (event) => reject(event.error));
    worker.addEventListener("message", (event) => {
      const searchImageData = RawImageData.from(event.data.searchImageData);
      const areaImageData = RawImageData.from(event.data.areaImageData);
      const urls = [
        searchImageData.toCanvas().toDataURL("image/png", 1),
        areaImageData.toCanvas().toDataURL("image/png", 1)
      ];
      if (useCache) {
        localStorage.setItem("smaa-search", urls[0]);
        localStorage.setItem("smaa-area", urls[1]);
      }
      resolve(urls);
    });
    worker.postMessage(null);
  });
}
var SMAAImageGenerator = class {
  /**
   * Indicates whether data image caching is enabled.
   *
   * @defaultValue true
   */
  cacheEnabled;
  /**
   * Constructs a new SMAA image generator.
   */
  constructor() {
    this.cacheEnabled = true;
  }
  /**
   * Generates the SMAA data images.
   *
   * @example
   * SMAAImageGenerator.generate().then(([search, area]) => {
   *   const smaaEffect = new SMAAEffect(search, area);
   * });
   * @return A promise that returns the search image and area image as a pair.
   */
  async generate() {
    const useCache = this.cacheEnabled && window.localStorage !== void 0;
    const cachedURLs = useCache ? [
      localStorage.getItem("smaa-search"),
      localStorage.getItem("smaa-area")
    ] : [null, null];
    const promise = cachedURLs[0] !== null && cachedURLs[1] !== null ? Promise.resolve(cachedURLs) : generate(useCache);
    const urls = await promise;
    return await new Promise((resolve, reject) => {
      const searchImage = new Image();
      const areaImage = new Image();
      const manager = new LoadingManager2();
      manager.onLoad = () => resolve([searchImage, areaImage]);
      manager.onError = reject;
      searchImage.addEventListener("error", () => manager.itemError("smaa-search"));
      areaImage.addEventListener("error", () => manager.itemError("smaa-area"));
      searchImage.addEventListener("load", () => manager.itemEnd("smaa-search"));
      areaImage.addEventListener("load", () => manager.itemEnd("smaa-area"));
      manager.itemStart("smaa-search");
      manager.itemStart("smaa-area");
      searchImage.src = urls[0];
      areaImage.src = urls[1];
    });
  }
};

// src/textures/smaa/SMAASearchImageData.ts
var edges = /* @__PURE__ */ new Map([
  [bilinear(0, 0, 0, 0), [0, 0, 0, 0]],
  [bilinear(0, 0, 0, 1), [0, 0, 0, 1]],
  [bilinear(0, 0, 1, 0), [0, 0, 1, 0]],
  [bilinear(0, 0, 1, 1), [0, 0, 1, 1]],
  [bilinear(0, 1, 0, 0), [0, 1, 0, 0]],
  [bilinear(0, 1, 0, 1), [0, 1, 0, 1]],
  [bilinear(0, 1, 1, 0), [0, 1, 1, 0]],
  [bilinear(0, 1, 1, 1), [0, 1, 1, 1]],
  [bilinear(1, 0, 0, 0), [1, 0, 0, 0]],
  [bilinear(1, 0, 0, 1), [1, 0, 0, 1]],
  [bilinear(1, 0, 1, 0), [1, 0, 1, 0]],
  [bilinear(1, 0, 1, 1), [1, 0, 1, 1]],
  [bilinear(1, 1, 0, 0), [1, 1, 0, 0]],
  [bilinear(1, 1, 0, 1), [1, 1, 0, 1]],
  [bilinear(1, 1, 1, 0), [1, 1, 1, 0]],
  [bilinear(1, 1, 1, 1), [1, 1, 1, 1]]
]);
function bilinear(e0, e1, e2, e3) {
  const a = lerp(e0, e1, 1 - 0.25);
  const b = lerp(e2, e3, 1 - 0.25);
  return lerp(a, b, 1 - 0.125);
}
function deltaLeft(left, top) {
  let d = 0;
  if (top[3] === 1) {
    d += 1;
  }
  if (d === 1 && top[2] === 1 && left[1] !== 1 && left[3] !== 1) {
    d += 1;
  }
  return d;
}
function deltaRight(left, top) {
  let d = 0;
  if (top[3] === 1 && left[1] !== 1 && left[3] !== 1) {
    d += 1;
  }
  if (d === 1 && top[2] === 1 && left[0] !== 1 && left[2] !== 1) {
    d += 1;
  }
  return d;
}
var SMAASearchImageData = class {
  /**
   * Creates a new search image.
   *
   * @return The generated image data.
   */
  static generate() {
    const width = 66;
    const height = 33;
    const halfWidth = width / 2;
    const croppedWidth = 64;
    const croppedHeight = 16;
    const data = new Uint8ClampedArray(width * height);
    const croppedData = new Uint8ClampedArray(croppedWidth * croppedHeight * 4);
    for (let y = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        const s = 0.03125 * x;
        const t = 0.03125 * y;
        if (edges.has(s) && edges.has(t)) {
          const e1 = edges.get(s);
          const e2 = edges.get(t);
          const i = y * width + x;
          data[i] = 127 * deltaLeft(e1, e2);
          data[i + halfWidth] = 127 * deltaRight(e1, e2);
        }
      }
    }
    for (let i = 0, y = height - croppedHeight; y < height; ++y) {
      for (let x = 0; x < croppedWidth; ++x, i += 4) {
        croppedData[i] = data[y * width + x];
        croppedData[i + 3] = 255;
      }
    }
    return new RawImageData(croppedWidth, croppedHeight, croppedData);
  }
};

// src/textures/NoiseTexture.ts
import {
  DataTexture as DataTexture2,
  RedFormat as RedFormat2,
  RGFormat as RGFormat3,
  RGBAFormat as RGBAFormat4,
  UnsignedByteType as UnsignedByteType10
} from "three";
function getNoise(size, format, type) {
  const channels = /* @__PURE__ */ new Map([
    [RedFormat2, 1],
    [RGFormat3, 2],
    [RGBAFormat4, 4]
  ]);
  const c2 = channels.get(format);
  let data;
  if (c2 === void 0) {
    throw new Error(`Texture format not supported: ${format}`);
  }
  if (type === UnsignedByteType10) {
    data = new Uint8Array(size * c2);
    for (let i = 0, l = data.length; i < l; ++i) {
      data[i] = Math.random() * 255 + 0.5;
    }
  } else {
    data = new Float32Array(size * c2);
    for (let i = 0, l = data.length; i < l; ++i) {
      data[i] = Math.random();
    }
  }
  return data;
}
var NoiseTexture = class extends DataTexture2 {
  /**
   * Constructs a new noise texture.
   *
   * Supported texture formats: `RGBAFormat`, `RedFormat`, `RGFormat`.
   *
   * @param width - The width.
   * @param height - The height.
   * @param format - The texture format. Default is `RGBAFormat`.
   * @param type - The texture type.
   */
  constructor(width, height, format = RGBAFormat4, type = UnsignedByteType10) {
    super(getNoise(width * height, format, type), width, height, format, type);
    this.needsUpdate = true;
  }
};

// src/utils/functions/packing.ts
var unpackFactors = new Float32Array([
  255 / 256 / 256 ** 3,
  255 / 256 / 256 ** 2,
  255 / 256 / 256,
  255 / 256
]);
function unpackRGBAToFloat(packedDepth) {
  return (packedDepth[0] * unpackFactors[0] + packedDepth[1] * unpackFactors[1] + packedDepth[2] * unpackFactors[2] + packedDepth[3] * unpackFactors[3]) / 255;
}

// src/utils/functions/texture.ts
function getHash(texture) {
  const texture3D = texture;
  const attributes = [
    texture.wrapS,
    texture.wrapT,
    texture3D.wrapR || 0,
    texture.magFilter,
    texture.minFilter,
    texture.anisotropy,
    texture.internalFormat,
    texture.format,
    texture.type,
    texture.generateMipmaps,
    texture.premultiplyAlpha,
    texture.flipY,
    texture.unpackAlignment,
    texture.colorSpace
  ];
  return attributes.join(";");
}

// src/utils/DebugTools.ts
var DebugTools_exports = {};
__export(DebugTools_exports, {
  analyzePipeline: () => analyzePipeline
});
function toTextureId(textureIds, buffer) {
  if (buffer === null || buffer.value === null) {
    return "canvas";
  }
  const uuid = buffer instanceof RenderTargetResource ? buffer.value.texture.uuid : buffer.value.uuid;
  return uuid !== null ? textureIds.get(uuid) ?? "unknown" : "canvas";
}
function createTextureIds(passes, result = /* @__PURE__ */ new Map(), nextId = 0) {
  for (const pass of passes) {
    for (const buffer of pass.input.buffers.values()) {
      if (buffer.value !== null && !result.has(buffer.value.uuid)) {
        result.set(buffer.value.uuid, nextId++);
      }
    }
    for (const buffer of pass.output.buffers.values()) {
      if (buffer.value !== null && !result.has(buffer.value.texture.uuid)) {
        result.set(buffer.value.texture.uuid, nextId++);
      }
    }
    createTextureIds(pass.subpasses, result, nextId);
  }
  return result;
}
function analyzeDataFlow(passes, textureIds) {
  for (const pass of passes) {
    console.group(`${pass.name} p${pass.id}`);
    const { input, output } = pass;
    if (!pass.enabled) {
      console.debug("disabled");
    } else if (pass instanceof ClearPass) {
      console.debug("clears", toTextureId(textureIds, output.defaultBuffer));
    } else {
      if (input.buffers.size > 0) {
        const buffers = Array.from(input.buffers.values()).filter((x) => x.id !== input.defaultBuffer?.id);
        if (input.hasDefaultBuffer) {
          const defaultbufferId = toTextureId(textureIds, input.defaultBuffer);
          console.debug("reads", defaultbufferId, buffers.map((x) => toTextureId(textureIds, x)).join(" "));
        } else {
          console.debug("reads", buffers.map((x) => toTextureId(textureIds, x)).join(" "));
        }
      }
      if (output.buffers.size > 0) {
        const buffers = Array.from(output.buffers.values()).filter((x) => x.id !== output.defaultBuffer?.id);
        if (output.hasDefaultBuffer) {
          const defaultbufferId = toTextureId(textureIds, output.defaultBuffer);
          console.debug("writes", defaultbufferId, buffers.map((x) => toTextureId(textureIds, x)).join(" "));
        } else {
          console.debug("writes", buffers.map((x) => toTextureId(textureIds, x)).join(" "));
        }
      }
    }
    analyzeDataFlow(pass.subpasses, textureIds);
    console.groupEnd();
  }
}
function gatherInputResources(passes, result = /* @__PURE__ */ new Set()) {
  for (const pass of passes) {
    for (const resource of pass.input.buffers.values()) {
      result.add(resource);
    }
    gatherInputResources(pass.subpasses, result);
  }
  return result;
}
function gatherOutputResources(passes, result = /* @__PURE__ */ new Set()) {
  for (const pass of passes) {
    for (const resource of pass.output.buffers.values()) {
      result.add(resource);
    }
    gatherOutputResources(pass.subpasses, result);
  }
  return result;
}
function analyzeInputResources(passes, textureIds) {
  const resources = gatherInputResources(passes);
  for (const resource of resources) {
    console.debug(
      `${toTextureId(textureIds, resource)}:`,
      `(${resource.id})`,
      resource.value?.uuid
    );
  }
}
function analyzeOutputResources(passes, textureIds) {
  const resources = gatherOutputResources(passes);
  for (const resource of resources) {
    console.debug(
      `${toTextureId(textureIds, resource)}:`,
      `(${resource.id} \u2192 ${resource.texture.id})`,
      resource.texture.value?.uuid ?? "null"
    );
  }
}
function analyzePipeline(pipeline) {
  const textureIds = createTextureIds(pipeline.passes);
  console.debug("RenderPipeline", pipeline);
  console.groupCollapsed("Data Flow");
  analyzeDataFlow(pipeline.passes, textureIds);
  console.groupEnd();
  console.groupCollapsed("Resources");
  console.group("Input Buffers");
  analyzeInputResources(pipeline.passes, textureIds);
  console.groupEnd();
  console.group("Output Buffers");
  analyzeOutputResources(pipeline.passes, textureIds);
  console.groupEnd();
  console.groupEnd();
}
export {
  ASCIIEffect,
  ASCIITexture,
  AdaptiveLuminanceMaterial,
  AddBlendFunction,
  AlphaBlendFunction,
  AverageBlendFunction,
  Background,
  BackgroundMaterial,
  BlendFunction,
  BlendMode,
  BloomEffect,
  BokehMaterial,
  BoxBlurMaterial,
  BufferDebugMaterial,
  BufferDebugPass,
  CircleOfConfusionMaterial,
  ClearFlags,
  ClearPass,
  ClearValues,
  ColorBlendFunction,
  ColorBurnBlendFunction,
  ColorChannel,
  ColorDepthEffect,
  ColorDodgeBlendFunction,
  CopyMaterial,
  CopyPass,
  DarkenBlendFunction,
  DebugTools_exports as DebugTools,
  DepthCopyMaterial,
  DepthCopyMode,
  DepthCopyPass,
  DepthDownsamplingMaterial,
  DepthDownsamplingPass,
  DepthPickingPass,
  DepthTestStrategy,
  DifferenceBlendFunction,
  DisposableResource,
  DivideBlendFunction,
  DownsamplingMaterial,
  DstBlendFunction,
  Effect,
  EffectMaterial,
  EffectMaterialManager,
  EffectPass,
  EffectShaderData,
  EffectShaderSection,
  ExclusionBlendFunction,
  FXAAEffect,
  FullscreenMaterial,
  GBuffer,
  GBufferConfig,
  GBufferDebug,
  GBufferShaderPlugin,
  GData,
  GaussKernel,
  GaussianBlurMaterial,
  GaussianBlurPass,
  GeometryPass,
  GlitchMode,
  HalftoneEffect,
  HalftoneShape,
  HardLightBlendFunction,
  HardMixBlendFunction,
  HueBlendFunction,
  IOManager,
  IdManager,
  Input,
  InvertBlendFunction,
  InvertRGBBlendFunction,
  KawaseBlurMaterial,
  KernelSize,
  LUT1DEffect,
  LUT3DEffect,
  LambdaPass,
  LensDistortionEffect,
  LightenBlendFunction,
  LinearBurnBlendFunction,
  LinearDodgeBlendFunction,
  LinearLightBlendFunction,
  LookupTexture,
  LuminanceHighPassMaterial,
  LuminancePass,
  LuminosityBlendFunction,
  MaskFunction,
  MaskMaterial,
  MipmapBlurPass,
  MixBlendFunction,
  MultiplyBlendFunction,
  NegationBlendFunction,
  NoiseEffect,
  NoiseTexture,
  ObservableMap,
  ObservableSet,
  Output,
  OverlayBlendFunction,
  Pass,
  PinLightBlendFunction,
  RawImageData,
  ReflectBlendFunction,
  RenderPipeline,
  RenderTargetResource,
  Resolution,
  Resource,
  SMAAAreaImageData,
  SMAAEdgeDetectionMaterial,
  SMAAEdgeDetectionMode,
  SMAAEffect,
  SMAAImageGenerator,
  SMAAPredicationMode,
  SMAAPreset,
  SMAASearchImageData,
  SMAAWeightsMaterial,
  SaturationBlendFunction,
  ScanlineEffect,
  Scissor,
  ScreenBlendFunction,
  Selection,
  ShaderDataTracker,
  ShaderPass,
  SkyBoxMaterial,
  SoftLightBlendFunction,
  SrcBlendFunction,
  SubtractBlendFunction,
  TetrahedralUpscaler,
  TextureEffect,
  TextureResource,
  TiltShiftBlurMaterial,
  ToneMapping,
  ToneMappingEffect,
  UpsamplingMaterial,
  Viewport,
  VignetteEffect,
  VignetteTechnique,
  VividLightBlendFunction,
  extractIndices,
  extractOutputDefinitions,
  getHash,
  lerp,
  orthographicDepthToViewZ,
  prefixSubstrings,
  saturate,
  topologicalSort,
  unpackRGBAToFloat,
  version,
  viewZToOrthographicDepth
};
